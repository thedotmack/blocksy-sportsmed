<?php

/**
 * Generated stub declarations for Yoast.
 * @see https://yoast.com/
 * @see https://github.com/php-stubs/wordpress-seo-stubs
 */

namespace {
  /**
   * An interface for registering integrations with WordPress.
   */
  interface WPSEO_WordPress_Integration
  {
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * A WordPress integration that listens for whether the SEO changes have been saved successfully.
   */
  class WPSEO_Admin_Settings_Changed_Listener implements \WPSEO_WordPress_Integration
  {
    /**
     * Have the Yoast SEO settings been saved.
     *
     * @var bool
     */
    private static $settings_saved = \false;
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks and overwrites the wp_settings_errors global to determine whether the Yoast SEO settings have been saved.
     */
    public function intercept_save_update_notification()
    {
    }
    /**
     * Checks whether the settings notification is a settings_updated notification.
     *
     * @param array $wp_settings_error The settings object.
     *
     * @return bool Whether this is a settings updated settings notification.
     */
    public function is_settings_updated_notification($wp_settings_error)
    {
    }
    /**
     * Get whether the settings have successfully been saved
     *
     * @return bool Whether the settings have successfully been saved.
     */
    public function have_settings_been_saved()
    {
    }
    /**
     * Renders a success message if the Yoast SEO settings have been saved.
     */
    public function show_success_message()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Ajax
   */
  /**
   * Class WPSEO_Shortcode_Filter.
   *
   * Used for parsing WP shortcodes with AJAX.
   */
  class WPSEO_Shortcode_Filter
  {
    /**
     * Initialize the AJAX hooks.
     */
    public function __construct()
    {
    }
    /**
     * Parse the shortcodes.
     */
    public function do_filter()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Ajax
   */
  /**
   * This class will catch the request to dismiss the target notice (set by notice_name)
   * and will store the dismiss status as an user meta in the database.
   */
  class Yoast_Dismissable_Notice_Ajax
  {
    /**
     * Notice type toggle value for user notices.
     *
     * @var string
     */
    const FOR_USER = 'user_meta';
    /**
     * Notice type toggle value for network notices.
     *
     * @var string
     */
    const FOR_NETWORK = 'site_option';
    /**
     * Notice type toggle value for site notices.
     *
     * @var string
     */
    const FOR_SITE = 'option';
    /**
     * Name of the notice that will be dismissed.
     *
     * @var string
     */
    private $notice_name;
    /**
     * The type of the current notice.
     *
     * @var string
     */
    private $notice_type;
    /**
     * Initialize the hooks for the AJAX request.
     *
     * @param string $notice_name The name for the hook to catch the notice.
     * @param string $notice_type The notice type.
     */
    public function __construct($notice_name, $notice_type = self::FOR_USER)
    {
    }
    /**
     * Handles the dismiss notice request.
     */
    public function dismiss_notice()
    {
    }
    /**
     * Storing the dismissed value in the database. The target location is based on the set notification type.
     */
    private function save_dismissed()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Ajax
   */
  /**
   * Class Yoast_Plugin_Conflict_Ajax.
   */
  class Yoast_Plugin_Conflict_Ajax
  {
    /**
     * Option identifier where dismissed conflicts are stored.
     *
     * @var string
     */
    private $option_name = 'wpseo_dismissed_conflicts';
    /**
     * List of notification identifiers that have been dismissed.
     *
     * @var array
     */
    private $dismissed_conflicts = [];
    /**
     * Initialize the hooks for the AJAX request.
     */
    public function __construct()
    {
    }
    /**
     * Handles the dismiss notice request.
     */
    public function dismiss_notice()
    {
    }
    /**
     * Getting the user option from the database.
     *
     * @return bool|array
     */
    private function get_dismissed_option()
    {
    }
    /**
     * Getting the dismissed conflicts from the database
     *
     * @param string $plugin_section Type of conflict group (such as Open Graph or sitemap).
     *
     * @return array
     */
    private function get_dismissed_conflicts($plugin_section)
    {
    }
    /**
     * Storing the conflicting plugins as an user option in the database.
     *
     * @param string $plugin_section Plugin conflict type (such as Open Graph or sitemap).
     */
    private function save_dismissed_conflicts($plugin_section)
    {
    }
    /**
     * Loop through the plugins to compare them with the already stored dismissed plugin conflicts.
     *
     * @param array $posted_plugins Plugin set to check.
     */
    public function compare_plugins(array $posted_plugins)
    {
    }
    /**
     * Check if plugin is already dismissed, if not store it in the array that will be saved later.
     *
     * @param string $posted_plugin Plugin to check against dismissed conflicts.
     */
    private function compare_plugin($posted_plugin)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * Capability Manager interface.
   */
  interface WPSEO_Capability_Manager
  {
    /**
     * Registers a capability.
     *
     * @param string $capability Capability to register.
     * @param array  $roles      Roles to add the capability to.
     * @param bool   $overwrite  Optional. Use add or overwrite as registration method.
     */
    public function register($capability, array $roles, $overwrite = \false);
    /**
     * Adds the registerd capabilities to the system.
     */
    public function add();
    /**
     * Removes the registered capabilities from the system.
     */
    public function remove();
    /**
     * Returns the list of registered capabilities.
     *
     * @return string[] List of registered capabilities.
     */
    public function get_capabilities();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * Abstract Capability Manager shared code.
   */
  abstract class WPSEO_Abstract_Capability_Manager implements \WPSEO_Capability_Manager
  {
    /**
     * Registered capabilities.
     *
     * @var array
     */
    protected $capabilities = [];
    /**
     * Registers a capability.
     *
     * @param string $capability Capability to register.
     * @param array  $roles      Roles to add the capability to.
     * @param bool   $overwrite  Optional. Use add or overwrite as registration method.
     */
    public function register($capability, array $roles, $overwrite = \false)
    {
    }
    /**
     * Returns the list of registered capabilitities.
     *
     * @return string[] Registered capabilities.
     */
    public function get_capabilities()
    {
    }
    /**
     * Returns a list of WP_Role roles.
     *
     * The string array of role names are converted to actual WP_Role objects.
     * These are needed to be able to use the API on them.
     *
     * @param array $roles Roles to retrieve the objects for.
     *
     * @return WP_Role[] List of WP_Role objects.
     */
    protected function get_wp_roles(array $roles)
    {
    }
    /**
     * Filter capability roles.
     *
     * @param string $capability Capability to filter roles for.
     * @param array  $roles      List of roles which can be filtered.
     *
     * @return array Filtered list of roles for the capability.
     */
    protected function filter_roles($capability, array $roles)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * Capability Manager Factory.
   */
  class WPSEO_Capability_Manager_Factory
  {
    /**
     * Returns the Manager to use.
     *
     * @param string $plugin_type Whether it's Free or Premium.
     *
     * @return WPSEO_Capability_Manager Manager to use.
     */
    public static function get($plugin_type = 'free')
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * Integrates Yoast SEO capabilities with third party role manager plugins.
   *
   * Integrates with: Members
   * Integrates with: User Role Editor
   */
  class WPSEO_Capability_Manager_Integration implements \WPSEO_WordPress_Integration
  {
    /**
     * Capability manager to use.
     *
     * @var WPSEO_Capability_Manager
     */
    public $manager;
    /**
     * WPSEO_Capability_Manager_Integration constructor.
     *
     * @param WPSEO_Capability_Manager $manager The capability manager to use.
     */
    public function __construct(\WPSEO_Capability_Manager $manager)
    {
    }
    /**
     * Registers the hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Get the Yoast SEO capabilities.
     * Optionally append them to an existing array.
     *
     * @param  array $caps Optional existing capability list.
     * @return array
     */
    public function get_capabilities(array $caps = [])
    {
    }
    /**
     * Add capabilities to its own group in the Members plugin.
     *
     * @see members_register_cap_group()
     */
    public function action_members_register_cap_group()
    {
    }
    /**
     * Adds Yoast SEO capability group in the User Role Editor plugin.
     *
     * @see URE_Capabilities_Groups_Manager::get_groups_tree()
     *
     * @param array $groups Current groups.
     *
     * @return array Filtered list of capabilty groups.
     */
    public function filter_ure_capabilities_groups_tree($groups = [])
    {
    }
    /**
     * Adds capabilities to the Yoast SEO group in the User Role Editor plugin.
     *
     * @see URE_Capabilities_Groups_Manager::get_cap_groups()
     *
     * @param array  $groups Current capability groups.
     * @param string $cap_id Capability identifier.
     *
     * @return array List of filtered groups.
     */
    public function filter_ure_custom_capability_groups($groups = [], $cap_id = '')
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * VIP implementation of the Capability Manager.
   */
  final class WPSEO_Capability_Manager_VIP extends \WPSEO_Abstract_Capability_Manager
  {
    /**
     * Adds the registered capabilities to the system.
     *
     * @return void
     */
    public function add()
    {
    }
    /**
     * Removes the registered capabilities from the system
     *
     * @return void
     */
    public function remove()
    {
    }
    /**
     * Returns the roles which the capability is registered on.
     *
     * @param array  $role_capabilities List of all roles with their capabilities.
     * @param string $capability        Capability to filter roles for.
     * @param array  $roles             List of default roles.
     *
     * @return array List of capabilities.
     */
    protected function get_role_capabilities($role_capabilities, $capability, $roles)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * Default WordPress capability manager implementation.
   */
  final class WPSEO_Capability_Manager_WP extends \WPSEO_Abstract_Capability_Manager
  {
    /**
     * Adds the capabilities to the roles.
     *
     * @return void
     */
    public function add()
    {
    }
    /**
     * Unregisters the capabilities from the system.
     *
     * @return void
     */
    public function remove()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * Capability Utils collection.
   */
  class WPSEO_Capability_Utils
  {
    /**
     * Checks if the user has the proper capabilities.
     *
     * @param string $capability Capability to check.
     *
     * @return bool True if the user has the proper rights.
     */
    public static function current_user_can($capability)
    {
    }
    /**
     * Retrieves the users that have the specified capability.
     *
     * @param string $capability The name of the capability.
     *
     * @return array The users that have the capability.
     */
    public static function get_applicable_users($capability)
    {
    }
    /**
     * Retrieves the roles that have the specified capability.
     *
     * @param string $capability The name of the capability.
     *
     * @return array The names of the roles that have the capability.
     */
    public static function get_applicable_roles($capability)
    {
    }
    /**
     * Checks if the current user has at least one of the supplied capabilities.
     *
     * @param array $capabilities Capabilities to check against.
     *
     * @return bool True if the user has at least one capability.
     */
    protected static function has_any(array $capabilities)
    {
    }
    /**
     * Checks if the user has a certain capability.
     *
     * @param string $capability Capability to check against.
     *
     * @return bool True if the user has the capability.
     */
    protected static function has($capability)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Capabilities
   */
  /**
   * Capabilities registration class.
   */
  class WPSEO_Register_Capabilities implements \WPSEO_WordPress_Integration
  {
    /**
     * Registers the hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the capabilities.
     *
     * @return void
     */
    public function register()
    {
    }
    /**
     * Revokes the 'wpseo_manage_options' capability from administrator users if it should
     * only be granted to network administrators.
     *
     * @param array   $allcaps An array of all the user's capabilities.
     * @param array   $caps    Actual capabilities being checked.
     * @param array   $args    Optional parameters passed to has_cap(), typically object ID.
     * @param WP_User $user    The user object.
     *
     * @return array Possibly modified array of the user's capabilities.
     */
    public function filter_user_has_wpseo_manage_options_cap($allcaps, $caps, $args, $user)
    {
    }
    /**
     * Maybe add manage_privacy_options capability for wpseo_manager user role.
     *
     * @param string[] $caps Primitive capabilities required of the user.
     * @param string[] $cap  Capability being checked.
     *
     * @return string[] Filtered primitive capabilities required of the user.
     */
    public function map_meta_cap_for_seo_manager($caps, $cap)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents a way to determine an assets location.
   */
  interface WPSEO_Admin_Asset_Location
  {
    /**
     * Determines the URL of the asset on the dev server.
     *
     * @param WPSEO_Admin_Asset $asset The asset to determine the URL for.
     * @param string            $type  The type of asset. Usually JS or CSS.
     *
     * @return string The URL of the asset.
     */
    public function get_url(\WPSEO_Admin_Asset $asset, $type);
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents a way to determine the analysis worker asset location.
   */
  final class WPSEO_Admin_Asset_Analysis_Worker_Location implements \WPSEO_Admin_Asset_Location
  {
    /**
     * Holds the asset's location.
     *
     * @var WPSEO_Admin_Asset_Location
     */
    private $asset_location;
    /**
     * Holds the asset itself.
     *
     * @var WPSEO_Admin_Asset
     */
    private $asset;
    /**
     * Constructs the location of the analysis worker asset.
     *
     * @param string $flat_version The flat version of the asset.
     * @param string $name         The name of the analysis worker asset.
     */
    public function __construct($flat_version = '', $name = 'analysis-worker')
    {
    }
    /**
     * Retrieves the analysis worker asset.
     *
     * @return WPSEO_Admin_Asset The analysis worker asset.
     */
    public function get_asset()
    {
    }
    /**
     * Determines the URL of the asset on the dev server.
     *
     * @param WPSEO_Admin_Asset $asset The asset to determine the URL for.
     * @param string            $type  The type of asset. Usually JS or CSS.
     *
     * @return string The URL of the asset.
     */
    public function get_url(\WPSEO_Admin_Asset $asset, $type)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Changes the asset paths to dev server paths.
   */
  final class WPSEO_Admin_Asset_Dev_Server_Location implements \WPSEO_Admin_Asset_Location
  {
    /**
     * Holds the dev server's default URL.
     *
     * @var string
     */
    const DEFAULT_URL = 'http://localhost:8080';
    /**
     * Holds the url where the server is located.
     *
     * @var string
     */
    private $url;
    /**
     * Class constructor.
     *
     * @param string|null $url Where the dev server is located.
     */
    public function __construct($url = \null)
    {
    }
    /**
     * Determines the URL of the asset on the dev server.
     *
     * @param WPSEO_Admin_Asset $asset The asset to determine the URL for.
     * @param string            $type  The type of asset. Usually JS or CSS.
     *
     * @return string The URL of the asset.
     */
    public function get_url(\WPSEO_Admin_Asset $asset, $type)
    {
    }
    /**
     * Determines the URL of the asset not using the dev server.
     *
     * @param WPSEO_Admin_Asset $asset The asset to determine the URL for.
     * @param string            $type  The type of asset.
     *
     * @return string The URL of the asset file.
     */
    public function get_default_url(\WPSEO_Admin_Asset $asset, $type)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * This class registers all the necessary styles and scripts.
   *
   * Also has methods for the enqueing of scripts and styles.
   * It automatically adds a prefix to the handle.
   */
  class WPSEO_Admin_Asset_Manager
  {
    /**
     * Prefix for naming the assets.
     *
     * @var string
     */
    const PREFIX = 'yoast-seo-';
    /**
     * Class that manages the assets' location.
     *
     * @var WPSEO_Admin_Asset_Location
     */
    protected $asset_location;
    /**
     * Prefix for naming the assets.
     *
     * @var string
     */
    private $prefix;
    /**
     * Constructs a manager of assets. Needs a location to know where to register assets at.
     *
     * @param WPSEO_Admin_Asset_Location|null $asset_location The provider of the asset location.
     * @param string                          $prefix         The prefix for naming assets.
     */
    public function __construct(\WPSEO_Admin_Asset_Location $asset_location = \null, $prefix = self::PREFIX)
    {
    }
    /**
     * Enqueues scripts.
     *
     * @param string $script The name of the script to enqueue.
     */
    public function enqueue_script($script)
    {
    }
    /**
     * Enqueues styles.
     *
     * @param string $style The name of the style to enqueue.
     */
    public function enqueue_style($style)
    {
    }
    /**
     * Enqueues the appropriate language for the user.
     */
    public function enqueue_user_language_script()
    {
    }
    /**
     * Registers scripts based on it's parameters.
     *
     * @param WPSEO_Admin_Asset $script The script to register.
     */
    public function register_script(\WPSEO_Admin_Asset $script)
    {
    }
    /**
     * Registers styles based on it's parameters.
     *
     * @param WPSEO_Admin_Asset $style The style to register.
     */
    public function register_style(\WPSEO_Admin_Asset $style)
    {
    }
    /**
     * Calls the functions that register scripts and styles with the scripts and styles to be registered as arguments.
     */
    public function register_assets()
    {
    }
    /**
     * Registers all the scripts passed to it.
     *
     * @param array $scripts The scripts passed to it.
     */
    public function register_scripts($scripts)
    {
    }
    /**
     * Registers all the styles it receives.
     *
     * @param array $styles Styles that need to be registered.
     */
    public function register_styles($styles)
    {
    }
    /**
     * Localizes the script.
     *
     * @param string $handle      The script handle.
     * @param string $object_name The object name.
     * @param array  $data        The l10n data.
     */
    public function localize_script($handle, $object_name, $data)
    {
    }
    /**
     * Adds an inline script.
     *
     * @param string $handle   The script handle.
     * @param string $data     The l10n data.
     * @param string $position Optional. Whether to add the inline script before the handle or after.
     */
    public function add_inline_script($handle, $data, $position = 'after')
    {
    }
    /**
     * A list of styles that shouldn't be registered but are needed in other locations in the plugin.
     *
     * @return array
     */
    public function special_styles()
    {
    }
    /**
     * Flattens a version number for use in a filename.
     *
     * @param string $version The original version number.
     *
     * @return string The flattened version number.
     */
    public function flatten_version($version)
    {
    }
    /**
     * Creates a default location object for use in the admin asset manager.
     *
     * @return WPSEO_Admin_Asset_Location The location to use in the asset manager.
     */
    public static function create_default_location()
    {
    }
    /**
     * Checks if the given script is enqueued.
     *
     * @param string $script The script to check.
     *
     * @return bool True when the script is enqueued.
     */
    public function is_script_enqueued($script)
    {
    }
    /**
     * Returns the scripts that need to be registered.
     *
     * @todo Data format is not self-documenting. Needs explanation inline. R.
     *
     * @return array The scripts that need to be registered.
     */
    protected function scripts_to_be_registered()
    {
    }
    /**
     * Loads a generated asset file.
     *
     * @param array $args {
     *     The arguments.
     *
     *     @type string                  $asset_file      The asset file to load.
     *     @type int                     $ext_length      The length of the extension, including suffix, of the filename.
     *     @type string                  $suffix          Optional. The suffix of the asset name.
     *     @type array<string, string[]> $additional_deps Optional. The additional dependencies assets may have.
     *     @type string                  $base_dir        Optional. The base directory of the asset.
     *     @type string[]                $header_scripts  Optional. The script names that should be in the header.
     * }
     *
     * @return array {
     *     The scripts to be registered.
     *
     *     @type string   $name      The name of the asset.
     *     @type string   $src       The src of the asset.
     *     @type string[] $deps      The dependenies of the asset.
     *     @type bool     $in_footer Whether or not the asset should be in the footer.
     * }
     */
    protected function load_generated_asset_file($args)
    {
    }
    /**
     * Loads the scripts that should be renamed for BC.
     *
     * @return array {
     *     The scripts to be registered.
     *
     *     @type string   $name      The name of the asset.
     *     @type string   $src       The src of the asset.
     *     @type string[] $deps      The dependenies of the asset.
     *     @type bool     $in_footer Whether or not the asset should be in the footer.
     * }
     */
    protected function load_renamed_scripts()
    {
    }
    /**
     * Returns the styles that need to be registered.
     *
     * @todo Data format is not self-documenting. Needs explanation inline. R.
     *
     * @return array Styles that need to be registered.
     */
    protected function styles_to_be_registered()
    {
    }
    /**
     * Determines the URL of the asset.
     *
     * @param WPSEO_Admin_Asset $asset The asset to determine the URL for.
     * @param string            $type  The type of asset. Usually JS or CSS.
     *
     * @return string The URL of the asset.
     */
    protected function get_url(\WPSEO_Admin_Asset $asset, $type)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Determines the location of an asset within the SEO plugin.
   */
  final class WPSEO_Admin_Asset_SEO_Location implements \WPSEO_Admin_Asset_Location
  {
    /**
     * Path to the plugin file.
     *
     * @var string
     */
    protected $plugin_file;
    /**
     * Whether or not to add the file suffix to the asset.
     *
     * @var bool
     */
    protected $add_suffix = \true;
    /**
     * The plugin file to base the asset location upon.
     *
     * @param string $plugin_file The plugin file string.
     * @param bool   $add_suffix  Optional. Whether or not a file suffix should be added.
     */
    public function __construct($plugin_file, $add_suffix = \true)
    {
    }
    /**
     * Determines the URL of the asset on the dev server.
     *
     * @param WPSEO_Admin_Asset $asset The asset to determine the URL for.
     * @param string            $type  The type of asset. Usually JS or CSS.
     *
     * @return string The URL of the asset.
     */
    public function get_url(\WPSEO_Admin_Asset $asset, $type)
    {
    }
    /**
     * Determines the path relative to the plugin folder of an asset.
     *
     * @param WPSEO_Admin_Asset $asset The asset to determine the path for.
     * @param string            $type  The type of asset.
     *
     * @return string The path to the asset file.
     */
    protected function get_path(\WPSEO_Admin_Asset $asset, $type)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Localizes JavaScript files.
   *
   * @codeCoverageIgnore
   * @deprecated 18.0
   */
  final class WPSEO_Admin_Asset_Yoast_Components_L10n
  {
    /**
     * Represents the asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * WPSEO_Admin_Asset_Yoast_Components_L10n constructor.
     *
     * @codeCoverageIgnore
     * @deprecated 18.0
     */
    public function __construct()
    {
    }
    /**
     * Localizes the given script with the JavaScript translations.
     *
     * @codeCoverageIgnore
     * @deprecated 18.0
     *
     * @param string $script_handle The script handle to localize for.
     *
     * @return void
     */
    public function localize_script($script_handle)
    {
    }
    /**
     * Returns translations necessary for JS files.
     *
     * @codeCoverageIgnore
     * @deprecated 18.0
     *
     * @param string $component The component to retrieve the translations for.
     * @return object|null The translations in a Jed format for JS files.
     */
    protected function get_translations($component)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Determines the editor specific replacement variables.
   */
  class WPSEO_Admin_Editor_Specific_Replace_Vars
  {
    /**
     * Holds the editor specific replacements variables.
     *
     * @var array The editor specific replacement variables.
     */
    protected $replacement_variables = [
      // Posts types.
      'page' => ['id', 'pt_single', 'pt_plural', 'parent_title'],
      'post' => ['id', 'term404', 'pt_single', 'pt_plural'],
      // Custom post type.
      'custom_post_type' => ['id', 'term404', 'pt_single', 'pt_plural', 'parent_title'],
      // Settings - archive pages.
      'custom-post-type_archive' => ['pt_single', 'pt_plural'],
      // Taxonomies.
      'category' => ['term_title', 'term_description', 'category_description', 'parent_title', 'term_hierarchy'],
      'post_tag' => ['term_title', 'term_description', 'tag_description'],
      'post_format' => ['term_title'],
      // Custom taxonomy.
      'term-in-custom-taxonomy' => ['term_title', 'term_description', 'category_description', 'parent_title', 'term_hierarchy'],
      // Settings - special pages.
      'search' => ['searchphrase'],
    ];
    /**
     * WPSEO_Admin_Editor_Specific_Replace_Vars constructor.
     */
    public function __construct()
    {
    }
    /**
     * Retrieves the editor specific replacement variables.
     *
     * @return array The editor specific replacement variables.
     */
    public function get()
    {
    }
    /**
     * Retrieves the generic replacement variable names.
     *
     * Which are the replacement variables without the editor specific ones.
     *
     * @param array $replacement_variables Possibly generic replacement variables.
     *
     * @return array The generic replacement variable names.
     */
    public function get_generic($replacement_variables)
    {
    }
    /**
     * Determines the page type of the current term.
     *
     * @param string $taxonomy The taxonomy name.
     *
     * @return string The page type.
     */
    public function determine_for_term($taxonomy)
    {
    }
    /**
     * Determines the page type of the current post.
     *
     * @param WP_Post $post A WordPress post instance.
     *
     * @return string The page type.
     */
    public function determine_for_post($post)
    {
    }
    /**
     * Determines the page type for a post type.
     *
     * @param string $post_type The name of the post_type.
     * @param string $fallback  The page type to fall back to.
     *
     * @return string The page type.
     */
    public function determine_for_post_type($post_type, $fallback = 'custom_post_type')
    {
    }
    /**
     * Determines the page type for an archive page.
     *
     * @param string $name     The name of the archive.
     * @param string $fallback The page type to fall back to.
     *
     * @return string The page type.
     */
    public function determine_for_archive($name, $fallback = 'custom-post-type_archive')
    {
    }
    /**
     * Adds the replavement variables for the given page types.
     *
     * @param array $page_types                   Page types to add variables for.
     * @param array $replacement_variables_to_add The variables to add.
     *
     * @return void
     */
    protected function add_for_page_types(array $page_types, array $replacement_variables_to_add)
    {
    }
    /**
     * Extracts the names from the given replacements variables.
     *
     * @param array $replacement_variables Replacement variables to extract the name from.
     *
     * @return array Extracted names.
     */
    protected function extract_names($replacement_variables)
    {
    }
    /**
     * Returns whether the given page type has editor specific replace vars.
     *
     * @param string $page_type The page type to check.
     *
     * @return bool True if there are associated editor specific replace vars.
     */
    protected function has_for_page_type($page_type)
    {
    }
    /**
     * Merges all editor specific replacement variables into one array and removes duplicates.
     *
     * @return array The list of unique editor specific replacement variables.
     */
    protected function get_unique_replacement_variables()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Handles the Gutenberg Compatibility notification showing and hiding.
   */
  class WPSEO_Admin_Gutenberg_Compatibility_Notification implements \WPSEO_WordPress_Integration
  {
    /**
     * Notification ID to use.
     *
     * @var string
     */
    private $notification_id = 'wpseo-outdated-gutenberg-plugin';
    /**
     * Instance of gutenberg compatibility checker.
     *
     * @var WPSEO_Gutenberg_Compatibility
     */
    protected $compatibility_checker;
    /**
     * Instance of Yoast Notification Center.
     *
     * @var Yoast_Notification_Center
     */
    protected $notification_center;
    /**
     * WPSEO_Admin_Gutenberg_Compatibility_Notification constructor.
     */
    public function __construct()
    {
    }
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Manages if the notification should be shown or removed.
     *
     * @return void
     */
    public function manage_notification()
    {
    }
    /**
     * Adds the notification to the notificaton center.
     *
     * @return void
     */
    protected function add_notification()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates the HTML for an inline Help Button and Panel.
   */
  class WPSEO_Admin_Help_Panel
  {
    /**
     * Unique identifier of the element the inline help refers to, used as an identifier in the html.
     *
     * @var string
     */
    private $id;
    /**
     * The Help Button text. Needs a properly escaped string.
     *
     * @var string
     */
    private $help_button_text;
    /**
     * The Help Panel content. Needs a properly escaped string (might contain HTML).
     *
     * @var string
     */
    private $help_content;
    /**
     * Optional Whether to print out a container div element for the Help Panel, used for styling.
     *
     * @var string
     */
    private $wrapper;
    /**
     * Constructor.
     *
     * @param string $id               Unique identifier of the element the inline help refers to, used as
     *                                 an identifier in the html.
     * @param string $help_button_text The Help Button text. Needs a properly escaped string.
     * @param string $help_content     The Help Panel content. Needs a properly escaped string (might contain HTML).
     * @param string $wrapper          Optional Whether to print out a container div element for the Help Panel,
     *                                 used for styling.
     *                                 Pass a `has-wrapper` value to print out the container. Default: no container.
     */
    public function __construct($id, $help_button_text, $help_content, $wrapper = '')
    {
    }
    /**
     * Returns the html for the Help Button.
     *
     * @return string
     */
    public function get_button_html()
    {
    }
    /**
     * Returns the html for the Help Panel.
     *
     * @return string
     */
    public function get_panel_html()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Performs the load on admin side.
   */
  class WPSEO_Admin_Init
  {
    /**
     * Holds the global `$pagenow` variable's value.
     *
     * @var string
     */
    private $pagenow;
    /**
     * Holds the asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $asset_manager;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Enqueue our styling for dismissible yoast notifications.
     */
    public function enqueue_dismissible()
    {
    }
    /**
     * Removes any notification for incomplete translations.
     *
     * @return void
     */
    public function remove_translations_notification()
    {
    }
    /**
     * Creates an unsupported PHP version notification in the notification center.
     *
     * @return void
     */
    public function unsupported_php_notice()
    {
    }
    /**
     * Gets the latest released major WordPress version from the WordPress stable-check api.
     *
     * @return float|int The latest released major WordPress version. 0 when the stable-check API doesn't respond.
     */
    private function get_latest_major_wordpress_version()
    {
    }
    /**
     * Helper to verify if the user is currently visiting one of our admin pages.
     *
     * @return bool
     */
    private function on_wpseo_admin_page()
    {
    }
    /**
     * Whether we should load the meta box classes.
     *
     * @return bool true if we should load the meta box classes, false otherwise.
     */
    private function should_load_meta_boxes()
    {
    }
    /**
     * Determine whether we should load the meta box class and if so, load it.
     */
    private function load_meta_boxes()
    {
    }
    /**
     * Determine if we should load our taxonomy edit class and if so, load it.
     */
    private function load_taxonomy_class()
    {
    }
    /**
     * Determine if we should load our admin pages class and if so, load it.
     *
     * Loads admin page class for all admin pages starting with `wpseo_`.
     */
    private function load_admin_user_class()
    {
    }
    /**
     * Determine if we should load our admin pages class and if so, load it.
     *
     * Loads admin page class for all admin pages starting with `wpseo_`.
     */
    private function load_admin_page_class()
    {
    }
    /**
     * Loads the plugin suggestions.
     */
    private function load_plugin_suggestions()
    {
    }
    /**
     * Registers the Premium Upsell Admin Block.
     *
     * @return void
     */
    private function register_premium_upsell_admin_block()
    {
    }
    /**
     * See if we should start our XML Sitemaps Admin class.
     */
    private function load_xml_sitemaps_admin()
    {
    }
    /**
     * Shows deprecation warnings to the user if a plugin has registered a filter we have deprecated.
     */
    public function show_hook_deprecation_warnings()
    {
    }
    /**
     * Check if the permalink uses %postname%.
     *
     * @return bool
     */
    private function has_postname_in_permalink()
    {
    }
    /**
     * Shows a notice on the permalink settings page.
     */
    public function permalink_settings_notice()
    {
    }
    /**
     * Adds a custom Yoast section within the Classic Editor publish box.
     *
     * @param \WP_Post $post The current post object.
     *
     * @return void
     */
    public function add_publish_box_section($post)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Determines the recommended replacement variables based on the context.
   */
  class WPSEO_Admin_Recommended_Replace_Vars
  {
    /**
     * The recommended replacement variables.
     *
     * @var array
     */
    protected $recommended_replace_vars = [
      // Posts types.
      'page' => ['sitename', 'title', 'sep', 'primary_category'],
      'post' => ['sitename', 'title', 'sep', 'primary_category'],
      // Homepage.
      'homepage' => ['sitename', 'sitedesc', 'sep'],
      // Custom post type.
      'custom_post_type' => ['sitename', 'title', 'sep'],
      // Taxonomies.
      'category' => ['sitename', 'term_title', 'sep', 'term_hierarchy'],
      'post_tag' => ['sitename', 'term_title', 'sep'],
      'post_format' => ['sitename', 'term_title', 'sep', 'page'],
      // Custom taxonomy.
      'term-in-custom-taxonomy' => ['sitename', 'term_title', 'sep', 'term_hierarchy'],
      // Settings - archive pages.
      'author_archive' => ['sitename', 'title', 'sep', 'page'],
      'date_archive' => ['sitename', 'sep', 'date', 'page'],
      'custom-post-type_archive' => ['sitename', 'title', 'sep', 'page'],
      // Settings - special pages.
      'search' => ['sitename', 'searchphrase', 'sep', 'page'],
      '404' => ['sitename', 'sep'],
    ];
    /**
     * Determines the page type of the current term.
     *
     * @param string $taxonomy The taxonomy name.
     *
     * @return string The page type.
     */
    public function determine_for_term($taxonomy)
    {
    }
    /**
     * Determines the page type of the current post.
     *
     * @param WP_Post $post A WordPress post instance.
     *
     * @return string The page type.
     */
    public function determine_for_post($post)
    {
    }
    /**
     * Determines the page type for a post type.
     *
     * @param string $post_type The name of the post_type.
     * @param string $fallback  The page type to fall back to.
     *
     * @return string The page type.
     */
    public function determine_for_post_type($post_type, $fallback = 'custom_post_type')
    {
    }
    /**
     * Determines the page type for an archive page.
     *
     * @param string $name     The name of the archive.
     * @param string $fallback The page type to fall back to.
     *
     * @return string The page type.
     */
    public function determine_for_archive($name, $fallback = 'custom-post-type_archive')
    {
    }
    /**
     * Retrieves the recommended replacement variables for the given page type.
     *
     * @param string $page_type The page type.
     *
     * @return array The recommended replacement variables.
     */
    public function get_recommended_replacevars_for($page_type)
    {
    }
    /**
     * Retrieves the recommended replacement variables.
     *
     * @return array The recommended replacement variables.
     */
    public function get_recommended_replacevars()
    {
    }
    /**
     * Returns whether the given page type has recommended replace vars.
     *
     * @param array  $recommended_replace_vars The recommended replace vars
     *                                         to check in.
     * @param string $page_type                The page type to check.
     *
     * @return bool True if there are associated recommended replace vars.
     */
    private function has_recommended_replace_vars($recommended_replace_vars, $page_type)
    {
    }
    /**
     * Determines whether or not a post is the homepage.
     *
     * @param WP_Post $post The WordPress global post object.
     *
     * @return bool True if the given post is the homepage.
     */
    private function is_homepage($post)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   * @since   1.8.0
   */
  /**
   * Customizes user profile.
   */
  class WPSEO_Admin_User_Profile
  {
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Clear author sitemap cache when settings are changed.
     *
     * @since 3.1
     *
     * @param int    $meta_id   The ID of the meta option changed.
     * @param int    $object_id The ID of the user.
     * @param string $meta_key  The key of the meta field changed.
     */
    public function clear_author_sitemap_cache($meta_id, $object_id, $meta_key)
    {
    }
    /**
     * Updates the user metas that (might) have been set on the user profile page.
     *
     * @param int $user_id User ID of the updated user.
     */
    public function process_user_option_update($user_id)
    {
    }
    /**
     * Add the inputs needed for SEO values to the User Profile page.
     *
     * @param WP_User $user User instance to output for.
     */
    public function user_profile($user)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents the utils for the admin.
   */
  class WPSEO_Admin_Utils
  {
    /**
     * Gets the install URL for the passed plugin slug.
     *
     * @param string $slug The slug to create an install link for.
     *
     * @return string The install URL. Empty string if the current user doesn't have the proper capabilities.
     */
    public static function get_install_url($slug)
    {
    }
    /**
     * Gets the activation URL for the passed plugin slug.
     *
     * @param string $slug The slug to create an activation link for.
     *
     * @return string The activation URL. Empty string if the current user doesn't have the proper capabilities.
     */
    public static function get_activation_url($slug)
    {
    }
    /**
     * Creates a link if the passed plugin is deemend a directly-installable plugin.
     *
     * @param array $plugin The plugin to create the link for.
     *
     * @return string The link to the plugin install. Returns the title if the plugin is deemed a Premium product.
     */
    public static function get_install_link($plugin)
    {
    }
    /**
     * Gets a visually hidden accessible message for links that open in a new browser tab.
     *
     * @return string The visually hidden accessible message.
     */
    public static function get_new_tab_message()
    {
    }
  }
  /**
   * Class that holds most of the admin functionality for Yoast SEO.
   */
  class WPSEO_Admin
  {
    /**
     * The page identifier used in WordPress to register the admin page.
     *
     * !DO NOT CHANGE THIS!
     *
     * @var string
     */
    const PAGE_IDENTIFIER = 'wpseo_dashboard';
    /**
     * Array of classes that add admin functionality.
     *
     * @var array
     */
    protected $admin_features;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Schedules a rewrite flush to happen at shutdown.
     */
    public function schedule_rewrite_flush()
    {
    }
    /**
     * Returns all the classes for the admin features.
     *
     * @return array
     */
    public function get_admin_features()
    {
    }
    /**
     * Register assets needed on admin pages.
     */
    public function enqueue_assets()
    {
    }
    /**
     * Returns the manage_options capability.
     *
     * @return string The capability to use.
     */
    public function get_manage_options_cap()
    {
    }
    /**
     * Maps the manage_options cap on saving an options page to wpseo_manage_options.
     */
    public function map_manage_options_cap()
    {
    }
    /**
     * Adds the ability to choose how many posts are displayed per page
     * on the bulk edit pages.
     */
    public function bulk_edit_options()
    {
    }
    /**
     * Saves the posts per page limit for bulk edit pages.
     *
     * @param int    $status Status value to pass through.
     * @param string $option Option name.
     * @param int    $value  Count value to check.
     *
     * @return int
     */
    public function save_bulk_edit_options($status, $option, $value)
    {
    }
    /**
     * Adds links to Premium Support and FAQ under the plugin in the plugin overview page.
     *
     * @param array  $links Array of links for the plugins, adapted when the current plugin is found.
     * @param string $file  The filename for the current plugin, which the filter loops through.
     *
     * @return array
     */
    public function add_action_link($links, $file)
    {
    }
    /**
     * Enqueues the (tiny) global JS needed for the plugin.
     */
    public function config_page_scripts()
    {
    }
    /**
     * Enqueues the (tiny) global stylesheet needed for the plugin.
     */
    public function enqueue_global_style()
    {
    }
    /**
     * Filter the $contactmethods array and add a set of social profiles.
     *
     * These are used with the Facebook author, rel="author" and Twitter cards implementation.
     *
     * @param array $contactmethods Currently set contactmethods.
     *
     * @return array Contactmethods with added contactmethods.
     */
    public function update_contactmethods($contactmethods)
    {
    }
    /**
     * Log the updated timestamp for user profiles when theme is changed.
     */
    public function switch_theme()
    {
    }
    /**
     * Localization for the dismiss urls.
     *
     * @return array
     */
    private function localize_admin_global_script()
    {
    }
    /**
     * Sets the upsell notice.
     */
    protected function set_upsell_notice()
    {
    }
    /**
     * Whether we are on the admin dashboard page.
     *
     * @return bool
     */
    protected function on_dashboard_page()
    {
    }
    /**
     * Loads the cornerstone filter.
     *
     * @return WPSEO_WordPress_Integration[] The integrations to initialize.
     */
    protected function initialize_cornerstone_content()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents a WPSEO asset
   */
  class WPSEO_Admin_Asset
  {
    /**
     * Constant used to identify file type as a JS file.
     *
     * @var string
     */
    const TYPE_JS = 'js';
    /**
     * Constant used to identify file type as a CSS file.
     *
     * @var string
     */
    const TYPE_CSS = 'css';
    /**
     * The name option identifier.
     *
     * @var string
     */
    const NAME = 'name';
    /**
     * The source option identifier.
     *
     * @var string
     */
    const SRC = 'src';
    /**
     * The dependencies option identifier.
     *
     * @var string
     */
    const DEPS = 'deps';
    /**
     * The version option identifier.
     *
     * @var string
     */
    const VERSION = 'version';
    /* Style specific. */
    /**
     * The media option identifier.
     *
     * @var string
     */
    const MEDIA = 'media';
    /**
     * The rtl option identifier.
     *
     * @var string
     */
    const RTL = 'rtl';
    /* Script specific. */
    /**
     * The "in footer" option identifier.
     *
     * @var string
     */
    const IN_FOOTER = 'in_footer';
    /**
     * Asset identifier.
     *
     * @var string
     */
    protected $name;
    /**
     * Path to the asset.
     *
     * @var string
     */
    protected $src;
    /**
     * Asset dependencies.
     *
     * @var string|array
     */
    protected $deps;
    /**
     * Asset version.
     *
     * @var string
     */
    protected $version;
    /**
     * For CSS Assets. The type of media for which this stylesheet has been defined.
     *
     * See https://www.w3.org/TR/CSS2/media.html#media-types.
     *
     * @var string
     */
    protected $media;
    /**
     * For JS Assets. Whether or not the script should be loaded in the footer.
     *
     * @var bool
     */
    protected $in_footer;
    /**
     * For CSS Assets. Whether this stylesheet is a right-to-left stylesheet.
     *
     * @var bool
     */
    protected $rtl;
    /**
     * File suffix.
     *
     * @var string
     */
    protected $suffix;
    /**
     * Default asset arguments.
     *
     * @var array
     */
    private $defaults = ['deps' => [], 'in_footer' => \true, 'rtl' => \true, 'media' => 'all', 'version' => '', 'suffix' => ''];
    /**
     * Constructs an instance of the WPSEO_Admin_Asset class.
     *
     * @param array $args The arguments for this asset.
     *
     * @throws InvalidArgumentException Throws when no name or src has been provided.
     */
    public function __construct(array $args)
    {
    }
    /**
     * Returns the asset identifier.
     *
     * @return string
     */
    public function get_name()
    {
    }
    /**
     * Returns the path to the asset.
     *
     * @return string
     */
    public function get_src()
    {
    }
    /**
     * Returns the asset dependencies.
     *
     * @return array|string
     */
    public function get_deps()
    {
    }
    /**
     * Returns the asset version.
     *
     * @return string|null
     */
    public function get_version()
    {
    }
    /**
     * Returns the media type for CSS assets.
     *
     * @return string
     */
    public function get_media()
    {
    }
    /**
     * Returns whether a script asset should be loaded in the footer of the page.
     *
     * @return bool
     */
    public function is_in_footer()
    {
    }
    /**
     * Returns whether this CSS has a RTL counterpart.
     *
     * @return bool
     */
    public function has_rtl()
    {
    }
    /**
     * Returns the file suffix.
     *
     * @return string
     */
    public function get_suffix()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Bulk Editor
   * @since   1.5.0
   */
  /**
   * Implements table for bulk editing.
   */
  class WPSEO_Bulk_List_Table extends \WP_List_Table
  {
    /**
     * The nonce that was passed with the request.
     *
     * @var string
     */
    private $nonce;
    /**
     * Array of post types for which the current user has `edit_others_posts` capabilities.
     *
     * @var array
     */
    private $all_posts;
    /**
     * Array of post types for which the current user has `edit_posts` capabilities, but not `edit_others_posts`.
     *
     * @var array
     */
    private $own_posts;
    /**
     * Saves all the metadata into this array.
     *
     * @var array
     */
    protected $meta_data = [];
    /**
     * The current requested page_url.
     *
     * @var string
     */
    private $request_url = '';
    /**
     * The current page (depending on $_GET['paged']) if current tab is for current page_type, else it will be 1.
     *
     * @var int
     */
    private $current_page;
    /**
     * The current post filter, if is used (depending on $_GET['post_type_filter']).
     *
     * @var string
     */
    private $current_filter;
    /**
     * The current post status, if is used (depending on $_GET['post_status']).
     *
     * @var string
     */
    private $current_status;
    /**
     * The current sorting, if used (depending on $_GET['order'] and $_GET['orderby']).
     *
     * @var string
     */
    private $current_order;
    /**
     * The page_type for current class instance (for example: title / description).
     *
     * @var string
     */
    protected $page_type;
    /**
     * Based on the page_type ($this->page_type) there will be constructed an url part, for subpages and
     * navigation.
     *
     * @var string
     */
    protected $page_url;
    /**
     * The settings which will be used in the __construct.
     *
     * @var array
     */
    protected $settings;
    /**
     * Holds the pagination config.
     *
     * @var array
     */
    protected $pagination = [];
    /**
     * Holds the sanitized data from the user input.
     *
     * @var array
     */
    protected $input_fields = [];
    /**
     * Class constructor.
     *
     * @param array $args The arguments.
     */
    public function __construct($args = [])
    {
    }
    /**
     * Prepares the data and renders the page.
     */
    public function show_page()
    {
    }
    /**
     * Used in the constructor to build a reference list of post types the current user can edit.
     */
    protected function populate_editable_post_types()
    {
    }
    /**
     * Will show the navigation for the table like page navigation and page filter.
     *
     * @param string $which Table nav location (such as top).
     */
    public function display_tablenav($which)
    {
    }
    /**
     * This function builds the base sql subquery used in this class.
     *
     * This function takes into account the post types in which the current user can
     * edit all posts, and the ones the current user can only edit his/her own.
     *
     * @return string The subquery, which should always be used in $wpdb->prepare(),
     *                passing the current user_id in as the first parameter.
     */
    public function get_base_subquery()
    {
    }
    /**
     * Gets the views.
     *
     * @return array The views.
     */
    public function get_views()
    {
    }
    /**
     * Outputs extra table navigation.
     *
     * @param string $which Table nav location (such as top).
     */
    public function extra_tablenav($which)
    {
    }
    /**
     * Gets a list of sortable columns.
     *
     * The format is: 'internal-name' => array( 'orderby', bool ).
     *
     * @return array
     */
    public function get_sortable_columns()
    {
    }
    /**
     * Sets the correct pagenumber and pageurl for the navigation.
     */
    public function prepare_page_navigation()
    {
    }
    /**
     * Preparing the requested pagerows and setting the needed variables.
     */
    public function prepare_items()
    {
    }
    /**
     * Getting the columns for first row.
     *
     * @return array
     */
    public function get_columns()
    {
    }
    /**
     * Setting the column headers.
     */
    protected function set_column_headers()
    {
    }
    /**
     * Counting total items.
     *
     * @param string $subquery         SQL FROM part.
     * @param string $all_states       SQL IN part.
     * @param string $post_type_clause SQL post type part.
     *
     * @return mixed
     */
    protected function count_items($subquery, $all_states, $post_type_clause)
    {
    }
    /**
     * Getting the post_type_clause filter.
     *
     * @return string
     */
    protected function get_post_type_clause()
    {
    }
    /**
     * Setting the pagination.
     *
     * Total items is the number of all visible items.
     *
     * @param int $total_items Total items counts.
     */
    protected function set_pagination($total_items)
    {
    }
    /**
     * Parse the query to get items from database.
     *
     * Based on given parameters there will be parse a query which will get all the pages/posts and other post_types
     * from the database.
     *
     * @param string $subquery         SQL FROM part.
     * @param string $all_states       SQL IN part.
     * @param string $post_type_clause SQL post type part.
     *
     * @return string
     */
    protected function parse_item_query($subquery, $all_states, $post_type_clause)
    {
    }
    /**
     * Heavily restricts the possible columns by which a user can order the table
     * in the bulk editor, thereby preventing a possible CSRF vulnerability.
     *
     * @param string $orderby The column by which we want to order.
     *
     * @return string
     */
    protected function sanitize_orderby($orderby)
    {
    }
    /**
     * Makes sure the order clause is always ASC or DESC for the bulk editor table,
     * thereby preventing a possible CSRF vulnerability.
     *
     * @param string $order Whether we want to sort ascending or descending.
     *
     * @return string SQL order string (ASC, DESC).
     */
    protected function sanitize_order($order)
    {
    }
    /**
     * Getting all the items.
     *
     * @param string $query SQL query to use.
     */
    protected function get_items($query)
    {
    }
    /**
     * Getting all the states.
     *
     * @return string
     */
    protected function get_all_states()
    {
    }
    /**
     * Based on $this->items and the defined columns, the table rows will be displayed.
     */
    public function display_rows()
    {
    }
    /**
     * Getting the attributes for each table cell.
     *
     * @param string $column_name         Column name string.
     * @param array  $hidden              Set of hidden columns.
     * @param string $classes             Additional CSS classes.
     * @param string $column_display_name Column display name string.
     *
     * @return string
     */
    protected function column_attributes($column_name, $hidden, $classes, $column_display_name)
    {
    }
    /**
     * Parsing the title.
     *
     * @param WP_Post $rec Post object.
     *
     * @return string
     */
    protected function parse_page_title_column($rec)
    {
    }
    /**
     * Parsing the column based on the $column_name.
     *
     * @param string  $column_name Column name.
     * @param WP_Post $rec         Post object.
     *
     * @return string
     */
    protected function parse_column($column_name, $rec)
    {
    }
    /**
     * Parse the field where the existing meta-data value is displayed.
     *
     * @param int        $record_id  Record ID.
     * @param string     $attributes HTML attributes.
     * @param bool|array $values     Optional values data array.
     *
     * @return string
     */
    protected function parse_meta_data_field($record_id, $attributes, $values = \false)
    {
    }
    /**
     * Method for setting the meta data, which belongs to the records that will be shown on the current page.
     *
     * This method will loop through the current items ($this->items) for getting the post_id. With this data
     * ($needed_ids) the method will query the meta-data table for getting the title.
     */
    protected function get_meta_data()
    {
    }
    /**
     * Getting all post_ids from to $this->items.
     *
     * @return array
     */
    protected function get_post_ids()
    {
    }
    /**
     * Getting the meta_data from database.
     *
     * @param array $post_ids Post IDs for SQL IN part.
     *
     * @return mixed
     */
    protected function get_meta_data_result(array $post_ids)
    {
    }
    /**
     * Setting $this->meta_data.
     *
     * @param array $meta_data Meta data set.
     */
    protected function parse_meta_data($meta_data)
    {
    }
    /**
     * This method will merge general array with given parameter $columns.
     *
     * @param array $columns Optional columns set.
     *
     * @return array
     */
    protected function merge_columns($columns = [])
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Bulk Editor
   * @since   1.5.0
   */
  /**
   * Implements table for bulk description editing.
   */
  class WPSEO_Bulk_Description_List_Table extends \WPSEO_Bulk_List_Table
  {
    /**
     * Current type for this class will be (meta) description.
     *
     * @var string
     */
    protected $page_type = 'description';
    /**
     * Settings with are used in __construct.
     *
     * @var array
     */
    protected $settings = ['singular' => 'wpseo_bulk_description', 'plural' => 'wpseo_bulk_descriptions', 'ajax' => \true];
    /**
     * The field in the database where meta field is saved.
     *
     * @var string
     */
    protected $target_db_field = 'metadesc';
    /**
     * The columns shown on the table.
     *
     * @return array
     */
    public function get_columns()
    {
    }
    /**
     * Parse the metadescription.
     *
     * @param string $column_name Column name.
     * @param object $record      Data object.
     * @param string $attributes  HTML attributes.
     *
     * @return string
     */
    protected function parse_page_specific_column($column_name, $record, $attributes)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Bulk Editor
   * @since   1.5.0
   */
  /**
   * Implements table for bulk title editing.
   */
  class WPSEO_Bulk_Title_Editor_List_Table extends \WPSEO_Bulk_List_Table
  {
    /**
     * Current type for this class will be title.
     *
     * @var string
     */
    protected $page_type = 'title';
    /**
     * Settings with are used in __construct.
     *
     * @var array
     */
    protected $settings = ['singular' => 'wpseo_bulk_title', 'plural' => 'wpseo_bulk_titles', 'ajax' => \true];
    /**
     * The field in the database where meta field is saved.
     *
     * @var string
     */
    protected $target_db_field = 'title';
    /**
     * The columns shown on the table.
     *
     * @return array
     */
    public function get_columns()
    {
    }
    /**
     * Parse the title columns.
     *
     * @param string $column_name Column name.
     * @param object $record      Data object.
     * @param string $attributes  HTML attributes.
     *
     * @return string
     */
    protected function parse_page_specific_column($column_name, $record, $attributes)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Collects the data from the added collection objects.
   */
  class WPSEO_Collector
  {
    /**
     * Holds the collections.
     *
     * @var WPSEO_Collection[]
     */
    protected $collections = [];
    /**
     * Adds a collection object to the collections.
     *
     * @param WPSEO_Collection $collection The collection object to add.
     */
    public function add_collection(\WPSEO_Collection $collection)
    {
    }
    /**
     * Collects the data from the collection objects.
     *
     * @return array The collected data.
     */
    public function collect()
    {
    }
    /**
     * Returns the collected data as a JSON encoded string.
     *
     * @return false|string The encode string.
     */
    public function get_as_json()
    {
    }
  }
  /**
   * Class WPSEO_Admin_Pages.
   *
   * Class with functionality for the Yoast SEO admin pages.
   */
  class WPSEO_Admin_Pages
  {
    /**
     * The option in use for the current admin page.
     *
     * @var string
     */
    public $currentoption = 'wpseo';
    /**
     * Holds the asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $asset_manager;
    /**
     * Class constructor, which basically only hooks the init function on the init hook.
     */
    public function __construct()
    {
    }
    /**
     * Make sure the needed scripts are loaded for admin pages.
     */
    public function init()
    {
    }
    /**
     * Loads the required styles for the config page.
     */
    public function config_page_styles()
    {
    }
    /**
     * Loads the required scripts for the config page.
     */
    public function config_page_scripts()
    {
    }
    /**
     * Retrieves some variables that are needed for replacing variables in JS.
     *
     * @deprecated 20.3
     * @codeCoverageIgnore
     *
     * @return array The replacement and recommended replacement variables.
     */
    public function get_replace_vars_script_data()
    {
    }
    /**
     * Enqueues and handles all the tool dependencies.
     */
    private function enqueue_tools_scripts()
    {
    }
    /**
     * Returns the appropriate shortlink for the Webinar.
     *
     * @return string The shortlink for the Webinar.
     */
    private function get_webinar_shortlink()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Customizer
   */
  /**
   * Class with functionality to support WP SEO settings in WordPress Customizer.
   */
  class WPSEO_Customizer
  {
    /**
     * Holds the customize manager.
     *
     * @var WP_Customize_Manager
     */
    protected $wp_customize;
    /**
     * Template for the setting IDs used for the customizer.
     *
     * @var string
     */
    private $setting_template = 'wpseo_titles[%s]';
    /**
     * Default arguments for the breadcrumbs customizer settings object.
     *
     * @var array
     */
    private $default_setting_args = ['default' => '', 'type' => 'option', 'transport' => 'refresh'];
    /**
     * Default arguments for the breadcrumbs customizer control object.
     *
     * @var array
     */
    private $default_control_args = ['label' => '', 'type' => 'text', 'section' => 'wpseo_breadcrumbs_customizer_section', 'settings' => '', 'context' => ''];
    /**
     * Construct Method.
     */
    public function __construct()
    {
    }
    /**
     * Function to support WordPress Customizer.
     *
     * @param WP_Customize_Manager $wp_customize Manager class instance.
     */
    public function wpseo_customize_register($wp_customize)
    {
    }
    /**
     * Add the breadcrumbs section to the customizer.
     */
    private function breadcrumbs_section()
    {
    }
    /**
     * Returns whether or not the breadcrumbs are active.
     *
     * @return bool
     */
    public function breadcrumbs_active_callback()
    {
    }
    /**
     * Adds the breadcrumbs show blog checkbox.
     */
    private function breadcrumbs_blog_show_setting()
    {
    }
    /**
     * Returns whether or not to show the breadcrumbs blog show option.
     *
     * @return bool
     */
    public function breadcrumbs_blog_show_active_cb()
    {
    }
    /**
     * Adds the breadcrumbs separator text field.
     */
    private function breadcrumbs_separator_setting()
    {
    }
    /**
     * Adds the breadcrumbs home anchor text field.
     */
    private function breadcrumbs_home_setting()
    {
    }
    /**
     * Adds the breadcrumbs prefix text field.
     */
    private function breadcrumbs_prefix_setting()
    {
    }
    /**
     * Adds the breadcrumbs archive prefix text field.
     */
    private function breadcrumbs_archiveprefix_setting()
    {
    }
    /**
     * Adds the breadcrumbs search prefix text field.
     */
    private function breadcrumbs_searchprefix_setting()
    {
    }
    /**
     * Adds the breadcrumb 404 prefix text field.
     */
    private function breadcrumbs_404_setting()
    {
    }
    /**
     * Adds the customizer setting and control.
     *
     * @param string      $index           Array key index to use for the customizer setting.
     * @param array       $control_args    Customizer control object arguments.
     *                                     Only those different from the default need to be passed.
     * @param string|null $id              Optional. Customizer control object ID.
     *                                     Will default to 'wpseo-' . $index.
     * @param array       $custom_settings Optional. Customizer setting arguments.
     *                                     Only those different from the default need to be passed.
     */
    private function add_setting_and_control($index, $control_args, $id = \null, $custom_settings = [])
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents the proxy for communicating with the database.
   */
  class WPSEO_Database_Proxy
  {
    /**
     * Holds the table name.
     *
     * @var string
     */
    protected $table_name;
    /**
     * Determines whether to suppress errors or not.
     *
     * @var bool
     */
    protected $suppress_errors = \true;
    /**
     * Determines if this table is multisite.
     *
     * @var bool
     */
    protected $is_multisite_table = \false;
    /**
     * Holds the last suppressed state.
     *
     * @var bool
     */
    protected $last_suppressed_state;
    /**
     * Holds the WordPress database object.
     *
     * @var wpdb
     */
    protected $database;
    /**
     * Sets the class attributes and registers the table.
     *
     * @param wpdb   $database           The database object.
     * @param string $table_name         The table name that is represented.
     * @param bool   $suppress_errors    Should the errors be suppressed.
     * @param bool   $is_multisite_table Should the table be global in multisite.
     */
    public function __construct($database, $table_name, $suppress_errors = \true, $is_multisite_table = \false)
    {
    }
    /**
     * Inserts data into the database.
     *
     * @param array             $data   Data to insert.
     * @param array|string|null $format Formats for the data.
     *
     * @return false|int Total amount of inserted rows or false on error.
     */
    public function insert(array $data, $format = \null)
    {
    }
    /**
     * Updates data in the database.
     *
     * @param array             $data         Data to update on the table.
     * @param array             $where        Where condition as key => value array.
     * @param array|string|null $format       Optional. Data prepare format.
     * @param array|string|null $where_format Optional. Where prepare format.
     *
     * @return false|int False when the update request is invalid, int on number of rows changed.
     */
    public function update(array $data, array $where, $format = \null, $where_format = \null)
    {
    }
    /**
     * Upserts data in the database.
     *
     * Performs an insert into and if key is duplicate it will update the existing record.
     *
     * @param array             $data         Data to update on the table.
     * @param array|null        $where        Unused. Where condition as key => value array.
     * @param array|string|null $format       Optional. Data prepare format.
     * @param array|string|null $where_format Optional. Where prepare format.
     *
     * @return false|int False when the upsert request is invalid, int on number of rows changed.
     */
    public function upsert(array $data, array $where = \null, $format = \null, $where_format = \null)
    {
    }
    /**
     * Deletes a record from the database.
     *
     * @param array             $where  Where clauses for the query.
     * @param array|string|null $format Formats for the data.
     *
     * @return false|int
     */
    public function delete(array $where, $format = \null)
    {
    }
    /**
     * Executes the given query and returns the results.
     *
     * @param string $query The query to execute.
     *
     * @return array|object|null The resultset
     */
    public function get_results($query)
    {
    }
    /**
     * Creates a table to the database.
     *
     * @param array $columns The columns to create.
     * @param array $indexes The indexes to use.
     *
     * @return bool True when creation is successful.
     */
    public function create_table(array $columns, array $indexes = [])
    {
    }
    /**
     * Checks if there is an error.
     *
     * @return bool Returns true when there is an error.
     */
    public function has_error()
    {
    }
    /**
     * Executed before a query will be ran.
     */
    protected function pre_execution()
    {
    }
    /**
     * Executed after a query has been ran.
     */
    protected function post_execution()
    {
    }
    /**
     * Returns the full table name.
     *
     * @return string Full table name including prefix.
     */
    public function get_table_name()
    {
    }
    /**
     * Returns the prefix to use for the table.
     *
     * @return string The table prefix depending on the database context.
     */
    protected function get_table_prefix()
    {
    }
    /**
     * Registers the table with WordPress.
     *
     * @return void
     */
    protected function register_table()
    {
    }
    /**
     * Checks if the table has been registered with WordPress.
     *
     * @return bool True if the table is registered, false otherwise.
     */
    protected function is_table_registered()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Export
   */
  /**
   * Class WPSEO_Export.
   *
   * Class with functionality to export the WP SEO settings.
   */
  class WPSEO_Export
  {
    /**
     * Holds the nonce action.
     *
     * @var string
     */
    const NONCE_ACTION = 'wpseo_export';
    /**
     * Holds the export data.
     *
     * @var string
     */
    private $export = '';
    /**
     * Holds whether the export was a success.
     *
     * @var bool
     */
    public $success;
    /**
     * Handles the export request.
     */
    public function export()
    {
    }
    /**
     * Outputs the export.
     */
    public function output()
    {
    }
    /**
     * Exports the current site's WP SEO settings.
     */
    private function export_settings()
    {
    }
    /**
     * Writes the header of the export.
     */
    private function export_header()
    {
    }
    /**
     * Writes a line to the export.
     *
     * @param string $line          Line string.
     * @param bool   $newline_first Boolean flag whether to prepend with new line.
     */
    private function write_line($line, $newline_first = \false)
    {
    }
    /**
     * Writes an entire option group to the export.
     *
     * @param string $opt_group Option group name.
     */
    private function write_opt_group($opt_group)
    {
    }
    /**
     * Writes a settings line to the export.
     *
     * @param string $key Key string.
     * @param string $val Value string.
     */
    private function write_setting($key, $val)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Exposes shortlinks in a global, so that we can pass them to our Javascript components.
   */
  class WPSEO_Expose_Shortlinks implements \WPSEO_WordPress_Integration
  {
    /**
     * Array containing the keys and shortlinks.
     *
     * @var array
     */
    private $shortlinks = ['shortlinks.advanced.allow_search_engines' => 'https://yoa.st/allow-search-engines', 'shortlinks.advanced.follow_links' => 'https://yoa.st/follow-links', 'shortlinks.advanced.meta_robots' => 'https://yoa.st/meta-robots-advanced', 'shortlinks.advanced.breadcrumbs_title' => 'https://yoa.st/breadcrumbs-title', 'shortlinks.metabox.schema.explanation' => 'https://yoa.st/400', 'shortlinks.metabox.schema.page_type' => 'https://yoa.st/402', 'shortlinks.sidebar.schema.explanation' => 'https://yoa.st/401', 'shortlinks.sidebar.schema.page_type' => 'https://yoa.st/403', 'shortlinks.focus_keyword_info' => 'https://yoa.st/focus-keyword', 'shortlinks.nofollow_sponsored' => 'https://yoa.st/nofollow-sponsored', 'shortlinks.snippet_preview_info' => 'https://yoa.st/snippet-preview', 'shortlinks.cornerstone_content_info' => 'https://yoa.st/1i9', 'shortlinks.upsell.social_preview.facebook' => 'https://yoa.st/social-preview-facebook', 'shortlinks.upsell.social_preview.twitter' => 'https://yoa.st/social-preview-twitter', 'shortlinks.upsell.sidebar.news' => 'https://yoa.st/get-news-sidebar', 'shortlinks.upsell.sidebar.focus_keyword_synonyms_link' => 'https://yoa.st/textlink-synonyms-popup-sidebar', 'shortlinks.upsell.sidebar.focus_keyword_synonyms_button' => 'https://yoa.st/keyword-synonyms-popup-sidebar', 'shortlinks.upsell.sidebar.premium_seo_analysis_button' => 'https://yoa.st/premium-seo-analysis-sidebar', 'shortlinks.upsell.sidebar.focus_keyword_additional_link' => 'https://yoa.st/textlink-keywords-popup-sidebar', 'shortlinks.upsell.sidebar.focus_keyword_additional_button' => 'https://yoa.st/add-keywords-popup-sidebar', 'shortlinks.upsell.sidebar.additional_link' => 'https://yoa.st/textlink-keywords-sidebar', 'shortlinks.upsell.sidebar.additional_button' => 'https://yoa.st/add-keywords-sidebar', 'shortlinks.upsell.sidebar.keyphrase_distribution' => 'https://yoa.st/keyphrase-distribution-sidebar', 'shortlinks.upsell.sidebar.word_complexity' => 'https://yoa.st/word-complexity-sidebar', 'shortlinks.upsell.metabox.news' => 'https://yoa.st/get-news-metabox', 'shortlinks.upsell.metabox.go_premium' => 'https://yoa.st/pe-premium-page', 'shortlinks.upsell.metabox.focus_keyword_synonyms_link' => 'https://yoa.st/textlink-synonyms-popup-metabox', 'shortlinks.upsell.metabox.focus_keyword_synonyms_button' => 'https://yoa.st/keyword-synonyms-popup', 'shortlinks.upsell.metabox.premium_seo_analysis_button' => 'https://yoa.st/premium-seo-analysis-metabox', 'shortlinks.upsell.metabox.focus_keyword_additional_link' => 'https://yoa.st/textlink-keywords-popup-metabox', 'shortlinks.upsell.metabox.focus_keyword_additional_button' => 'https://yoa.st/add-keywords-popup', 'shortlinks.upsell.metabox.additional_link' => 'https://yoa.st/textlink-keywords-metabox', 'shortlinks.upsell.metabox.additional_button' => 'https://yoa.st/add-keywords-metabox', 'shortlinks.upsell.metabox.keyphrase_distribution' => 'https://yoa.st/keyphrase-distribution-metabox', 'shortlinks.upsell.metabox.word_complexity' => 'https://yoa.st/word-complexity-metabox', 'shortlinks.upsell.gsc.create_redirect_button' => 'https://yoa.st/redirects', 'shortlinks.readability_analysis_info' => 'https://yoa.st/readability-analysis', 'shortlinks.inclusive_language_analysis_info' => 'https://yoa.st/inclusive-language-analysis', 'shortlinks.activate_premium_info' => 'https://yoa.st/activate-subscription', 'shortlinks.upsell.sidebar.morphology_upsell_metabox' => 'https://yoa.st/morphology-upsell-metabox', 'shortlinks.upsell.sidebar.morphology_upsell_sidebar' => 'https://yoa.st/morphology-upsell-sidebar', 'shortlinks.semrush.volume_help' => 'https://yoa.st/3-v', 'shortlinks.semrush.trend_help' => 'https://yoa.st/3-v', 'shortlinks.semrush.prices' => 'https://yoa.st/semrush-prices', 'shortlinks.semrush.premium_landing_page' => 'https://yoa.st/413', 'shortlinks.wincher.seo_performance' => 'https://yoa.st/wincher-integration', 'shortlinks-insights-estimated_reading_time' => 'https://yoa.st/4fd', 'shortlinks-insights-flesch_reading_ease' => 'https://yoa.st/34r', 'shortlinks-insights-flesch_reading_ease_sidebar' => 'https://yoa.st/4mf', 'shortlinks-insights-flesch_reading_ease_metabox' => 'https://yoa.st/4mg', 'shortlinks-insights-flesch_reading_ease_article' => 'https://yoa.st/34s', 'shortlinks-insights-keyword_research_link' => 'https://yoa.st/keyword-research-metabox', 'shortlinks-insights-upsell-sidebar-prominent_words' => 'https://yoa.st/prominent-words-upsell-sidebar', 'shortlinks-insights-upsell-metabox-prominent_words' => 'https://yoa.st/prominent-words-upsell-metabox', 'shortlinks-insights-upsell-elementor-prominent_words' => 'https://yoa.st/prominent-words-upsell-elementor', 'shortlinks-insights-word_count' => 'https://yoa.st/word-count', 'shortlinks-insights-upsell-sidebar-text_formality' => 'https://yoa.st/formality-upsell-sidebar', 'shortlinks-insights-upsell-metabox-text_formality' => 'https://yoa.st/formality-upsell-metabox', 'shortlinks-insights-upsell-elementor-text_formality' => 'https://yoa.st/formality-upsell-elementor', 'shortlinks-insights-text_formality_info_free' => 'https://yoa.st/formality-free', 'shortlinks-insights-text_formality_info_premium' => 'https://yoa.st/formality'];
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds shortlinks to the passed array.
     *
     * @param array $input The array to add shortlinks to.
     *
     * @return array The passed array with the additional shortlinks.
     */
    public function expose_shortlinks($input)
    {
    }
    /**
     * Retrieves the shortlinks.
     *
     * @return array The shortlinks.
     */
    private function get_shortlinks()
    {
    }
    /**
     * Checks if the current page is a term edit page.
     *
     * @return bool True when page is term edit.
     */
    private function is_term_edit()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Gutenberg_Compatibility
   */
  /**
   * Class WPSEO_Gutenberg_Compatibility
   */
  class WPSEO_Gutenberg_Compatibility
  {
    /**
     * The currently released version of Gutenberg.
     *
     * @var string
     */
    const CURRENT_RELEASE = '15.4.0';
    /**
     * The minimally supported version of Gutenberg by the plugin.
     *
     * @var string
     */
    const MINIMUM_SUPPORTED = '15.4.0';
    /**
     * Holds the current version.
     *
     * @var string
     */
    protected $current_version = '';
    /**
     * WPSEO_Gutenberg_Compatibility constructor.
     */
    public function __construct()
    {
    }
    /**
     * Determines whether or not Gutenberg is installed.
     *
     * @return bool Whether or not Gutenberg is installed.
     */
    public function is_installed()
    {
    }
    /**
     * Determines whether or not the currently installed version of Gutenberg is below the minimum supported version.
     *
     * @return bool True if the currently installed version is below the minimum supported version. False otherwise.
     */
    public function is_below_minimum()
    {
    }
    /**
     * Gets the currently installed version.
     *
     * @return string The currently installed version.
     */
    public function get_installed_version()
    {
    }
    /**
     * Determines whether or not the currently installed version of Gutenberg is the latest, fully compatible version.
     *
     * @return bool Whether or not the currently installed version is fully compatible.
     */
    public function is_fully_compatible()
    {
    }
    /**
     * Gets the latest released version of Gutenberg.
     *
     * @return string The latest release.
     */
    protected function get_latest_release()
    {
    }
    /**
     * Gets the minimum supported version of Gutenberg.
     *
     * @return string The minumum supported release.
     */
    protected function get_minimum_supported_version()
    {
    }
    /**
     * Detects the currently installed Gutenberg version.
     *
     * @return string The currently installed Gutenberg version. Empty if the version couldn't be detected.
     */
    protected function detect_installed_gutenberg_version()
    {
    }
  }
  /**
   * Class WPSEO_Meta_Columns.
   */
  class WPSEO_Meta_Columns
  {
    /**
     * Holds the context objects for each indexable.
     *
     * @var Meta_Tags_Context[]
     */
    protected $context = [];
    /**
     * Holds the SEO analysis.
     *
     * @var WPSEO_Metabox_Analysis_SEO
     */
    private $analysis_seo;
    /**
     * Holds the readability analysis.
     *
     * @var WPSEO_Metabox_Analysis_Readability
     */
    private $analysis_readability;
    /**
     * Admin columns cache.
     *
     * @var Admin_Columns_Cache_Integration
     */
    private $admin_columns_cache;
    /**
     * Holds the Score_Icon_Helper.
     *
     * @var Score_Icon_Helper
     */
    private $score_icon_helper;
    /**
     * When page analysis is enabled, just initialize the hooks.
     */
    public function __construct()
    {
    }
    /**
     * Sets up up the hooks.
     */
    public function setup_hooks()
    {
    }
    /**
     * Adds the column headings for the SEO plugin for edit posts / pages overview.
     *
     * @param array $columns Already existing columns.
     *
     * @return array Array containing the column headings.
     */
    public function column_heading($columns)
    {
    }
    /**
     * Displays the column content for the given column.
     *
     * @param string $column_name Column to display the content for.
     * @param int    $post_id     Post to display the column content for.
     */
    public function column_content($column_name, $post_id)
    {
    }
    /**
     * Indicates which of the SEO columns are sortable.
     *
     * @param array $columns Appended with their orderby variable.
     *
     * @return array Array containing the sortable columns.
     */
    public function column_sort($columns)
    {
    }
    /**
     * Hides the SEO title, meta description and focus keyword columns if the user hasn't chosen which columns to hide.
     *
     * @param array $hidden The hidden columns.
     *
     * @return array Array containing the columns to hide.
     */
    public function column_hidden($hidden)
    {
    }
    /**
     * Adds a dropdown that allows filtering on the posts SEO Quality.
     */
    public function posts_filter_dropdown()
    {
    }
    /**
     * Adds a dropdown that allows filtering on the posts Readability Quality.
     *
     * @return void
     */
    public function posts_filter_dropdown_readability()
    {
    }
    /**
     * Generates an <option> element.
     *
     * @param string $value    The option's value.
     * @param string $label    The option's label.
     * @param string $selected HTML selected attribute for an option.
     *
     * @return string The generated <option> element.
     */
    protected function generate_option($value, $label, $selected = '')
    {
    }
    /**
     * Returns the meta object for a given post ID.
     *
     * @param int $post_id The post ID.
     *
     * @return Meta The meta object.
     */
    protected function get_meta($post_id)
    {
    }
    /**
     * Determines the SEO score filter to be later used in the meta query, based on the passed SEO filter.
     *
     * @param string $seo_filter The SEO filter to use to determine what further filter to apply.
     *
     * @return array The SEO score filter.
     */
    protected function determine_seo_filters($seo_filter)
    {
    }
    /**
     * Determines the Readability score filter to the meta query, based on the passed Readability filter.
     *
     * @param string $readability_filter The Readability filter to use to determine what further filter to apply.
     *
     * @return array The Readability score filter.
     */
    protected function determine_readability_filters($readability_filter)
    {
    }
    /**
     * Creates a keyword filter for the meta query, based on the passed Keyword filter.
     *
     * @param string $keyword_filter The keyword filter to use.
     *
     * @return array The keyword filter.
     */
    protected function get_keyword_filter($keyword_filter)
    {
    }
    /**
     * Determines whether the passed filter is considered to be valid.
     *
     * @param mixed $filter The filter to check against.
     *
     * @return bool Whether the filter is considered valid.
     */
    protected function is_valid_filter($filter)
    {
    }
    /**
     * Collects the filters and merges them into a single array.
     *
     * @return array Array containing all the applicable filters.
     */
    protected function collect_filters()
    {
    }
    /**
     * Modify the query based on the filters that are being passed.
     *
     * @param array $vars Query variables that need to be modified based on the filters.
     *
     * @return array Array containing the meta query to use for filtering the posts overview.
     */
    public function column_sort_orderby($vars)
    {
    }
    /**
     * Retrieves the meta robots query values to be used within the meta query.
     *
     * @return array Array containing the query parameters regarding meta robots.
     */
    protected function get_meta_robots_query_values()
    {
    }
    /**
     * Determines the score filters to be used. If more than one is passed, it created an AND statement for the query.
     *
     * @param array $score_filters Array containing the score filters.
     *
     * @return array Array containing the score filters that need to be applied to the meta query.
     */
    protected function determine_score_filters($score_filters)
    {
    }
    /**
     * Retrieves the post type from the $_GET variable.
     *
     * @return string|null The sanitized current post type or null when the variable is not set in $_GET.
     */
    public function get_current_post_type()
    {
    }
    /**
     * Retrieves the SEO filter from the $_GET variable.
     *
     * @return string|null The sanitized seo filter or null when the variable is not set in $_GET.
     */
    public function get_current_seo_filter()
    {
    }
    /**
     * Retrieves the Readability filter from the $_GET variable.
     *
     * @return string|null The sanitized readability filter or null when the variable is not set in $_GET.
     */
    public function get_current_readability_filter()
    {
    }
    /**
     * Retrieves the keyword filter from the $_GET variable.
     *
     * @return string|null The sanitized seo keyword filter or null when the variable is not set in $_GET.
     */
    public function get_current_keyword_filter()
    {
    }
    /**
     * Uses the vars to create a complete filter query that can later be executed to filter out posts.
     *
     * @param array $vars    Array containing the variables that will be used in the meta query.
     * @param array $filters Array containing the filters that we need to apply in the meta query.
     *
     * @return array Array containing the complete filter query.
     */
    protected function build_filter_query($vars, $filters)
    {
    }
    /**
     * Creates a Readability score filter.
     *
     * @param number $low  The lower boundary of the score.
     * @param number $high The higher boundary of the score.
     *
     * @return array The Readability Score filter.
     */
    protected function create_readability_score_filter($low, $high)
    {
    }
    /**
     * Creates an SEO score filter.
     *
     * @param number $low  The lower boundary of the score.
     * @param number $high The higher boundary of the score.
     *
     * @return array The SEO score filter.
     */
    protected function create_seo_score_filter($low, $high)
    {
    }
    /**
     * Creates a filter to retrieve posts that were set to no-index.
     *
     * @return array Array containin the no-index filter.
     */
    protected function create_no_index_filter()
    {
    }
    /**
     * Creates a filter to retrieve posts that have no keyword set.
     *
     * @return array Array containing the no focus keyword filter.
     */
    protected function create_no_focus_keyword_filter()
    {
    }
    /**
     * Determines whether a particular post_id is of an indexable post type.
     *
     * @param string $post_id The post ID to check.
     *
     * @return bool Whether or not it is indexable.
     */
    protected function is_indexable($post_id)
    {
    }
    /**
     * Determines whether the given post ID uses the default indexing settings.
     *
     * @param int $post_id The post ID to check.
     *
     * @return bool Whether or not the default indexing is being used for the post.
     */
    protected function uses_default_indexing($post_id)
    {
    }
    /**
     * Returns filters when $order_by is matched in the if-statement.
     *
     * @param string $order_by The ID of the column by which to order the posts.
     *
     * @return array Array containing the order filters.
     */
    private function filter_order_by($order_by)
    {
    }
    /**
     * Parses the score column.
     *
     * @param int $post_id The ID of the post for which to show the score.
     *
     * @return string The HTML for the SEO score indicator.
     */
    private function parse_column_score($post_id)
    {
    }
    /**
     * Parsing the readability score column.
     *
     * @param int $post_id The ID of the post for which to show the readability score.
     *
     * @return string The HTML for the readability score indicator.
     */
    private function parse_column_score_readability($post_id)
    {
    }
    /**
     * Sets up the hooks for the post_types.
     */
    private function set_post_type_hooks()
    {
    }
    /**
     * Wraps the WPSEO_Metabox check to determine whether the metabox should be displayed either by
     * choice of the admin or because the post type is not a public post type.
     *
     * @since 7.0
     *
     * @param string|null $post_type Optional. The post type to test, defaults to the current post post_type.
     *
     * @return bool Whether or not the meta box (and associated columns etc) should be hidden.
     */
    private function display_metabox($post_type = \null)
    {
    }
    /**
     * Determines whether or not filter dropdowns should be displayed.
     *
     * @return bool Whether or the current page can display the filter drop downs.
     */
    public function can_display_filter()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Loads the MyYoast proxy.
   *
   * This class registers a proxy page on `admin.php`. Which is reached with the `page=PAGE_IDENTIFIER` parameter.
   * It will read external files and serves them like they are located locally.
   */
  class WPSEO_MyYoast_Proxy implements \WPSEO_WordPress_Integration
  {
    /**
     * The page identifier used in WordPress to register the MyYoast proxy page.
     *
     * @var string
     */
    const PAGE_IDENTIFIER = 'wpseo_myyoast_proxy';
    /**
     * The cache control's max age. Used in the header of a successful proxy response.
     *
     * @var int
     */
    const CACHE_CONTROL_MAX_AGE = \DAY_IN_SECONDS;
    /**
     * Registers the hooks when the user is on the right page.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the proxy page. It does not actually add a link to the dashboard.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    public function add_proxy_page()
    {
    }
    /**
     * Renders the requested proxy page and exits to prevent the WordPress UI from loading.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    public function handle_proxy_page()
    {
    }
    /**
     * Renders the requested proxy page.
     *
     * This is separated from the exits to be able to test it.
     *
     * @return void
     */
    public function render_proxy_page()
    {
    }
    /**
     * Tries to load the given url via `wp_remote_get`.
     *
     * @codeCoverageIgnore
     *
     * @param string $url The url to load.
     *
     * @return string The body of the response.
     *
     * @throws Exception When `wp_remote_get` returned an error.
     * @throws Exception When the response code is not 200.
     */
    protected function get_remote_url_body($url)
    {
    }
    /**
     * Determines the proxy options based on the file and plugin version arguments.
     *
     * When the file is known it returns an array like this:
     * <code>
     * $array = array(
     *  'content_type' => 'the content type'
     *  'url'          => 'the url, possibly with the plugin version'
     * )
     * </code>
     *
     * @return array Empty for an unknown file. See format above for known files.
     */
    protected function determine_proxy_options()
    {
    }
    /**
     * Checks if the current page is the MyYoast proxy page.
     *
     * @codeCoverageIgnore
     *
     * @return bool True when the page request parameter equals the proxy page.
     */
    protected function is_proxy_page()
    {
    }
    /**
     * Returns the proxy file from the HTTP request parameters.
     *
     * @codeCoverageIgnore
     *
     * @return string The sanitized file request parameter or an empty string if it does not exist.
     */
    protected function get_proxy_file()
    {
    }
    /**
     * Returns the plugin version from the HTTP request parameters.
     *
     * @codeCoverageIgnore
     *
     * @return string The sanitized plugin_version request parameter or an empty string if it does not exist.
     */
    protected function get_plugin_version()
    {
    }
    /**
     * Sets the HTTP header.
     *
     * This is a tiny helper function to enable better testing.
     *
     * @codeCoverageIgnore
     *
     * @param string $header The header to set.
     *
     * @return void
     */
    protected function set_header($header)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Options\Tabs
   */
  /**
   * Class WPSEO_Option_Tab.
   */
  class WPSEO_Option_Tab
  {
    /**
     * Name of the tab.
     *
     * @var string
     */
    private $name;
    /**
     * Label of the tab.
     *
     * @var string
     */
    private $label;
    /**
     * Optional arguments.
     *
     * @var array
     */
    private $arguments;
    /**
     * WPSEO_Option_Tab constructor.
     *
     * @param string $name      Name of the tab.
     * @param string $label     Localized label of the tab.
     * @param array  $arguments Optional arguments.
     */
    public function __construct($name, $label, array $arguments = [])
    {
    }
    /**
     * Gets the name.
     *
     * @return string The name.
     */
    public function get_name()
    {
    }
    /**
     * Gets the label.
     *
     * @return string The label.
     */
    public function get_label()
    {
    }
    /**
     * Retrieves whether the tab needs a save button.
     *
     * @return bool True whether the tabs needs a save button.
     */
    public function has_save_button()
    {
    }
    /**
     * Retrieves whether the tab hosts beta functionalities.
     *
     * @return bool True whether the tab hosts beta functionalities.
     */
    public function is_beta()
    {
    }
    /**
     * Retrieves whether the tab hosts premium functionalities.
     *
     * @return bool True whether the tab hosts premium functionalities.
     */
    public function is_premium()
    {
    }
    /**
     * Gets the option group.
     *
     * @return string The option group.
     */
    public function get_opt_group()
    {
    }
    /**
     * Retrieves the variable from the supplied arguments.
     *
     * @param string       $variable      Variable to retrieve.
     * @param string|mixed $default_value Default to use when variable not found.
     *
     * @return mixed|string The retrieved variable.
     */
    protected function get_argument($variable, $default_value = '')
    {
    }
  }
  /**
   * Class WPSEO_Option_Tabs_Formatter.
   */
  class WPSEO_Option_Tabs_Formatter
  {
    /**
     * Retrieves the path to the view of the tab.
     *
     * @param WPSEO_Option_Tabs $option_tabs Option Tabs to get base from.
     * @param WPSEO_Option_Tab  $tab         Tab to get name from.
     *
     * @return string
     */
    public function get_tab_view(\WPSEO_Option_Tabs $option_tabs, \WPSEO_Option_Tab $tab)
    {
    }
    /**
     * Outputs the option tabs.
     *
     * @param WPSEO_Option_Tabs $option_tabs Option Tabs to get tabs from.
     */
    public function run(\WPSEO_Option_Tabs $option_tabs)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Options\Tabs
   */
  /**
   * Class WPSEO_Option_Tabs.
   */
  class WPSEO_Option_Tabs
  {
    /**
     * Tabs base.
     *
     * @var string
     */
    private $base;
    /**
     * The tabs in this group.
     *
     * @var array
     */
    private $tabs = [];
    /**
     * Name of the active tab.
     *
     * @var string
     */
    private $active_tab = '';
    /**
     * WPSEO_Option_Tabs constructor.
     *
     * @codeCoverageIgnore
     *
     * @param string $base       Base of the tabs.
     * @param string $active_tab Currently active tab.
     */
    public function __construct($base, $active_tab = '')
    {
    }
    /**
     * Get the base.
     *
     * @return string
     */
    public function get_base()
    {
    }
    /**
     * Add a tab.
     *
     * @param WPSEO_Option_Tab $tab Tab to add.
     *
     * @return $this
     */
    public function add_tab(\WPSEO_Option_Tab $tab)
    {
    }
    /**
     * Get active tab.
     *
     * @return WPSEO_Option_Tab|null Get the active tab.
     */
    public function get_active_tab()
    {
    }
    /**
     * Is the tab the active tab.
     *
     * @param WPSEO_Option_Tab $tab Tab to check for active tab.
     *
     * @return bool
     */
    public function is_active_tab(\WPSEO_Option_Tab $tab)
    {
    }
    /**
     * Get all tabs.
     *
     * @return WPSEO_Option_Tab[]
     */
    public function get_tabs()
    {
    }
    /**
     * Display the tabs.
     *
     * @param Yoast_Form $yform Yoast Form needed in the views.
     */
    public function display(\Yoast_Form $yform)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class WPSEO_presenter_paper.
   */
  class WPSEO_Paper_Presenter
  {
    /**
     * Title of the paper.
     *
     * @var string
     */
    private $title;
    /**
     * The view variables.
     *
     * @var array
     */
    private $settings;
    /**
     * The path to the view file.
     *
     * @var string
     */
    private $view_file;
    /**
     * WPSEO_presenter_paper constructor.
     *
     * @param string      $title     The title of the paper.
     * @param string|null $view_file Optional. The path to the view file. Use the content setting
     *                               if do not wish to use a view file.
     * @param array       $settings  Optional. Settings for the paper.
     */
    public function __construct($title, $view_file = \null, array $settings = [])
    {
    }
    /**
     * Renders the collapsible paper and returns it as a string.
     *
     * @return string The rendered paper.
     */
    public function get_output()
    {
    }
    /**
     * Retrieves the view variables.
     *
     * @return array The view variables.
     */
    private function get_view_variables()
    {
    }
    /**
     * Retrieves the collapsible config based on the settings.
     *
     * @return array The config.
     */
    protected function collapsible_config()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Plugin_Availability
   */
  /**
   * Class WPSEO_Plugin_Availability
   */
  class WPSEO_Plugin_Availability
  {
    /**
     * Holds the plugins.
     *
     * @var array
     */
    protected $plugins = [];
    /**
     * Registers the plugins so we can access them.
     */
    public function register()
    {
    }
    /**
     * Registers all the available Yoast SEO plugins.
     */
    protected function register_yoast_plugins()
    {
    }
    /**
     * Sets certain plugin properties based on WordPress' status.
     */
    protected function register_yoast_plugins_status()
    {
    }
    /**
     * Checks whether or not a plugin is known within the Yoast SEO collection.
     *
     * @param string $plugin The plugin to search for.
     *
     * @return bool Whether or not the plugin is exists.
     */
    protected function plugin_exists($plugin)
    {
    }
    /**
     * Gets all the possibly available plugins.
     *
     * @return array Array containing the information about the plugins.
     */
    public function get_plugins()
    {
    }
    /**
     * Gets a specific plugin. Returns an empty array if it cannot be found.
     *
     * @param string $plugin The plugin to search for.
     *
     * @return array The plugin properties.
     */
    public function get_plugin($plugin)
    {
    }
    /**
     * Gets the version of the plugin.
     *
     * @param array $plugin The information available about the plugin.
     *
     * @return string The version associated with the plugin.
     */
    public function get_version($plugin)
    {
    }
    /**
     * Checks if there are dependencies available for the plugin.
     *
     * @param array $plugin The information available about the plugin.
     *
     * @return bool Whether or not there is a dependency present.
     */
    public function has_dependencies($plugin)
    {
    }
    /**
     * Gets the dependencies for the plugin.
     *
     * @param array $plugin The information available about the plugin.
     *
     * @return array Array containing all the dependencies associated with the plugin.
     */
    public function get_dependencies($plugin)
    {
    }
    /**
     * Checks if all dependencies are satisfied.
     *
     * @param array $plugin The information available about the plugin.
     *
     * @return bool Whether or not the dependencies are satisfied.
     */
    public function dependencies_are_satisfied($plugin)
    {
    }
    /**
     * Checks whether or not one of the plugins is properly installed and usable.
     *
     * @param array $plugin The information available about the plugin.
     *
     * @return bool Whether or not the plugin is properly installed.
     */
    public function is_installed($plugin)
    {
    }
    /**
     * Gets all installed plugins.
     *
     * @return array The installed plugins.
     */
    public function get_installed_plugins()
    {
    }
    /**
     * Checks for the availability of the plugin.
     *
     * @param array $plugin The information available about the plugin.
     *
     * @return bool Whether or not the plugin is available.
     */
    public function is_available($plugin)
    {
    }
    /**
     * Checks whether a dependency is available.
     *
     * @param array $dependency The information about the dependency to look for.
     *
     * @return bool Whether or not the dependency is available.
     */
    public function is_dependency_available($dependency)
    {
    }
    /**
     * Gets the names of the dependencies.
     *
     * @param array $plugin The plugin to get the dependency names from.
     *
     * @return array Array containing the names of the associated dependencies.
     */
    public function get_dependency_names($plugin)
    {
    }
    /**
     * Gets an array of plugins that have defined dependencies.
     *
     * @return array Array of the plugins that have dependencies.
     */
    public function get_plugins_with_dependencies()
    {
    }
    /**
     * Determines whether or not a plugin is active.
     *
     * @param string $plugin The plugin slug to check.
     *
     * @return bool Whether or not the plugin is active.
     */
    public function is_active($plugin)
    {
    }
    /**
     * Determines whether or not a plugin is a Premium product.
     *
     * @param array $plugin The plugin to check.
     *
     * @return bool Whether or not the plugin is a Premium product.
     */
    public function is_premium($plugin)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   * @since   1.7.0
   */
  /**
   * Base class for handling plugin conflicts.
   */
  class Yoast_Plugin_Conflict
  {
    /**
     * The plugins must be grouped per section.
     *
     * It's possible to check for each section if there are conflicting plugins.
     *
     * @var array
     */
    protected $plugins = [];
    /**
     * All the current active plugins will be stored in this private var.
     *
     * @var array
     */
    protected $all_active_plugins = [];
    /**
     * After searching for active plugins that are in $this->plugins the active plugins will be stored in this
     * property.
     *
     * @var array
     */
    protected $active_conflicting_plugins = [];
    /**
     * Property for holding instance of itself.
     *
     * @var Yoast_Plugin_Conflict
     */
    protected static $instance;
    /**
     * For the use of singleton pattern. Create instance of itself and return this instance.
     *
     * @param string $class_name Give the classname to initialize. If classname is
     *                           false (empty) it will use it's own __CLASS__.
     *
     * @return Yoast_Plugin_Conflict
     */
    public static function get_instance($class_name = '')
    {
    }
    /**
     * Setting instance, all active plugins and search for active plugins.
     *
     * Protected constructor to prevent creating a new instance of the
     * *Singleton* via the `new` operator from outside this class.
     */
    protected function __construct()
    {
    }
    /**
     * Check if there are conflicting plugins for given $plugin_section.
     *
     * @param string $plugin_section Type of plugin conflict (such as Open Graph or sitemap).
     *
     * @return bool
     */
    public function check_for_conflicts($plugin_section)
    {
    }
    /**
     * Checks for given $plugin_sections for conflicts.
     *
     * @param array $plugin_sections Set of sections.
     */
    public function check_plugin_conflicts($plugin_sections)
    {
    }
    /**
     * Setting an error on the screen.
     *
     * @param string $plugin_section          Type of conflict group (such as Open Graph or sitemap).
     * @param string $readable_plugin_section This is the value for the translation.
     */
    protected function set_error($plugin_section, $readable_plugin_section)
    {
    }
    /**
     * Clear the notification for a plugin.
     *
     * @param string $plugin_file Clear the optional notification for this plugin.
     */
    public function clear_error($plugin_file)
    {
    }
    /**
     * Loop through the $this->plugins to check if one of the plugins is active.
     *
     * This method will store the active plugins in $this->active_plugins.
     */
    protected function search_active_plugins()
    {
    }
    /**
     * Loop through plugins and check if each plugin is active.
     *
     * @param array  $plugins        Set of plugins.
     * @param string $plugin_section Type of conflict group (such as Open Graph or sitemap).
     */
    protected function check_plugins_active($plugins, $plugin_section)
    {
    }
    /**
     * Check if given plugin exists in array with all_active_plugins.
     *
     * @param string $plugin Plugin basename string.
     *
     * @return bool
     */
    protected function check_plugin_is_active($plugin)
    {
    }
    /**
     * Add plugin to the list of active plugins.
     *
     * This method will check first if key $plugin_section exists, if not it will create an empty array
     * If $plugin itself doesn't exist it will be added.
     *
     * @param string $plugin_section Type of conflict group (such as Open Graph or sitemap).
     * @param string $plugin         Plugin basename string.
     */
    protected function add_active_plugin($plugin_section, $plugin)
    {
    }
    /**
     * Search in $this->plugins for the given $plugin.
     *
     * If there is a result it will return the plugin category.
     *
     * @param string $plugin Plugin basename string.
     *
     * @return int|string
     */
    protected function find_plugin_category($plugin)
    {
    }
    /**
     * Get plugin name from file.
     *
     * @param string $plugin Plugin path relative to plugins directory.
     *
     * @return string|bool Plugin name or false when no name is set.
     */
    protected function get_plugin_name($plugin)
    {
    }
    /**
     * When being in the deactivation process the currently deactivated plugin has to be removed.
     */
    private function remove_deactivated_plugin()
    {
    }
    /**
     * Get the identifier from the plugin file.
     *
     * @param string $plugin_file Plugin file to get Identifier from.
     *
     * @return string
     */
    private function get_notification_identifier($plugin_file)
    {
    }
  }
  /**
   * Contains list of conflicting plugins.
   */
  class WPSEO_Plugin_Conflict extends \Yoast_Plugin_Conflict
  {
    /**
     * The plugins must be grouped per section.
     *
     * It's possible to check for each section if there are conflicting plugin.
     *
     * NOTE: when changing this array, be sure to update the array in Conflicting_Plugins_Service too.
     *
     * @var array
     */
    protected $plugins = [
      // The plugin which are writing OG metadata.
      'open_graph' => \Yoast\WP\SEO\Config\Conflicting_Plugins::OPEN_GRAPH_PLUGINS,
      'xml_sitemaps' => \Yoast\WP\SEO\Config\Conflicting_Plugins::XML_SITEMAPS_PLUGINS,
      'cloaking' => \Yoast\WP\SEO\Config\Conflicting_Plugins::CLOAKING_PLUGINS,
      'seo' => \Yoast\WP\SEO\Config\Conflicting_Plugins::SEO_PLUGINS,
    ];
    /**
     * Overrides instance to set with this class as class.
     *
     * @param string $class_name Optional class name.
     *
     * @return Yoast_Plugin_Conflict
     */
    public static function get_instance($class_name = __CLASS__)
    {
    }
    /**
     * After activating any plugin, this method will be executed by a hook.
     *
     * If the activated plugin is conflicting with ours a notice will be shown.
     *
     * @param string|bool $plugin Optional plugin basename to check.
     */
    public static function hook_check_for_plugin_conflicts($plugin = \false)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class WPSEO_Premium_popup.
   */
  class WPSEO_Premium_Popup
  {
    /**
     * An unique identifier for the popup
     *
     * @var string
     */
    private $identifier = '';
    /**
     * The heading level of the title of the popup.
     *
     * @var string
     */
    private $heading_level = '';
    /**
     * The title of the popup.
     *
     * @var string
     */
    private $title = '';
    /**
     * The content of the popup.
     *
     * @var string
     */
    private $content = '';
    /**
     * The URL for where the button should link to.
     *
     * @var string
     */
    private $url = '';
    /**
     * Wpseo_Premium_Popup constructor.
     *
     * @param string $identifier    An unique identifier for the popup.
     * @param string $heading_level The heading level for the title of the popup.
     * @param string $title         The title of the popup.
     * @param string $content       The content of the popup.
     * @param string $url           The URL for where the button should link to.
     */
    public function __construct($identifier, $heading_level, $title, $content, $url)
    {
    }
    /**
     * Returns the premium popup as an HTML string.
     *
     * @param bool $popup Show this message as a popup show it straight away.
     *
     * @return string
     */
    public function get_premium_message($popup = \true)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class WPSEO_Premium_Upsell_Admin_Block
   */
  class WPSEO_Premium_Upsell_Admin_Block
  {
    /**
     * Hook to display the block on.
     *
     * @var string
     */
    protected $hook;
    /**
     * Identifier to use in the dismissal functionality.
     *
     * @var string
     */
    protected $identifier = 'premium_upsell';
    /**
     * Registers which hook the block will be displayed on.
     *
     * @param string $hook Hook to display the block on.
     */
    public function __construct($hook)
    {
    }
    /**
     * Registers WordPress hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Renders the upsell block.
     *
     * @return void
     */
    public function render()
    {
    }
    /**
     * Formats the argument to a HTML list item.
     *
     * @param string $argument The argument to format.
     *
     * @return string Formatted argument in HTML.
     */
    protected function get_argument_html($argument)
    {
    }
    /**
     * Returns the HTML base class to use.
     *
     * @return string The HTML base class.
     */
    protected function get_html_class()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Adds the UI to change the primary term for a post.
   */
  class WPSEO_Primary_Term_Admin implements \WPSEO_WordPress_Integration
  {
    /**
     * Constructor.
     */
    public function register_hooks()
    {
    }
    /**
     * Gets the current post ID.
     *
     * @return int The post ID.
     */
    protected function get_current_id()
    {
    }
    /**
     * Adds hidden fields for primary taxonomies.
     *
     * @param string $content The metabox content.
     *
     * @return string The HTML content.
     */
    public function add_input_fields($content)
    {
    }
    /**
     * Generates the HTML for a hidden field for a primary taxonomy.
     *
     * @param string $taxonomy_name The taxonomy's slug.
     *
     * @return string The HTML for a hidden primary taxonomy field.
     */
    protected function primary_term_field($taxonomy_name)
    {
    }
    /**
     * Generates an id for a primary taxonomy's hidden field.
     *
     * @param string $taxonomy_name The taxonomy's slug.
     *
     * @return string The field id.
     */
    protected function generate_field_id($taxonomy_name)
    {
    }
    /**
     * Generates a name for a primary taxonomy's hidden field.
     *
     * @param string $taxonomy_name The taxonomy's slug.
     *
     * @return string The field id.
     */
    protected function generate_field_name($taxonomy_name)
    {
    }
    /**
     * Adds primary term templates.
     */
    public function wp_footer()
    {
    }
    /**
     * Enqueues all the assets needed for the primary term interface.
     *
     * @return void
     */
    public function enqueue_assets()
    {
    }
    /**
     * Gets the id of the primary term.
     *
     * @param string $taxonomy_name Taxonomy name for the term.
     *
     * @return int primary term id
     */
    protected function get_primary_term($taxonomy_name)
    {
    }
    /**
     * Returns all the taxonomies for which the primary term selection is enabled.
     *
     * @param int|null $post_id Default current post ID.
     * @return array
     */
    protected function get_primary_term_taxonomies($post_id = \null)
    {
    }
    /**
     * Includes templates file.
     */
    protected function include_js_templates()
    {
    }
    /**
     * Generates the primary term taxonomies.
     *
     * @param int $post_id ID of the post.
     *
     * @return array
     */
    protected function generate_primary_term_taxonomies($post_id)
    {
    }
    /**
     * Creates a map of taxonomies for localization.
     *
     * @param array $taxonomies The taxononmies that should be mapped.
     *
     * @return array The mapped taxonomies.
     */
    protected function get_mapped_taxonomies_for_js($taxonomies)
    {
    }
    /**
     * Returns an array suitable for use in the javascript.
     *
     * @param stdClass $taxonomy The taxonomy to map.
     *
     * @return array The mapped taxonomy.
     */
    private function map_taxonomies_for_js($taxonomy)
    {
    }
    /**
     * Returns whether or not a taxonomy is hierarchical.
     *
     * @param stdClass $taxonomy Taxonomy object.
     *
     * @return bool
     */
    private function filter_hierarchical_taxonomies($taxonomy)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents the upsell notice.
   */
  class WPSEO_Product_Upsell_Notice
  {
    /**
     * Holds the name of the user meta key.
     *
     * The value of this database field holds whether the user has dismissed this notice or not.
     *
     * @var string
     */
    const USER_META_DISMISSED = 'wpseo-remove-upsell-notice';
    /**
     * Holds the option name.
     *
     * @var string
     */
    const OPTION_NAME = 'wpseo';
    /**
     * Holds the options.
     *
     * @var array
     */
    protected $options;
    /**
     * Sets the options, because they always have to be there on instance.
     */
    public function __construct()
    {
    }
    /**
     * Checks if the notice should be added or removed.
     */
    public function initialize()
    {
    }
    /**
     * Sets the upgrade notice.
     */
    public function set_upgrade_notice()
    {
    }
    /**
     * Listener for the upsell notice.
     */
    public function dismiss_notice_listener()
    {
    }
    /**
     * When the notice should be shown.
     *
     * @return bool
     */
    protected function should_add_notification()
    {
    }
    /**
     * Checks if the options has a first activated on date value.
     *
     * @return bool
     */
    protected function has_first_activated_on()
    {
    }
    /**
     * Sets the first activated on.
     */
    protected function set_first_activated_on()
    {
    }
    /**
     * Adds a notification to the notification center.
     */
    protected function add_notification()
    {
    }
    /**
     * Removes a notification to the notification center.
     */
    protected function remove_notification()
    {
    }
    /**
     * Returns a premium upsell section if using the free plugin.
     *
     * @return string
     */
    protected function get_premium_upsell_section()
    {
    }
    /**
     * Gets the notification value.
     *
     * @return Yoast_Notification
     */
    protected function get_notification()
    {
    }
    /**
     * Dismisses the notice.
     *
     * @return bool
     */
    protected function is_notice_dismissed()
    {
    }
    /**
     * Dismisses the notice.
     */
    protected function dismiss_notice()
    {
    }
    /**
     * Returns the set options.
     *
     * @return mixed
     */
    protected function get_options()
    {
    }
    /**
     * Saves the options to the database.
     */
    protected function save_options()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * This class handles a post request being send to a given endpoint.
   */
  class WPSEO_Remote_Request
  {
    /**
     * Holds the post method.
     *
     * @var string
     */
    const METHOD_POST = 'post';
    /**
     * Holds the get method.
     *
     * @var string
     */
    const METHOD_GET = 'get';
    /**
     * Holds the endpoint to send the request to.
     *
     * @var string
     */
    protected $endpoint = '';
    /**
     * Holds the arguments to use in this request.
     *
     * @var array
     */
    protected $args = ['blocking' => \false, 'timeout' => 2];
    /**
     * Holds the response error.
     *
     * @var WP_Error|null
     */
    protected $response_error;
    /**
     * Holds the response body.
     *
     * @var mixed
     */
    protected $response_body;
    /**
     * Sets the endpoint and arguments.
     *
     * @param string $endpoint The endpoint to send the request to.
     * @param array  $args     The arguments to use in this request.
     */
    public function __construct($endpoint, array $args = [])
    {
    }
    /**
     * Sets the request body.
     *
     * @param mixed $body The body to set.
     */
    public function set_body($body)
    {
    }
    /**
     * Sends the data to the given endpoint.
     *
     * @param string $method The type of request to send.
     *
     * @return bool True when sending data has been successful.
     */
    public function send($method = self::METHOD_POST)
    {
    }
    /**
     * Returns the value of the response error.
     *
     * @return WP_Error|null The response error.
     */
    public function get_response_error()
    {
    }
    /**
     * Returns the response body.
     *
     * @return mixed The response body.
     */
    public function get_response_body()
    {
    }
    /**
     * Processes the given response.
     *
     * @param mixed $response The response to process.
     *
     * @return bool True when response is valid.
     */
    protected function process_response($response)
    {
    }
    /**
     * Performs a post request to the specified endpoint with set arguments.
     *
     * @return WP_Error|array The response or WP_Error on failure.
     */
    protected function post()
    {
    }
    /**
     * Performs a post request to the specified endpoint with set arguments.
     *
     * @return WP_Error|array The response or WP_Error on failure.
     */
    protected function get()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Notifies the user to update the Search Appearance settings when the site is set to represent a Person,
   * but no person (name) has been chosen.
   */
  class WPSEO_Schema_Person_Upgrade_Notification implements \WPSEO_WordPress_Integration
  {
    /**
     * Registers all hooks to WordPress
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Handles if the notification should be added or removed.
     */
    public function handle_notification()
    {
    }
    /**
     * Adds a notification to the notification center.
     */
    protected function add_notification()
    {
    }
    /**
     * Removes a notification to the notification center.
     */
    protected function remove_notification()
    {
    }
    /**
     * Gets the notification object.
     *
     * @return Yoast_Notification
     */
    protected function get_notification()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Suggested_Plugins
   */
  /**
   * Class WPSEO_Suggested_Plugins
   */
  class WPSEO_Suggested_Plugins implements \WPSEO_WordPress_Integration
  {
    /**
     * Holds the availability checker.
     *
     * @var WPSEO_Plugin_Availability
     */
    protected $availability_checker;
    /**
     * Holds the notification center.
     *
     * @var Yoast_Notification_Center
     */
    protected $notification_center;
    /**
     * WPSEO_Suggested_Plugins constructor.
     *
     * @param WPSEO_Plugin_Availability $availability_checker The availability checker to use.
     * @param Yoast_Notification_Center $notification_center  The notification center to add notifications to.
     */
    public function __construct(\WPSEO_Plugin_Availability $availability_checker, \Yoast_Notification_Center $notification_center)
    {
    }
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds notifications (when necessary).
     *
     * @return void
     */
    public function add_notifications()
    {
    }
    /**
     * Build Yoast SEO suggested plugins notification.
     *
     * @param string $name   The plugin name to use for the unique ID.
     * @param array  $plugin The plugin to retrieve the data from.
     *
     * @return Yoast_Notification The notification containing the suggested plugin.
     */
    protected function get_yoast_seo_suggested_plugins_notification($name, $plugin)
    {
    }
    /**
     * Creates a message to suggest the installation of a particular plugin.
     *
     * @param array $suggested_plugin The suggested plugin.
     *
     * @return string The install suggested plugin message.
     */
    protected function create_install_suggested_plugin_message($suggested_plugin)
    {
    }
    /**
     * Creates a more information link that directs the user to WordPress.org Plugin repository.
     *
     * @param string $url  The URL to the plugin's page.
     * @param string $name The name of the plugin.
     *
     * @return string The more information link.
     */
    protected function create_more_information_link($url, $name)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents the yoast columns.
   */
  class WPSEO_Yoast_Columns implements \WPSEO_WordPress_Integration
  {
    /**
     * Registers all hooks to WordPress.
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the help tab to the help center for current screen.
     */
    public function add_help_tab()
    {
    }
    /**
     * Retrieves the post type from the $_GET variable.
     *
     * @return string The current post type.
     */
    private function get_current_post_type()
    {
    }
    /**
     * Whether we are showing link columns on this overview page.
     * This depends on the post being accessible or not.
     *
     * @return bool Whether the linking columns are shown
     */
    private function display_links()
    {
    }
    /**
     * Wraps the WPSEO_Metabox check to determine whether the metabox should be displayed either by
     * choice of the admin or because the post type is not a public post type.
     *
     * @return bool Whether the meta box (and associated columns etc) should be hidden.
     */
    private function display_meta_columns()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class to change or add WordPress dashboard widgets.
   */
  class Yoast_Dashboard_Widget implements \WPSEO_WordPress_Integration
  {
    /**
     * Holds the cache transient key.
     *
     * @var string
     */
    const CACHE_TRANSIENT_KEY = 'wpseo-dashboard-totals';
    /**
     * Holds an instance of the admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * Holds the dashboard statistics.
     *
     * @var WPSEO_Statistics
     */
    protected $statistics;
    /**
     * Yoast_Dashboard_Widget constructor.
     *
     * @param WPSEO_Statistics|null $statistics WPSEO_Statistics instance.
     */
    public function __construct(\WPSEO_Statistics $statistics = \null)
    {
    }
    /**
     * Register WordPress hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the dashboard widget if it should be shown.
     *
     * @return void
     */
    public function queue_dashboard_widget()
    {
    }
    /**
     * Adds dashboard widget to WordPress.
     */
    public function add_dashboard_widget()
    {
    }
    /**
     * Adds CSS classes to the dashboard widget.
     *
     * @param array $classes An array of postbox CSS classes.
     *
     * @return array
     */
    public function wpseo_dashboard_overview_class($classes)
    {
    }
    /**
     * Displays the dashboard widget.
     */
    public function display_dashboard_widget()
    {
    }
    /**
     * Enqueues assets for the dashboard if the current page is the dashboard.
     */
    public function enqueue_dashboard_assets()
    {
    }
    /**
     * Translates strings used in the dashboard widget.
     *
     * @return array The translated strings.
     */
    public function localize_dashboard_script()
    {
    }
    /**
     * Checks if the current screen is the dashboard screen.
     *
     * @return bool Whether or not this is the dashboard screen.
     */
    private function is_dashboard_screen()
    {
    }
    /**
     * Returns true when the dashboard widget should be shown.
     *
     * @return bool
     */
    private function show_widget()
    {
    }
  }
  /**
   * Admin form class.
   *
   * @since 2.0
   */
  class Yoast_Form
  {
    /**
     * Instance of this class
     *
     * @var Yoast_Form
     * @since 2.0
     */
    public static $instance;
    /**
     * The short name of the option to use for the current page.
     *
     * @var string
     * @since 2.0
     */
    public $option_name;
    /**
     * Option instance.
     *
     * @since 8.4
     * @var WPSEO_Option|null
     */
    protected $option_instance = \null;
    /**
     * Get the singleton instance of this class.
     *
     * @since 2.0
     *
     * @return Yoast_Form
     */
    public static function get_instance()
    {
    }
    /**
     * Generates the header for admin pages.
     *
     * @since 2.0
     *
     * @param bool   $form             Whether or not the form start tag should be included.
     * @param string $option           The short name of the option to use for the current page.
     * @param bool   $contains_files   Whether the form should allow for file uploads.
     * @param bool   $option_long_name Group name of the option.
     */
    public function admin_header($form = \true, $option = 'wpseo', $contains_files = \false, $option_long_name = \false)
    {
    }
    /**
     * Set the option used in output for form elements.
     *
     * @since 2.0
     *
     * @param string $option_name Option key.
     */
    public function set_option($option_name)
    {
    }
    /**
     * Generates the footer for admin pages.
     *
     * @since 2.0
     *
     * @param bool $submit       Whether or not a submit button and form end tag should be shown.
     * @param bool $show_sidebar Whether or not to show the banner sidebar - used by premium plugins to disable it.
     */
    public function admin_footer($submit = \true, $show_sidebar = \true)
    {
    }
    /**
     * Generates the sidebar for admin pages.
     *
     * @since 2.0
     */
    public function admin_sidebar()
    {
    }
    /**
     * Output a label element.
     *
     * @since 2.0
     *
     * @param string $text Label text string, which can contain escaped html.
     * @param array  $attr HTML attributes set.
     */
    public function label($text, $attr)
    {
    }
    /**
     * Output a legend element.
     *
     * @since 3.4
     *
     * @param string $text Legend text string.
     * @param array  $attr HTML attributes set.
     */
    public function legend($text, $attr)
    {
    }
    /**
     * Create a Checkbox input field.
     *
     * @since 2.0
     *
     * @param string $variable   The variable within the option to create the checkbox for.
     * @param string $label      The label to show for the variable.
     * @param bool   $label_left Whether the label should be left (true) or right (false).
     * @param array  $attr       Extra attributes to add to the checkbox.
     */
    public function checkbox($variable, $label, $label_left = \false, $attr = [])
    {
    }
    /**
     * Creates a Checkbox input field list.
     *
     * @since 12.8
     *
     * @param string $variable The variables within the option to create the checkbox list for.
     * @param string $labels   The labels to show for the variable.
     * @param array  $attr     Extra attributes to add to the checkbox list.
     */
    public function checkbox_list($variable, $labels, $attr = [])
    {
    }
    /**
     * Create a light switch input field using a single checkbox.
     *
     * @since 3.1
     *
     * @param string $variable The variable within the option to create the checkbox for.
     * @param string $label    The visual label text for the toggle.
     * @param array  $buttons  Array of two visual labels for the buttons (defaults Disabled/Enabled).
     * @param bool   $reverse  Reverse order of buttons (default true).
     * @param string $help     Inline Help that will be printed out before the toggle.
     * @param bool   $strong   Whether the visual label is displayed in strong text. Default is false.
     *                         Starting from Yoast SEO 16.5, the visual label is forced to bold via CSS.
     * @param array  $attr     Extra attributes to add to the light switch.
     */
    public function light_switch($variable, $label, $buttons = [], $reverse = \true, $help = '', $strong = \false, $attr = [])
    {
    }
    /**
     * Create a Text input field.
     *
     * @since 2.0
     * @since 2.1 Introduced the `$attr` parameter.
     *
     * @param string       $variable The variable within the option to create the text input field for.
     * @param string       $label    The label to show for the variable.
     * @param array|string $attr     Extra attributes to add to the input field. Can be class, disabled, autocomplete.
     */
    public function textinput($variable, $label, $attr = [])
    {
    }
    /**
     * Create a Number input field.
     *
     * @param string       $variable The variable within the option to create the text input field for.
     * @param string       $label    The label to show for the variable.
     * @param array|string $attr     Extra attributes to add to the input field. Can be class, disabled, autocomplete.
     */
    public function number($variable, $label, $attr = [])
    {
    }
    /**
     * Creates a text input field with with the ability to add content after the label.
     *
     * @param string $variable The variable within the option to create the text input field for.
     * @param string $label    The label to show for the variable.
     * @param array  $attr     Extra attributes to add to the input field.
     *
     * @return void
     */
    public function textinput_extra_content($variable, $label, $attr = [])
    {
    }
    /**
     * Create a textarea.
     *
     * @since 2.0
     *
     * @param string       $variable The variable within the option to create the textarea for.
     * @param string       $label    The label to show for the variable.
     * @param string|array $attr     The CSS class or an array of attributes to assign to the textarea.
     */
    public function textarea($variable, $label, $attr = [])
    {
    }
    /**
     * Create a hidden input field.
     *
     * @since 2.0
     *
     * @param string $variable The variable within the option to create the hidden input for.
     * @param string $id       The ID of the element.
     * @param mixed  $val      Optional. The value to set in the input field. Otherwise the value from the options will be used.
     */
    public function hidden($variable, $id = '', $val = \null)
    {
    }
    /**
     * Create a Select Box.
     *
     * @since 2.0
     *
     * @param string $variable       The variable within the option to create the select for.
     * @param string $label          The label to show for the variable.
     * @param array  $select_options The select options to choose from.
     * @param string $styled         The select style. Use 'styled' to get a styled select. Default 'unstyled'.
     * @param bool   $show_label     Whether or not to show the label, if not, it will be applied as an aria-label.
     * @param array  $attr           Extra attributes to add to the select.
     * @param string $help           Optional. Inline Help HTML that will be printed after the label. Default is empty.
     */
    public function select($variable, $label, array $select_options, $styled = 'unstyled', $show_label = \true, $attr = [], $help = '')
    {
    }
    /**
     * Create a File upload field.
     *
     * @since 2.0
     *
     * @param string $variable The variable within the option to create the file upload field for.
     * @param string $label    The label to show for the variable.
     * @param array  $attr     Extra attributes to add to the file upload input.
     */
    public function file_upload($variable, $label, $attr = [])
    {
    }
    /**
     * Media input.
     *
     * @since 2.0
     *
     * @param string $variable Option name.
     * @param string $label    Label message.
     * @param array  $attr     Extra attributes to add to the media input and buttons.
     */
    public function media_input($variable, $label, $attr = [])
    {
    }
    /**
     * Create a Radio input field.
     *
     * @since 2.0
     *
     * @param string $variable    The variable within the option to create the radio button for.
     * @param array  $values      The radio options to choose from.
     * @param string $legend      Optional. The legend to show for the field set, if any.
     * @param array  $legend_attr Optional. The attributes for the legend, if any.
     * @param array  $attr        Extra attributes to add to the radio button.
     */
    public function radio($variable, $values, $legend = '', $legend_attr = [], $attr = [])
    {
    }
    /**
     * Create a toggle switch input field using two radio buttons.
     *
     * @since 3.1
     *
     * @param string $variable The variable within the option to create the radio buttons for.
     * @param array  $values   Associative array of on/off keys and their values to be used as
     *                         the label elements text for the radio buttons. Optionally, each
     *                         value can be an array of visible label text and screen reader text.
     * @param string $label    The visual label for the radio buttons group, used as the fieldset legend.
     * @param string $help     Inline Help that will be printed out before the visible toggles text.
     * @param array  $attr     Extra attributes to add to the toggle switch.
     */
    public function toggle_switch($variable, $values, $label, $help = '', $attr = [])
    {
    }
    /**
     * Creates a toggle switch to define whether an indexable should be indexed or not.
     *
     * @param string $variable The variable within the option to create the radio buttons for.
     * @param string $label    The visual label for the radio buttons group, used as the fieldset legend.
     * @param string $help     Inline Help that will be printed out before the visible toggles text.
     * @param array  $attr     Extra attributes to add to the index switch.
     *
     * @return void
     */
    public function index_switch($variable, $label, $help = '', $attr = [])
    {
    }
    /**
     * Creates a toggle switch to show hide certain options.
     *
     * @param string $variable     The variable within the option to create the radio buttons for.
     * @param string $label        The visual label for the radio buttons group, used as the fieldset legend.
     * @param bool   $inverse_keys Whether or not the option keys need to be inverted to support older functions.
     * @param string $help         Inline Help that will be printed out before the visible toggles text.
     * @param array  $attr         Extra attributes to add to the show-hide switch.
     *
     * @return void
     */
    public function show_hide_switch($variable, $label, $inverse_keys = \false, $help = '', $attr = [])
    {
    }
    /**
     * Retrieves the value for the form field.
     *
     * @param string      $field_name    The field name to retrieve the value for.
     * @param string|null $default_value The default value, when field has no value.
     *
     * @return mixed|null The retrieved value.
     */
    protected function get_field_value($field_name, $default_value = \null)
    {
    }
    /**
     * Checks whether a given control should be disabled.
     *
     * @param string $variable The variable within the option to check whether its control should be disabled.
     *
     * @return bool True if control should be disabled, false otherwise.
     */
    protected function is_control_disabled($variable)
    {
    }
    /**
     * Gets the explanation note to print if a given control is disabled.
     *
     * @param string $variable    The variable within the option to print a disabled note for.
     * @param string $custom_note An optional custom note to print instead.
     *
     * @return string Explanation note HTML string, or empty string if no note necessary.
     */
    protected function get_disabled_note($variable, $custom_note = '')
    {
    }
    /**
     * Determines whether we are dealing with the Usage tracking feature on a multisite subsite.
     * This feature requires specific behavior for the toggle switch.
     *
     * @param string $feature_setting The feature setting.
     *
     * @return bool True if we are dealing with the Usage tracking feature on a multisite subsite.
     */
    protected function is_tracking_on_subsite($feature_setting)
    {
    }
    /**
     * Returns the disabled attribute HTML.
     *
     * @param string $variable The variable within the option of the related form element.
     * @param array  $attr     Extra attributes added to the form element.
     *
     * @return string The disabled attribute HTML.
     */
    protected function get_disabled_attribute($variable, $attr)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Implements server-side user input validation.
   *
   * @since 12.0
   */
  class Yoast_Input_Validation
  {
    /**
     * The error descriptions.
     *
     * @since 12.1
     *
     * @var array
     */
    private static $error_descriptions = [];
    /**
     * Check whether an option group is a Yoast SEO setting.
     *
     * The normal pattern is 'yoast' . $option_name . 'options'.
     *
     * @since 12.0
     *
     * @param string $group_name The option group name.
     *
     * @return bool Whether or not it's an Yoast SEO option group.
     */
    public static function is_yoast_option_group_name($group_name)
    {
    }
    /**
     * Adds an error message to the document title when submitting a settings
     * form and errors are returned.
     *
     * Uses the WordPress `admin_title` filter in the WPSEO_Option subclasses.
     *
     * @since 12.0
     *
     * @param string $admin_title The page title, with extra context added.
     *
     * @return string The modified or original admin title.
     */
    public static function add_yoast_admin_document_title_errors($admin_title)
    {
    }
    /**
     * Checks whether a specific form input field was submitted with an invalid value.
     *
     * @since 12.1
     *
     * @param string $error_code Must be the same slug-name used for the field variable and for `add_settings_error()`.
     *
     * @return bool Whether or not the submitted input field contained an invalid value.
     */
    public static function yoast_form_control_has_error($error_code)
    {
    }
    /**
     * Sets the error descriptions.
     *
     * @since 12.1
     *
     * @param array $descriptions An associative array of error descriptions.
     *                            For each entry, the key must be the setting variable.
     */
    public static function set_error_descriptions($descriptions = [])
    {
    }
    /**
     * Gets all the error descriptions.
     *
     * @since 12.1
     *
     * @return array An associative array of error descriptions.
     */
    public static function get_error_descriptions()
    {
    }
    /**
     * Gets a specific error description.
     *
     * @since 12.1
     *
     * @param string $error_code Code of the error set via `add_settings_error()`, normally the variable name.
     *
     * @return string|null The error description.
     */
    public static function get_error_description($error_code)
    {
    }
    /**
     * Gets the aria-invalid HTML attribute based on the submitted invalid value.
     *
     * @since 12.1
     *
     * @param string $error_code Code of the error set via `add_settings_error()`, normally the variable name.
     *
     * @return string The aria-invalid HTML attribute or empty string.
     */
    public static function get_the_aria_invalid_attribute($error_code)
    {
    }
    /**
     * Gets the aria-describedby HTML attribute based on the submitted invalid value.
     *
     * @since 12.1
     *
     * @param string $error_code Code of the error set via `add_settings_error()`, normally the variable name.
     *
     * @return string The aria-describedby HTML attribute or empty string.
     */
    public static function get_the_aria_describedby_attribute($error_code)
    {
    }
    /**
     * Gets the error description wrapped in a HTML paragraph.
     *
     * @since 12.1
     *
     * @param string $error_code Code of the error set via `add_settings_error()`, normally the variable name.
     *
     * @return string The error description HTML or empty string.
     */
    public static function get_the_error_description($error_code)
    {
    }
    /**
     * Adds the submitted invalid value to the WordPress `$wp_settings_errors` global.
     *
     * @since 12.1
     *
     * @param string $error_code  Code of the error set via `add_settings_error()`, normally the variable name.
     * @param string $dirty_value The submitted invalid value.
     *
     * @return void
     */
    public static function add_dirty_value_to_settings_errors($error_code, $dirty_value)
    {
    }
    /**
     * Gets an invalid submitted value.
     *
     * @since 12.1
     *
     * @param string $error_code Code of the error set via `add_settings_error()`, normally the variable name.
     *
     * @return string The submitted invalid input field value.
     */
    public static function get_dirty_value($error_code)
    {
    }
    /**
     * Gets a specific invalid value message.
     *
     * @since 12.1
     *
     * @param string $error_code Code of the error set via `add_settings_error()`, normally the variable name.
     *
     * @return string The error invalid value message or empty string.
     */
    public static function get_dirty_value_message($error_code)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO
   */
  /**
   * An interface for registering AJAX integrations with WordPress.
   */
  interface WPSEO_WordPress_AJAX_Integration
  {
    /**
     * Registers all AJAX hooks to WordPress.
     *
     * @return void
     */
    public function register_ajax_hooks();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals
   */
  /**
   * Multisite utility class for network admin functionality.
   */
  class Yoast_Network_Admin implements \WPSEO_WordPress_AJAX_Integration, \WPSEO_WordPress_Integration
  {
    /**
     * Action identifier for updating plugin network options.
     *
     * @var string
     */
    const UPDATE_OPTIONS_ACTION = 'yoast_handle_network_options';
    /**
     * Action identifier for restoring a site.
     *
     * @var string
     */
    const RESTORE_SITE_ACTION = 'yoast_restore_site';
    /**
     * Gets the available sites as choices, e.g. for a dropdown.
     *
     * @param bool $include_empty Optional. Whether to include an initial placeholder choice.
     *                            Default false.
     * @param bool $show_title    Optional. Whether to show the title for each site. This requires
     *                            switching through the sites, so has performance implications for
     *                            sites that do not use a persistent cache.
     *                            Default false.
     *
     * @return array Choices as $site_id => $site_label pairs.
     */
    public function get_site_choices($include_empty = \false, $show_title = \false)
    {
    }
    /**
     * Gets the states of a site.
     *
     * @param WP_Site $site Site object.
     *
     * @return array Array of $state_slug => $state_label pairs.
     */
    public function get_site_states($site)
    {
    }
    /**
     * Handles a request to update plugin network options.
     *
     * This method works similar to how option updates are handled in `wp-admin/options.php` and
     * `wp-admin/network/settings.php`.
     *
     * @return void
     */
    public function handle_update_options_request()
    {
    }
    /**
     * Handles a request to restore a site's default settings.
     *
     * @return void
     */
    public function handle_restore_site_request()
    {
    }
    /**
     * Outputs nonce, action and option group fields for a network settings page in the plugin.
     *
     * @param string $option_group Option group name for the current page.
     *
     * @return void
     */
    public function settings_fields($option_group)
    {
    }
    /**
     * Enqueues network admin assets.
     *
     * @return void
     */
    public function enqueue_assets()
    {
    }
    /**
     * Hooks in the necessary actions and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Hooks in the necessary AJAX actions.
     *
     * @return void
     */
    public function register_ajax_hooks()
    {
    }
    /**
     * Checks whether the requirements to use this class are met.
     *
     * @return bool True if requirements are met, false otherwise.
     */
    public function meets_requirements()
    {
    }
    /**
     * Verifies that the current request is valid.
     *
     * @param string $action    Nonce action.
     * @param string $query_arg Optional. Nonce query argument. Default '_wpnonce'.
     *
     * @return void
     */
    public function verify_request($action, $query_arg = '_wpnonce')
    {
    }
    /**
     * Terminates the current request by either redirecting back or sending an AJAX response.
     *
     * @return void
     */
    public function terminate_request()
    {
    }
    /**
     * Persists settings errors.
     *
     * Settings errors are stored in a transient for 30 seconds so that this transient
     * can be retrieved on the next page load.
     *
     * @return void
     */
    protected function persist_settings_errors()
    {
    }
    /**
     * Redirects back to the referer URL, with optional query arguments.
     *
     * @param array $query_args Optional. Query arguments to add to the redirect URL. Default none.
     *
     * @return void
     */
    protected function redirect_back($query_args = [])
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Network
   */
  /**
   * Implements a network settings API for the plugin's multisite settings.
   */
  class Yoast_Network_Settings_API
  {
    /**
     * Registered network settings.
     *
     * @var array
     */
    private $registered_settings = [];
    /**
     * Options whitelist, keyed by option group.
     *
     * @var array
     */
    private $whitelist_options = [];
    /**
     * The singleton instance of this class.
     *
     * @var Yoast_Network_Settings_API
     */
    private static $instance = \null;
    /**
     * Registers a network setting and its data.
     *
     * @param string $option_group The group the network option is part of.
     * @param string $option_name  The name of the network option to sanitize and save.
     * @param array  $args         {
     *     Optional. Data used to describe the network setting when registered.
     *
     *     @type callable $sanitize_callback A callback function that sanitizes the network option's value.
     *     @type mixed    $default           Default value when calling `get_network_option()`.
     * }
     *
     * @return void
     */
    public function register_setting($option_group, $option_name, $args = [])
    {
    }
    /**
     * Gets the registered settings and their data.
     *
     * @return array Array of $option_name => $data pairs.
     */
    public function get_registered_settings()
    {
    }
    /**
     * Gets the whitelisted options for a given option group.
     *
     * @param string $option_group Option group.
     *
     * @return array List of option names, or empty array if unknown option group.
     */
    public function get_whitelist_options($option_group)
    {
    }
    /**
     * Filters sanitization for a network option value.
     *
     * This method is added as a filter to `sanitize_option_{$option}` for network options that are
     * registered with a sanitize callback.
     *
     * @param string $value  The sanitized option value.
     * @param string $option The option name.
     *
     * @return string The filtered sanitized option value.
     */
    public function filter_sanitize_option($value, $option)
    {
    }
    /**
     * Filters the default value for a network option.
     *
     * This function is added as a filter to `default_site_option_{$option}` for network options that
     * are registered with a default.
     *
     * @param mixed  $default_value Existing default value to return.
     * @param string $option        The option name.
     *
     * @return mixed The filtered default value.
     */
    public function filter_default_option($default_value, $option)
    {
    }
    /**
     * Checks whether the requirements to use this class are met.
     *
     * @return bool True if requirements are met, false otherwise.
     */
    public function meets_requirements()
    {
    }
    /**
     * Gets the singleton instance of this class.
     *
     * @return Yoast_Network_Settings_API The singleton instance.
     */
    public static function get()
    {
    }
  }
  /**
   * Handles notifications storage and display.
   */
  class Yoast_Notification_Center
  {
    /**
     * Option name to store notifications on.
     *
     * @var string
     */
    const STORAGE_KEY = 'yoast_notifications';
    /**
     * The singleton instance of this object.
     *
     * @var \Yoast_Notification_Center
     */
    private static $instance = \null;
    /**
     * Holds the notifications.
     *
     * @var \Yoast_Notification[][]
     */
    private $notifications = [];
    /**
     * Notifications there are newly added.
     *
     * @var array
     */
    private $new = [];
    /**
     * Notifications that were resolved this execution.
     *
     * @var int
     */
    private $resolved = 0;
    /**
     * Internal storage for transaction before notifications have been retrieved from storage.
     *
     * @var array
     */
    private $queued_transactions = [];
    /**
     * Internal flag for whether notifications have been retrieved from storage.
     *
     * @var bool
     */
    private $notifications_retrieved = \false;
    /**
     * Internal flag for whether notifications need to be updated in storage.
     *
     * @var bool
     */
    private $notifications_need_storage = \false;
    /**
     * Construct.
     */
    private function __construct()
    {
    }
    /**
     * Singleton getter.
     *
     * @return Yoast_Notification_Center
     */
    public static function get()
    {
    }
    /**
     * Dismiss a notification.
     */
    public static function ajax_dismiss_notification()
    {
    }
    /**
     * Check if the user has dismissed a notification.
     *
     * @param Yoast_Notification $notification The notification to check for dismissal.
     * @param int|null           $user_id      User ID to check on.
     *
     * @return bool
     */
    public static function is_notification_dismissed(\Yoast_Notification $notification, $user_id = \null)
    {
    }
    /**
     * Checks if the notification is being dismissed.
     *
     * @param Yoast_Notification $notification Notification to check dismissal of.
     * @param string             $meta_value   Value to set the meta value to if dismissed.
     *
     * @return bool True if dismissed.
     */
    public static function maybe_dismiss_notification(\Yoast_Notification $notification, $meta_value = 'seen')
    {
    }
    /**
     * Dismisses a notification.
     *
     * @param Yoast_Notification $notification Notification to dismiss.
     * @param string             $meta_value   Value to save in the dismissal.
     *
     * @return bool True if dismissed, false otherwise.
     */
    public static function dismiss_notification(\Yoast_Notification $notification, $meta_value = 'seen')
    {
    }
    /**
     * Restores a notification.
     *
     * @param Yoast_Notification $notification Notification to restore.
     *
     * @return bool True if restored, false otherwise.
     */
    public static function restore_notification(\Yoast_Notification $notification)
    {
    }
    /**
     * Clear dismissal information for the specified Notification.
     *
     * When a cause is resolved, the next time it is present we want to show
     * the message again.
     *
     * @param string|Yoast_Notification $notification Notification to clear the dismissal of.
     *
     * @return bool
     */
    public function clear_dismissal($notification)
    {
    }
    /**
     * Retrieves notifications from the storage and merges in previous notification changes.
     *
     * The current user in WordPress is not loaded shortly before the 'init' hook, but the plugin
     * sometimes needs to add or remove notifications before that. In such cases, the transactions
     * are not actually executed, but added to a queue. That queue is then handled in this method,
     * after notifications for the current user have been set up.
     *
     * @return void
     */
    public function setup_current_notifications()
    {
    }
    /**
     * Add notification to the cookie.
     *
     * @param Yoast_Notification $notification Notification object instance.
     */
    public function add_notification(\Yoast_Notification $notification)
    {
    }
    /**
     * Get the notification by ID and user ID.
     *
     * @param string   $notification_id The ID of the notification to search for.
     * @param int|null $user_id         The ID of the user.
     *
     * @return Yoast_Notification|null
     */
    public function get_notification_by_id($notification_id, $user_id = \null)
    {
    }
    /**
     * Display the notifications.
     *
     * @param bool $echo_as_json True when notifications should be printed directly.
     *
     * @return void
     */
    public function display_notifications($echo_as_json = \false)
    {
    }
    /**
     * Remove notification after it has been displayed.
     *
     * @param Yoast_Notification $notification Notification to remove.
     * @param bool               $resolve      Resolve as fixed.
     */
    public function remove_notification(\Yoast_Notification $notification, $resolve = \true)
    {
    }
    /**
     * Removes a notification by its ID.
     *
     * @param string $notification_id The notification id.
     * @param bool   $resolve         Resolve as fixed.
     *
     * @return void
     */
    public function remove_notification_by_id($notification_id, $resolve = \true)
    {
    }
    /**
     * Get the notification count.
     *
     * @param bool $dismissed Count dismissed notifications.
     *
     * @return int Number of notifications
     */
    public function get_notification_count($dismissed = \false)
    {
    }
    /**
     * Get the number of notifications resolved this execution.
     *
     * These notifications have been resolved and should be counted when active again.
     *
     * @return int
     */
    public function get_resolved_notification_count()
    {
    }
    /**
     * Return the notifications sorted on type and priority.
     *
     * @return array|Yoast_Notification[] Sorted Notifications
     */
    public function get_sorted_notifications()
    {
    }
    /**
     * AJAX display notifications.
     */
    public function ajax_get_notifications()
    {
    }
    /**
     * Remove storage when the plugin is deactivated.
     */
    public function deactivate_hook()
    {
    }
    /**
     * Returns the given user ID if it exists.
     * Otherwise, this function returns the ID of the current user.
     *
     * @param int $user_id The user ID to check.
     *
     * @return int The user ID to use.
     */
    private static function get_user_id($user_id)
    {
    }
    /**
     * Splits the notifications on user ID.
     *
     * In other terms, it returns an associative array,
     * mapping user ID to a list of notifications for this user.
     *
     * @param array|Yoast_Notification[] $notifications The notifications to split.
     *
     * @return array The notifications, split on user ID.
     */
    private function split_on_user_id($notifications)
    {
    }
    /**
     * Save persistent notifications to storage.
     *
     * We need to be able to retrieve these so they can be dismissed at any time during the execution.
     *
     * @since 3.2
     *
     * @return void
     */
    public function update_storage()
    {
    }
    /**
     * Stores the notifications to its respective user's storage.
     *
     * @param array|Yoast_Notification[] $notifications The notifications to store.
     * @param int                        $user_id       The ID of the user for which to store the notifications.
     *
     * @return void
     */
    private function store_notifications_for_user($notifications, $user_id)
    {
    }
    /**
     * Provide a way to verify present notifications.
     *
     * @return array|Yoast_Notification[] Registered notifications.
     */
    public function get_notifications()
    {
    }
    /**
     * Returns the notifications for the given user.
     *
     * @param int $user_id The id of the user to check.
     *
     * @return Yoast_Notification[] The notifications for the user with the given ID.
     */
    public function get_notifications_for_user($user_id)
    {
    }
    /**
     * Get newly added notifications.
     *
     * @return array
     */
    public function get_new_notifications()
    {
    }
    /**
     * Get information from the User input.
     *
     * Note that this function does not handle nonce verification.
     *
     * @param string $key Key to retrieve.
     *
     * @return string non-sanitized value of key if set, an empty string otherwise.
     */
    private static function get_user_input($key)
    {
    }
    /**
     * Retrieve the notifications from storage and fill the relevant property.
     *
     * @param int $user_id The ID of the user to retrieve notifications for.
     *
     * @return void
     */
    private function retrieve_notifications_from_storage($user_id)
    {
    }
    /**
     * Sort on type then priority.
     *
     * @param Yoast_Notification $a Compare with B.
     * @param Yoast_Notification $b Compare with A.
     *
     * @return int 1, 0 or -1 for sorting offset.
     */
    private function sort_notifications(\Yoast_Notification $a, \Yoast_Notification $b)
    {
    }
    /**
     * Clear local stored notifications.
     */
    private function clear_notifications()
    {
    }
    /**
     * Filter out non-persistent notifications.
     *
     * @since 3.2
     *
     * @param Yoast_Notification $notification Notification to test for persistent.
     *
     * @return bool
     */
    private function filter_persistent_notifications(\Yoast_Notification $notification)
    {
    }
    /**
     * Filter out dismissed notifications.
     *
     * @param Yoast_Notification $notification Notification to check.
     *
     * @return bool
     */
    private function filter_dismissed_notifications(\Yoast_Notification $notification)
    {
    }
    /**
     * Convert Notification to array representation.
     *
     * @since 3.2
     *
     * @param Yoast_Notification $notification Notification to convert.
     *
     * @return array
     */
    private function notification_to_array(\Yoast_Notification $notification)
    {
    }
    /**
     * Convert stored array to Notification.
     *
     * @param array $notification_data Array to convert to Notification.
     *
     * @return Yoast_Notification
     */
    private function array_to_notification($notification_data)
    {
    }
    /**
     * Filter notifications that should not be displayed for the current user.
     *
     * @param Yoast_Notification $notification Notification to test.
     *
     * @return bool
     */
    private function filter_notification_current_user(\Yoast_Notification $notification)
    {
    }
    /**
     * Checks if given notification is persistent.
     *
     * @param Yoast_Notification $notification The notification to check.
     *
     * @return bool True when notification is not persistent.
     */
    private function is_notification_persistent(\Yoast_Notification $notification)
    {
    }
    /**
     * Queues a notification transaction for later execution if notifications are not yet set up.
     *
     * @param callable $callback Callback that performs the transaction.
     * @param array    $args     Arguments to pass to the callback.
     *
     * @return bool True if transaction was queued, false if it can be performed immediately.
     */
    private function queue_transaction($callback, $args)
    {
    }
    /**
     * Adds a notification transaction to the queue for later execution.
     *
     * @param callable $callback Callback that performs the transaction.
     * @param array    $args     Arguments to pass to the callback.
     */
    private function add_transaction_to_queue($callback, $args)
    {
    }
    /**
     * Removes all notifications from storage.
     *
     * @return bool True when notifications got removed.
     */
    protected function remove_storage()
    {
    }
    /**
     * Checks if there are stored notifications.
     *
     * @return bool True when there are stored notifications.
     */
    protected function has_stored_notifications()
    {
    }
    /**
     * Retrieves the stored notifications.
     *
     * @codeCoverageIgnore
     *
     * @return array|false Array with notifications or false when not set.
     */
    protected function get_stored_notifications()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Notifications
   * @since   1.5.3
   */
  /**
   * Implements individual notification.
   */
  class Yoast_Notification
  {
    /**
     * Type of capability check.
     *
     * @var string
     */
    const MATCH_ALL = 'all';
    /**
     * Type of capability check.
     *
     * @var string
     */
    const MATCH_ANY = 'any';
    /**
     * Notification type.
     *
     * @var string
     */
    const ERROR = 'error';
    /**
     * Notification type.
     *
     * @var string
     */
    const WARNING = 'warning';
    /**
     * Notification type.
     *
     * @var string
     */
    const UPDATED = 'updated';
    /**
     * Options of this Notification.
     *
     * Contains optional arguments:
     *
     * -             type: The notification type, i.e. 'updated' or 'error'
     * -               id: The ID of the notification
     * -            nonce: Security nonce to use in case of dismissible notice.
     * -         priority: From 0 to 1, determines the order of Notifications.
     * -    dismissal_key: Option name to save dismissal information in, ID will be used if not supplied.
     * -     capabilities: Capabilities that a user must have for this Notification to show.
     * - capability_check: How to check capability pass: all or any.
     * -  wpseo_page_only: Only display on wpseo page or on every page.
     *
     * @var array
     */
    private $options = [];
    /**
     * Contains default values for the optional arguments.
     *
     * @var array
     */
    private $defaults = ['type' => self::UPDATED, 'id' => '', 'user' => \null, 'nonce' => \null, 'priority' => 0.5, 'data_json' => [], 'dismissal_key' => \null, 'capabilities' => [], 'capability_check' => self::MATCH_ALL, 'yoast_branding' => \false];
    /**
     * The message for the notification.
     *
     * @var string
     */
    private $message;
    /**
     * Notification class constructor.
     *
     * @param string $message Message string.
     * @param array  $options Set of options.
     */
    public function __construct($message, $options = [])
    {
    }
    /**
     * Retrieve notification ID string.
     *
     * @return string
     */
    public function get_id()
    {
    }
    /**
     * Retrieve the user to show the notification for.
     *
     * @return WP_User The user to show this notification for.
     */
    public function get_user()
    {
    }
    /**
     * Retrieve the id of the user to show the notification for.
     *
     * Returns the id of the current user if not user has been sent.
     *
     * @return int The user id
     */
    public function get_user_id()
    {
    }
    /**
     * Retrieve nonce identifier.
     *
     * @return string|null Nonce for this Notification.
     */
    public function get_nonce()
    {
    }
    /**
     * Make sure the nonce is up to date.
     */
    public function refresh_nonce()
    {
    }
    /**
     * Get the type of the notification.
     *
     * @return string
     */
    public function get_type()
    {
    }
    /**
     * Priority of the notification.
     *
     * Relative to the type.
     *
     * @return float Returns the priority between 0 and 1.
     */
    public function get_priority()
    {
    }
    /**
     * Get the User Meta key to check for dismissal of notification.
     *
     * @return string User Meta Option key that registers dismissal.
     */
    public function get_dismissal_key()
    {
    }
    /**
     * Is this Notification persistent.
     *
     * @return bool True if persistent, False if fire and forget.
     */
    public function is_persistent()
    {
    }
    /**
     * Check if the notification is relevant for the current user.
     *
     * @return bool True if a user needs to see this notification, false if not.
     */
    public function display_for_current_user()
    {
    }
    /**
     * Does the current user match required capabilities.
     *
     * @return bool
     */
    public function match_capabilities()
    {
    }
    /**
     * Array filter function to find matched capabilities.
     *
     * @param string $capability Capability to test.
     *
     * @return bool
     */
    private function has_capability($capability)
    {
    }
    /**
     * Return the object properties as an array.
     *
     * @return array
     */
    public function to_array()
    {
    }
    /**
     * Adds string (view) behaviour to the notification.
     *
     * @return string
     */
    public function __toString()
    {
    }
    /**
     * Renders the notification as a string.
     *
     * @return string The rendered notification.
     */
    public function render()
    {
    }
    /**
     * Wraps the message with a Yoast SEO icon.
     *
     * @param string $message The message to wrap.
     *
     * @return string The wrapped message.
     */
    private function wrap_yoast_seo_icon($message)
    {
    }
    /**
     * Get the JSON if provided.
     *
     * @return false|string
     */
    public function get_json()
    {
    }
    /**
     * Make sure we only have values that we can work with.
     *
     * @param array $options Options to normalize.
     *
     * @return array
     */
    private function normalize_options($options)
    {
    }
    /**
     * Format HTML element attributes.
     *
     * @param string $value Attribute value.
     * @param string $key   Attribute name.
     */
    private function parse_attributes(&$value, $key)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Notifications
   */
  /**
   * Class Yoast_Notifications.
   */
  class Yoast_Notifications
  {
    /**
     * Holds the admin page's ID.
     *
     * @var string
     */
    const ADMIN_PAGE = 'wpseo_dashboard';
    /**
     * Total notifications count.
     *
     * @var int
     */
    private static $notification_count = 0;
    /**
     * All error notifications.
     *
     * @var array
     */
    private static $errors = [];
    /**
     * Active errors.
     *
     * @var array
     */
    private static $active_errors = [];
    /**
     * Dismissed errors.
     *
     * @var array
     */
    private static $dismissed_errors = [];
    /**
     * All warning notifications.
     *
     * @var array
     */
    private static $warnings = [];
    /**
     * Active warnings.
     *
     * @var array
     */
    private static $active_warnings = [];
    /**
     * Dismissed warnings.
     *
     * @var array
     */
    private static $dismissed_warnings = [];
    /**
     * Yoast_Notifications constructor.
     */
    public function __construct()
    {
    }
    /**
     * Add hooks
     */
    private function add_hooks()
    {
    }
    /**
     * Enqueue assets.
     */
    public function enqueue_assets()
    {
    }
    /**
     * Handle ajax request to dismiss a notification.
     */
    public function ajax_dismiss_notification()
    {
    }
    /**
     * Handle ajax request to restore a notification.
     */
    public function ajax_restore_notification()
    {
    }
    /**
     * Create AJAX response data.
     *
     * @param string $type Notification type.
     */
    private function output_ajax_response($type)
    {
    }
    /**
     * Get the HTML to return in the AJAX request.
     *
     * @param string $type Notification type.
     *
     * @return bool|string
     */
    private function get_view_html($type)
    {
    }
    /**
     * Extract the Yoast Notification from the AJAX request.
     *
     * This function does not handle nonce verification.
     *
     * @return Yoast_Notification|null A Yoast_Notification on success, null on failure.
     */
    private function get_notification_from_ajax_request()
    {
    }
    /**
     * Collect the notifications and group them together.
     */
    public static function collect_notifications()
    {
    }
    /**
     * Get the variables needed in the views.
     *
     * @return array
     */
    public static function get_template_variables()
    {
    }
    /**
     * Get the number of active notifications.
     *
     * @return int
     */
    public static function get_active_notification_count()
    {
    }
    /**
     * Filter out any non-errors.
     *
     * @param Yoast_Notification $notification Notification to test.
     *
     * @return bool
     */
    private static function filter_error_notifications(\Yoast_Notification $notification)
    {
    }
    /**
     * Filter out any non-warnings.
     *
     * @param Yoast_Notification $notification Notification to test.
     *
     * @return bool
     */
    private static function filter_warning_notifications(\Yoast_Notification $notification)
    {
    }
    /**
     * Filter out any dismissed notifications.
     *
     * @param Yoast_Notification $notification Notification to test.
     *
     * @return bool
     */
    private static function filter_dismissed_notifications(\Yoast_Notification $notification)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Endpoints
   */
  /**
   * Dictates the required methods for an Endpoint implementation.
   */
  interface WPSEO_Endpoint
  {
    /**
     * Registers the routes for the endpoints.
     *
     * @return void
     */
    public function register();
    /**
     * Determines whether or not data can be retrieved for the registered endpoints.
     *
     * @return bool Whether or not data can be retrieved.
     */
    public function can_retrieve_data();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Endpoints
   */
  /**
   * Represents an implementation of the WPSEO_Endpoint interface to register one or multiple endpoints.
   */
  class WPSEO_Endpoint_File_Size implements \WPSEO_Endpoint
  {
    /**
     * The namespace of the REST route.
     *
     * @var string
     */
    const REST_NAMESPACE = 'yoast/v1';
    /**
     * The route of the endpoint to retrieve the file size.
     *
     * @var string
     */
    const ENDPOINT_SINGULAR = 'file_size';
    /**
     * The name of the capability needed to retrieve data using the endpoints.
     *
     * @var string
     */
    const CAPABILITY_RETRIEVE = 'manage_options';
    /**
     * The service provider.
     *
     * @var WPSEO_File_Size_Service
     */
    private $service;
    /**
     * Sets the service provider.
     *
     * @param WPSEO_File_Size_Service $service The service provider.
     */
    public function __construct(\WPSEO_File_Size_Service $service)
    {
    }
    /**
     * Registers the routes for the endpoints.
     *
     * @return void
     */
    public function register()
    {
    }
    /**
     * Determines whether or not data can be retrieved for the registered endpoints.
     *
     * @return bool Whether or not data can be retrieved.
     */
    public function can_retrieve_data()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Statistics
   */
  /**
   * Represents an implementation of the WPSEO_Endpoint interface to register one or multiple endpoints.
   */
  class WPSEO_Endpoint_Statistics implements \WPSEO_Endpoint
  {
    /**
     * The namespace of the REST route.
     *
     * @var string
     */
    const REST_NAMESPACE = 'yoast/v1';
    /**
     * The route of the statistics endpoint.
     *
     * @var string
     */
    const ENDPOINT_RETRIEVE = 'statistics';
    /**
     * The name of the capability needed to retrieve data using the endpoints.
     *
     * @var string
     */
    const CAPABILITY_RETRIEVE = 'read';
    /**
     * Service to use.
     *
     * @var WPSEO_Statistics_Service
     */
    protected $service;
    /**
     * Constructs the WPSEO_Endpoint_Statistics class and sets the service to use.
     *
     * @param WPSEO_Statistics_Service $service Service to use.
     */
    public function __construct(\WPSEO_Statistics_Service $service)
    {
    }
    /**
     * Registers the REST routes that are available on the endpoint.
     */
    public function register()
    {
    }
    /**
     * Determines whether or not data can be retrieved for the registered endpoints.
     *
     * @return bool Whether or not data can be retrieved.
     */
    public function can_retrieve_data()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Exceptions
   */
  /**
   * Represents named methods for exceptions.
   */
  class WPSEO_File_Size_Exception extends \Exception
  {
    /**
     * Gets the exception for an externally hosted file.
     *
     * @param string $file_url The file url.
     *
     * @return WPSEO_File_Size_Exception Instance of the exception.
     */
    public static function externally_hosted($file_url)
    {
    }
    /**
     * Gets the exception for when a unknown error occurs.
     *
     * @param string $file_url The file url.
     *
     * @return WPSEO_File_Size_Exception Instance of the exception.
     */
    public static function unknown_error($file_url)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Filters
   */
  /**
   * Class WPSEO_Abstract_Post_Filter.
   */
  abstract class WPSEO_Abstract_Post_Filter implements \WPSEO_WordPress_Integration
  {
    /**
     * The filter's query argument.
     *
     * @var string
     */
    const FILTER_QUERY_ARG = 'yoast_filter';
    /**
     * Modify the query based on the FILTER_QUERY_ARG variable in $_GET.
     *
     * @param string $where Query variables.
     *
     * @return string The modified query.
     */
    public abstract function filter_posts($where);
    /**
     * Returns the query value this filter uses.
     *
     * @return string The query value this filter uses.
     */
    public abstract function get_query_val();
    /**
     * Returns the total number of posts that match this filter.
     *
     * @return int The total number of posts that match this filter.
     */
    protected abstract function get_post_total();
    /**
     * Returns the label for this filter.
     *
     * @return string The label for this filter.
     */
    protected abstract function get_label();
    /**
     * Registers the hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the filter links to the view_edit screens to give the user a filter link.
     *
     * @return void
     */
    public function add_filter_links()
    {
    }
    /**
     * Enqueues the necessary assets to display a filter explanation.
     *
     * @return void
     */
    public function enqueue_explanation_assets()
    {
    }
    /**
     * Adds a filter link to the views.
     *
     * @param array $views Array with the views.
     *
     * @return array Array of views including the added view.
     */
    public function add_filter_link(array $views)
    {
    }
    /**
     * Returns a text explaining this filter. Null if no explanation is necessary.
     *
     * @return string|null The explanation or null.
     */
    protected function get_explanation()
    {
    }
    /**
     * Renders a hidden input to preserve this filter's state when using sub-filters.
     *
     * @return void
     */
    public function render_hidden_input()
    {
    }
    /**
     * Returns an url to edit.php with post_type and this filter as the query arguments.
     *
     * @return string The url to activate this filter.
     */
    protected function get_filter_url()
    {
    }
    /**
     * Returns true when the filter is active.
     *
     * @return bool Whether the filter is active.
     */
    protected function is_filter_active()
    {
    }
    /**
     * Returns the current post type.
     *
     * @return string The current post type.
     */
    protected function get_current_post_type()
    {
    }
    /**
     * Returns the post types to which this filter should be added.
     *
     * @return array The post types to which this filter should be added.
     */
    protected function get_post_types()
    {
    }
    /**
     * Checks if the post type is supported.
     *
     * @param string $post_type Post type to check against.
     *
     * @return bool True when it is supported.
     */
    protected function is_supported_post_type($post_type)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Registers the filter for filtering posts by cornerstone content.
   */
  class WPSEO_Cornerstone_Filter extends \WPSEO_Abstract_Post_Filter
  {
    /**
     * Name of the meta value.
     *
     * @var string
     */
    const META_NAME = 'is_cornerstone';
    /**
     * Registers the hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the query value this filter uses.
     *
     * @return string The query value this filter uses.
     */
    public function get_query_val()
    {
    }
    /**
     * Modify the query based on the seo_filter variable in $_GET.
     *
     * @param string $where Query variables.
     *
     * @return string The modified query.
     */
    public function filter_posts($where)
    {
    }
    /**
     * Filters the post types that have the metabox disabled.
     *
     * @param array $post_types The post types to filter.
     *
     * @return array The filtered post types.
     */
    public function filter_metabox_disabled($post_types)
    {
    }
    /**
     * Returns the label for this filter.
     *
     * @return string The label for this filter.
     */
    protected function get_label()
    {
    }
    /**
     * Returns a text explaining this filter.
     *
     * @return string|null The explanation.
     */
    protected function get_explanation()
    {
    }
    /**
     * Returns the total amount of articles marked as cornerstone content.
     *
     * @return int
     */
    protected function get_post_total()
    {
    }
    /**
     * Returns the post types to which this filter should be added.
     *
     * @return array The post types to which this filter should be added.
     */
    protected function get_post_types()
    {
    }
  }
  /**
   * This class forces needed methods for the metabox localization.
   */
  class WPSEO_Metabox_Formatter
  {
    /**
     * Object that provides formatted values.
     *
     * @var WPSEO_Metabox_Formatter_Interface
     */
    private $formatter;
    /**
     * Setting the formatter property.
     *
     * @param WPSEO_Metabox_Formatter_Interface $formatter Object that provides the formatted values.
     */
    public function __construct(\WPSEO_Metabox_Formatter_Interface $formatter)
    {
    }
    /**
     * Returns the values.
     *
     * @return array
     */
    public function get_values()
    {
    }
    /**
     * Returns array with all the values always needed by a scraper object.
     *
     * @return array Default settings for the metabox.
     */
    private function get_defaults()
    {
    }
    /**
     * Returns required yoast-component translations.
     *
     * @return array
     */
    private function get_content_analysis_component_translations()
    {
    }
    /**
     * Returns Jed compatible YoastSEO.js translations.
     *
     * @return array
     */
    private function get_translations()
    {
    }
    /**
     * Checks if Jetpack's markdown module is enabled.
     * Can be extended to work with other plugins that parse markdown in the content.
     *
     * @return bool
     */
    private function is_markdown_enabled()
    {
    }
    /**
     * Checks if the user is logged in to SEMrush.
     *
     * @return bool The SEMrush login status.
     */
    private function get_semrush_login_status()
    {
    }
    /**
     * Checks whether a multilingual plugin is currently active. Currently, we only check the following plugins: WPML, Polylang, and TranslatePress.
     *
     * @return bool Whether a multilingual plugin is currently active.
     */
    private function multilingual_plugin_active()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Formatter
   */
  /**
   * Interface to force get_values.
   */
  interface WPSEO_Metabox_Formatter_Interface
  {
    /**
     * Returns formatter values.
     *
     * @return array
     */
    public function get_values();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Formatter
   */
  /**
   * This class provides data for the post metabox by return its values for localization.
   */
  class WPSEO_Post_Metabox_Formatter implements \WPSEO_Metabox_Formatter_Interface
  {
    /**
     * Holds the WordPress Post.
     *
     * @var WP_Post
     */
    private $post;
    /**
     * The permalink to follow.
     *
     * @var string
     */
    private $permalink;
    /**
     * Whether we must return social templates values.
     *
     * @var bool
     */
    private $use_social_templates = \false;
    /**
     * Constructor.
     *
     * @param WP_Post|array $post      Post object.
     * @param array         $options   Title options to use.
     * @param string        $structure The permalink to follow.
     */
    public function __construct($post, array $options, $structure)
    {
    }
    /**
     * Determines whether the social templates should be used.
     *
     * @return bool Whether the social templates should be used.
     */
    public function use_social_templates()
    {
    }
    /**
     * Returns the translated values.
     *
     * @return array
     */
    public function get_values()
    {
    }
    /**
     * Gets the image URL for the post's social preview.
     *
     * @return string|null The image URL for the social preview.
     */
    protected function get_image_url()
    {
    }
    /**
     * Returns the url to search for keyword for the post.
     *
     * @return string
     */
    private function search_url()
    {
    }
    /**
     * Returns the url to edit the taxonomy.
     *
     * @return string
     */
    private function edit_url()
    {
    }
    /**
     * Returns a base URL for use in the JS, takes permalink structure into account.
     *
     * @return string
     */
    private function base_url_for_js()
    {
    }
    /**
     * Counts the number of given keywords used for other posts other than the given post_id.
     *
     * @return array The keyword and the associated posts that use it.
     */
    private function get_focus_keyword_usage()
    {
    }
    /**
     * Retrieves the post types for the given post IDs.
     *
     * @param array $post_ids_per_keyword An associative array with keywords as keys and an array of post ids where those keywords are used.
     * @return array The post types for the given post IDs.
     */
    private function get_post_types_for_all_ids($post_ids_per_keyword)
    {
    }
    /**
     * Gets the keyword usage for the current post and the specified keyword.
     *
     * @param string $keyword The keyword to check the usage of.
     *
     * @return array The post IDs which use the passed keyword.
     */
    protected function get_keyword_usage_for_current_post($keyword)
    {
    }
    /**
     * Retrieves the title template.
     *
     * @param bool $fallback Whether to return the hardcoded fallback if the template value is empty.
     *
     * @return string The title template.
     */
    private function get_title_template($fallback = \true)
    {
    }
    /**
     * Retrieves the metadesc template.
     *
     * @return string The metadesc template.
     */
    private function get_metadesc_template()
    {
    }
    /**
     * Retrieves the social title template.
     *
     * @return string The social title template.
     */
    private function get_social_title_template()
    {
    }
    /**
     * Retrieves the social description template.
     *
     * @return string The social description template.
     */
    private function get_social_description_template()
    {
    }
    /**
     * Retrieves the social image template.
     *
     * @return string The social description template.
     */
    private function get_social_image_template()
    {
    }
    /**
     * Retrieves a template.
     *
     * @param string $template_option_name The name of the option in which the template you want to get is saved.
     *
     * @return string
     */
    private function get_template($template_option_name)
    {
    }
    /**
     * Retrieves a social template.
     *
     * @param string $template_option_name The name of the option in which the template you want to get is saved.
     *
     * @return string
     */
    private function get_social_template($template_option_name)
    {
    }
    /**
     * Determines the date to be displayed in the snippet preview.
     *
     * @return string
     */
    private function get_metadesc_date()
    {
    }
    /**
     * Determines whether the insights feature is enabled for this post.
     *
     * @return bool
     */
    protected function is_insights_enabled()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Formatter
   */
  /**
   * This class provides data for the term metabox by return its values for localization.
   */
  class WPSEO_Term_Metabox_Formatter implements \WPSEO_Metabox_Formatter_Interface
  {
    /**
     * The term the metabox formatter is for.
     *
     * @var WP_Term|stdClass
     */
    private $term;
    /**
     * The term's taxonomy.
     *
     * @var stdClass
     */
    private $taxonomy;
    /**
     * Whether we must return social templates values.
     *
     * @var bool
     */
    private $use_social_templates = \false;
    /**
     * Array with the WPSEO_Titles options.
     *
     * @var array
     */
    protected $options;
    /**
     * WPSEO_Taxonomy_Scraper constructor.
     *
     * @param stdClass         $taxonomy Taxonomy.
     * @param WP_Term|stdClass $term     Term.
     */
    public function __construct($taxonomy, $term)
    {
    }
    /**
     * Determines whether the social templates should be used.
     *
     * @return bool Whether the social templates should be used.
     */
    public function use_social_templates()
    {
    }
    /**
     * Returns the translated values.
     *
     * @return array
     */
    public function get_values()
    {
    }
    /**
     * Gets the image URL for the term's social preview.
     *
     * @return string|null The image URL for the social preview.
     */
    protected function get_image_url()
    {
    }
    /**
     * Returns the url to search for keyword for the taxonomy.
     *
     * @return string
     */
    private function search_url()
    {
    }
    /**
     * Returns the url to edit the taxonomy.
     *
     * @return string
     */
    private function edit_url()
    {
    }
    /**
     * Returns a base URL for use in the JS, takes permalink structure into account.
     *
     * @return string
     */
    private function base_url_for_js()
    {
    }
    /**
     * Counting the number of given keyword used for other term than given term_id.
     *
     * @return array
     */
    private function get_focus_keyword_usage()
    {
    }
    /**
     * Retrieves the title template.
     *
     * @param bool $fallback Whether to return the hardcoded fallback if the template value is empty.
     *
     * @return string The title template.
     */
    private function get_title_template($fallback = \true)
    {
    }
    /**
     * Retrieves the metadesc template.
     *
     * @return string The metadesc template.
     */
    private function get_metadesc_template()
    {
    }
    /**
     * Retrieves the social title template.
     *
     * @return string The social title template.
     */
    private function get_social_title_template()
    {
    }
    /**
     * Retrieves the social description template.
     *
     * @return string The social description template.
     */
    private function get_social_description_template()
    {
    }
    /**
     * Retrieves the social image template.
     *
     * @return string The social description template.
     */
    private function get_social_image_template()
    {
    }
    /**
     * Retrieves a template.
     *
     * @param string $template_option_name The name of the option in which the template you want to get is saved.
     *
     * @return string
     */
    private function get_template($template_option_name)
    {
    }
    /**
     * Retrieves a social template.
     *
     * @param string $template_option_name The name of the option in which the template you want to get is saved.
     *
     * @return string
     */
    private function get_social_template($template_option_name)
    {
    }
    /**
     * Determines whether the insights feature is enabled for this taxonomy.
     *
     * @return bool
     */
    protected function is_insights_enabled()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\admin\google_search_console
   */
  /**
   * Class WPSEO_GSC.
   */
  class WPSEO_GSC
  {
    /**
     * The option where data will be stored.
     *
     * @var string
     */
    const OPTION_WPSEO_GSC = 'wpseo-gsc';
    /**
     * Outputs the HTML for the redirect page.
     *
     * @return void
     */
    public function display()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Import_Plugins_Detector.
   *
   * Class with functionality to detect whether we should import from another SEO plugin.
   */
  class WPSEO_Import_Plugins_Detector
  {
    /**
     * Plugins we need to import from.
     *
     * @var array
     */
    public $needs_import = [];
    /**
     * Detects whether we need to import anything.
     */
    public function detect()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Import_Plugin.
   *
   * Class with functionality to import Yoast SEO settings from other plugins.
   */
  class WPSEO_Import_Plugin
  {
    /**
     * Holds the status of and message about imports.
     *
     * @var WPSEO_Import_Status
     */
    public $status;
    /**
     * Class with functionality to import meta data from other plugins.
     *
     * @var WPSEO_Plugin_Importer
     */
    protected $importer;
    /**
     * Import class constructor.
     *
     * @param WPSEO_Plugin_Importer $importer The importer that needs to perform this action.
     * @param string                $action   The action to perform.
     */
    public function __construct(\WPSEO_Plugin_Importer $importer, $action)
    {
    }
    /**
     * Convenience function to replace %s with plugin name in import message.
     *
     * @param string $msg Message string.
     *
     * @return string Returns message with plugin name instead of replacement variables.
     */
    protected function complete_msg($msg)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Import
   */
  /**
   * Class WPSEO_Import_Settings.
   *
   * Class with functionality to import the Yoast SEO settings.
   */
  class WPSEO_Import_Settings
  {
    /**
     * Nonce action key.
     *
     * @var string
     */
    const NONCE_ACTION = 'wpseo-import-settings';
    /**
     * Holds the import status instance.
     *
     * @var WPSEO_Import_Status
     */
    public $status;
    /**
     * Holds the old WPSEO version.
     *
     * @var string
     */
    private $old_wpseo_version;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Imports the data submitted by the user.
     *
     * @return void
     */
    public function import()
    {
    }
    /**
     * Parse the options.
     *
     * @param string $raw_options The content to parse.
     *
     * @return void
     */
    protected function parse_options($raw_options)
    {
    }
    /**
     * Parse the option group and import it.
     *
     * @param string $name         Name string.
     * @param array  $option_group Option group data.
     * @param array  $options      Options data.
     */
    protected function parse_option_group($name, $option_group, $options)
    {
    }
    /**
     * Imports the options if found.
     *
     * @param array $options The options parsed from the provided settings.
     */
    protected function import_options($options)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Import
   */
  /**
   * Class WPSEO_ImportStatus.
   *
   * Holds the status of and message about imports.
   */
  class WPSEO_Import_Status
  {
    /**
     * The import status.
     *
     * @var bool
     */
    public $status = \false;
    /**
     * The import message.
     *
     * @var string
     */
    private $msg = '';
    /**
     * The type of action performed.
     *
     * @var string
     */
    private $action;
    /**
     * WPSEO_Import_Status constructor.
     *
     * @param string $action The type of import action.
     * @param bool   $status The status of the import.
     * @param string $msg    Extra messages about the status.
     */
    public function __construct($action, $status, $msg = '')
    {
    }
    /**
     * Get the import message.
     *
     * @return string Message about current status.
     */
    public function get_msg()
    {
    }
    /**
     * Get the import action.
     *
     * @return string Import action type.
     */
    public function get_action()
    {
    }
    /**
     * Set the import action, set status to false.
     *
     * @param string $action The type of action to set as import action.
     *
     * @return void
     */
    public function set_action($action)
    {
    }
    /**
     * Sets the importer status message.
     *
     * @param string $msg The message to set.
     *
     * @return void
     */
    public function set_msg($msg)
    {
    }
    /**
     * Sets the importer status.
     *
     * @param bool $status The status to set.
     *
     * @return WPSEO_Import_Status The current object.
     */
    public function set_status($status)
    {
    }
    /**
     * Returns a success message depending on the action.
     *
     * @return string Returns a success message for the current action.
     */
    private function get_default_success_message()
    {
    }
  }
  /**
   * This file holds the abstract class for dealing with imports from other plugins.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Plugin_Importer.
   *
   * Class with functionality to import meta data from other plugins.
   */
  abstract class WPSEO_Plugin_Importer
  {
    /**
     * Holds the import status object.
     *
     * @var WPSEO_Import_Status
     */
    protected $status;
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name;
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key;
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Returns the string for the plugin we're importing from.
     *
     * @return string Plugin name.
     */
    public function get_plugin_name()
    {
    }
    /**
     * Imports the settings and post meta data from another SEO plugin.
     *
     * @return WPSEO_Import_Status Import status object.
     */
    public function run_import()
    {
    }
    /**
     * Handles post meta data to import.
     *
     * @return bool Import success status.
     */
    protected function import()
    {
    }
    /**
     * Removes the plugin data from the database.
     *
     * @return WPSEO_Import_Status Import status object.
     */
    public function run_cleanup()
    {
    }
    /**
     * Removes the plugin data from the database.
     *
     * @return bool Cleanup status.
     */
    protected function cleanup()
    {
    }
    /**
     * Sets the status message for when a cleanup has gone bad.
     *
     * @return void
     */
    protected function cleanup_error_msg()
    {
    }
    /**
     * Detects whether an import for this plugin is needed.
     *
     * @return WPSEO_Import_Status Import status object.
     */
    public function run_detect()
    {
    }
    /**
     * Detects whether there is post meta data to import.
     *
     * @return bool Boolean indicating whether there is something to import.
     */
    protected function detect()
    {
    }
    /**
     * Helper function to clone meta keys and (optionally) change their values in bulk.
     *
     * @param string $old_key        The existing meta key.
     * @param string $new_key        The new meta key.
     * @param array  $replace_values An array, keys old value, values new values.
     *
     * @return bool Clone status.
     */
    protected function meta_key_clone($old_key, $new_key, $replace_values = [])
    {
    }
    /**
     * Clones multiple meta keys.
     *
     * @param array $clone_keys The keys to clone.
     *
     * @return bool Success status.
     */
    protected function meta_keys_clone($clone_keys)
    {
    }
    /**
     * Sets the import status to false and returns a message about why it failed.
     */
    protected function set_missing_db_rights_status()
    {
    }
    /**
     * Helper function to search for a key in an array and maybe save it as a meta field.
     *
     * @param string $plugin_key The key in the $data array to check.
     * @param string $yoast_key  The identifier we use in our meta settings.
     * @param array  $data       The array of data for this post to sift through.
     * @param int    $post_id    The post ID.
     *
     * @return void
     */
    protected function import_meta_helper($plugin_key, $yoast_key, $data, $post_id)
    {
    }
    /**
     * Saves a post meta value if it doesn't already exist.
     *
     * @param string $new_key The key to save.
     * @param mixed  $value   The value to set the key to.
     * @param int    $post_id The Post to save the meta for.
     */
    protected function maybe_save_post_meta($new_key, $value, $post_id)
    {
    }
    /**
     * Replaces values in our temporary table according to our settings.
     *
     * @param array $replace_values Key value pair of values to replace with other values.
     *
     * @return void
     */
    protected function meta_key_clone_replace($replace_values)
    {
    }
  }
  /**
   * Class with functionality to import & clean All in One SEO Pack post metadata, versions 4 and up.
   */
  class WPSEO_Import_AIOSEO_V4 extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'All In One SEO Pack';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_aioseo_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_aioseo_title', 'new_key' => 'title'], ['old_key' => '_aioseo_description', 'new_key' => 'metadesc'], ['old_key' => '_aioseo_og_title', 'new_key' => 'opengraph-title'], ['old_key' => '_aioseo_og_description', 'new_key' => 'opengraph-description'], ['old_key' => '_aioseo_twitter_title', 'new_key' => 'twitter-title'], ['old_key' => '_aioseo_twitter_description', 'new_key' => 'twitter-description']];
    /**
     * Mapping between the AiOSEO replace vars and the Yoast replace vars.
     *
     * @var array
     *
     * @see https://yoast.com/help/list-available-snippet-variables-yoast-seo/
     */
    protected $replace_vars = [
      // They key is the AiOSEO replace var, the value is the Yoast replace var (see class-wpseo-replace-vars).
      '#author_first_name' => '%%author_first_name%%',
      '#author_last_name' => '%%author_last_name%%',
      '#author_name' => '%%name%%',
      '#categories' => '%%category%%',
      '#current_date' => '%%currentdate%%',
      '#current_day' => '%%currentday%%',
      '#current_month' => '%%currentmonth%%',
      '#current_year' => '%%currentyear%%',
      '#permalink' => '%%permalink%%',
      '#post_content' => '%%post_content%%',
      '#post_date' => '%%date%%',
      '#post_day' => '%%post_day%%',
      '#post_month' => '%%post_month%%',
      '#post_title' => '%%title%%',
      '#post_year' => '%%post_year%%',
      '#post_excerpt_only' => '%%excerpt_only%%',
      '#post_excerpt' => '%%excerpt%%',
      '#separator_sa' => '%%sep%%',
      '#site_title' => '%%sitename%%',
      '#tagline' => '%%sitedesc%%',
      '#taxonomy_title' => '%%category_title%%',
    ];
    /**
     * Replaces the AiOSEO variables in our temporary table with Yoast variables (replace vars).
     *
     * @param array $replace_values Key value pair of values to replace with other values. This is only used in the base class but not here.
     *                              That is because this class doesn't have any `convert` keys in `$clone_keys`.
     *                              For that reason, we're overwriting the base class' `meta_key_clone_replace()` function without executing that base functionality.
     *
     * @return void
     */
    protected function meta_key_clone_replace($replace_values)
    {
    }
    /**
     * Filters out all unique custom fields/taxonomies/etc. used in an AiOSEO replace var.
     *
     * @param string[] $meta_values   An array of all the meta values that
     *                                contain one or more AIOSEO custom field replace vars
     *                                (in the form `#custom_field-xyz`).
     * @param string   $aioseo_prefix The AiOSEO prefix to use
     *                                (e.g. `custom-field` for custom fields or `tax_name` for custom taxonomies).
     *
     * @return string[] An array of all the unique custom fields/taxonomies/etc. used in the replace vars.
     *                  E.g. `xyz` in the above example.
     */
    protected function get_unique_custom_fields_or_taxonomies($meta_values, $aioseo_prefix)
    {
    }
    /**
     * Replaces every AIOSEO custom field/taxonomy/etc. replace var with the Yoast version.
     *
     * E.g. `#custom_field-xyz` becomes `%%cf_xyz%%`.
     *
     * @param string[] $unique_custom_fields_or_taxonomies An array of unique custom fields to replace the replace vars of.
     * @param wpdb     $wpdb                               The WordPress database object.
     * @param string   $aioseo_prefix                      The AiOSEO prefix to use
     *                                                     (e.g. `custom-field` for custom fields or `tax_name` for custom taxonomies).
     * @param string   $yoast_prefix                       The Yoast prefix to use (e.g. `cf` for custom fields).
     */
    protected function replace_custom_field_or_taxonomy_replace_vars($unique_custom_fields_or_taxonomies, $wpdb, $aioseo_prefix, $yoast_prefix)
    {
    }
    // phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
    /**
     * Retrieve all the meta values from the temporary meta table that contain
     * at least one AiOSEO custom field replace var.
     *
     * @param wpdb   $wpdb          The WordPress database object.
     * @param string $aioseo_prefix The AiOSEO prefix to use
     *                              (e.g. `custom-field` for custom fields or `tax_name` for custom taxonomies).
     *
     * @return string[] All meta values that contain at least one AioSEO custom field replace var.
     */
    protected function get_meta_values_with_custom_field_or_taxonomy($wpdb, $aioseo_prefix)
    {
    }
    // phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
    /**
     * Detects whether there is AIOSEO data to import by looking whether the AIOSEO data have been cleaned up.
     *
     * @return bool Boolean indicating whether there is something to import.
     */
    protected function detect()
    {
    }
    /**
     * Import AIOSEO post data from their custom indexable table. Not currently used.
     *
     * @return void
     */
    protected function import()
    {
    }
  }
  /**
   * File with the class to handle data from All in One SEO Pack, versions 3 and under.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean All in One SEO Pack post metadata, versions 3 and under.
   */
  class WPSEO_Import_AIOSEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'All In One SEO Pack';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_aioseop_%';
    /**
     * OpenGraph keys to import.
     *
     * @var array
     */
    protected $import_keys = ['aioseop_opengraph_settings_title' => 'opengraph-title', 'aioseop_opengraph_settings_desc' => 'opengraph-description', 'aioseop_opengraph_settings_customimg' => 'opengraph-image', 'aioseop_opengraph_settings_customimg_twitter' => 'twitter-image'];
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_aioseop_title', 'new_key' => 'title'], ['old_key' => '_aioseop_description', 'new_key' => 'metadesc'], ['old_key' => '_aioseop_noindex', 'new_key' => 'meta-robots-noindex', 'convert' => ['on' => 1]], ['old_key' => '_aioseop_nofollow', 'new_key' => 'meta-robots-nofollow', 'convert' => ['on' => 1]]];
    /**
     * Import All In One SEO meta values.
     *
     * @return bool Import success status.
     */
    protected function import()
    {
    }
    /**
     * Imports the OpenGraph and Twitter settings for all posts.
     *
     * @return bool
     */
    protected function import_opengraph()
    {
    }
    /**
     * Imports the OpenGraph and Twitter settings for a single post.
     *
     * @param int $post_id Post ID.
     */
    private function import_post_opengraph($post_id)
    {
    }
  }
  /**
   * File with the class to handle data from Ultimate SEO.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean Ultimate SEO post metadata.
   */
  class WPSEO_Import_Greg_SEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = "Greg's High Performance SEO";
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_ghpseo_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_ghpseo_alternative_description', 'new_key' => 'metadesc'], ['old_key' => '_ghpseo_secondary_title', 'new_key' => 'title']];
  }
  /**
   * File with the class to handle data from HeadSpace.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Import_HeadSpace.
   *
   * Class with functionality to import & clean HeadSpace SEO post metadata.
   */
  class WPSEO_Import_HeadSpace extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'HeadSpace SEO';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_headspace_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_headspace_description', 'new_key' => 'metadesc'], ['old_key' => '_headspace_page_title', 'new_key' => 'title'], ['old_key' => '_headspace_noindex', 'new_key' => 'meta-robots-noindex', 'convert' => ['on' => 1]], ['old_key' => '_headspace_nofollow', 'new_key' => 'meta-robots-nofollow', 'convert' => ['on' => 1]]];
  }
  /**
   * File with the class to handle data from Jetpack's Advanced SEO settings.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Import_Jetpack_SEO.
   *
   * Class with functionality to import & clean Jetpack SEO post metadata.
   */
  class WPSEO_Import_Jetpack_SEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'Jetpack';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = 'advanced_seo_description';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => 'advanced_seo_description', 'new_key' => 'metadesc']];
  }
  /**
   * File with the class to handle data from Platinum SEO Pack.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean Ultimate SEO post metadata.
   */
  class WPSEO_Import_Platinum_SEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'Platinum SEO Pack';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = 'title';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => 'description', 'new_key' => 'metadesc'], ['old_key' => 'title', 'new_key' => 'title']];
    /**
     * Runs the import of post meta keys stored by Platinum SEO Pack.
     *
     * @return bool
     */
    protected function import()
    {
    }
    /**
     * Cleans up all the meta values Platinum SEO pack creates.
     *
     * @return bool
     */
    protected function cleanup()
    {
    }
    /**
     * Finds all the robotsmeta fields to import and deals with them.
     *
     * There are four potential values that Platinum SEO stores:
     * - index,folllow
     * - index,nofollow
     * - noindex,follow
     * - noindex,nofollow
     *
     * We only have to deal with the latter 3, the first is our default.
     *
     * @return void
     */
    protected function import_robots_meta()
    {
    }
    /**
     * Imports the values for all index, nofollow posts.
     *
     * @param string $value The meta robots value to find posts for.
     * @param array  $metas The meta field(s) to save.
     *
     * @return void
     */
    protected function import_by_meta_robots($value, $metas)
    {
    }
    /**
     * Finds posts by a given meta robots value.
     *
     * @param string $meta_value Robots meta value.
     *
     * @return array|bool Array of Post IDs on success, false on failure.
     */
    protected function find_posts_by_robots_meta($meta_value)
    {
    }
  }
  /**
   * File with the class to handle data from Squirrly.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean Squirrly post metadata.
   */
  class WPSEO_Import_Squirrly extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'Squirrly SEO';
    /**
     * Holds the name of the table Squirrly uses to store data.
     *
     * @var string
     */
    protected $table_name;
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_sq_post_keyword';
    /**
     * Data to import from (and the target to field) the serialized array stored in the SEO field in the Squirrly table.
     *
     * @var array
     */
    protected $seo_field_keys = ['noindex' => 'meta-robots-noindex', 'nofollow' => 'meta-robots-nofollow', 'title' => 'title', 'description' => 'metadesc', 'canonical' => 'canonical', 'cornerstone' => '_yst_is_cornerstone', 'tw_media' => 'twitter-image', 'tw_title' => 'twitter-title', 'tw_description' => 'twitter-description', 'og_title' => 'opengraph-title', 'og_description' => 'opengraph-description', 'og_media' => 'opengraph-image', 'focuskw' => 'focuskw'];
    /**
     * WPSEO_Import_Squirrly constructor.
     */
    public function __construct()
    {
    }
    /**
     * Imports the post meta values to Yoast SEO.
     *
     * @return bool Import success status.
     */
    protected function import()
    {
    }
    /**
     * Retrieve the posts from the Squirrly Database.
     *
     * @return array Array of post IDs from the DB.
     */
    protected function retrieve_posts()
    {
    }
    /**
     * Returns the query to return an identifier for the posts to import.
     *
     * @return string Query to get post ID's from the DB.
     */
    protected function retrieve_posts_query()
    {
    }
    /**
     * Removes the DB table and the post meta field Squirrly creates.
     *
     * @return bool Cleanup status.
     */
    protected function cleanup()
    {
    }
    /**
     * Detects whether there is post meta data to import.
     *
     * @return bool Boolean indicating whether there is something to import.
     */
    protected function detect()
    {
    }
    /**
     * Imports the data of a post out of Squirrly's DB table.
     *
     * @param mixed $post_identifier Post identifier, can be ID or string.
     *
     * @return bool Import status.
     */
    private function import_post_values($post_identifier)
    {
    }
    /**
     * Retrieves the Squirrly SEO data for a post from the DB.
     *
     * @param int $post_identifier Post ID.
     *
     * @return array|bool Array of data or false.
     */
    private function retrieve_post_data($post_identifier)
    {
    }
    /**
     * Squirrly stores the focus keyword in post meta.
     *
     * @param int $post_id Post ID.
     *
     * @return string The focus keyword.
     */
    private function maybe_add_focus_kw($post_id)
    {
    }
  }
  /**
   * File with the class to handle data from Premium SEO Pack.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean Premium SEO Pack post metadata.
   */
  class WPSEO_Import_Premium_SEO_Pack extends \WPSEO_Import_Squirrly
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'Premium SEO Pack';
    /**
     * WPSEO_Import_Premium_SEO_Pack constructor.
     */
    public function __construct()
    {
    }
    /**
     * Returns the query to return an identifier for the posts to import.
     *
     * @return string
     */
    protected function retrieve_posts_query()
    {
    }
  }
  /**
   * File with the class to handle data from RankMath.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import RankMath post metadata.
   */
  class WPSEO_Import_RankMath extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'RankMath';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = 'rank_math_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => 'rank_math_description', 'new_key' => 'metadesc'], ['old_key' => 'rank_math_title', 'new_key' => 'title'], ['old_key' => 'rank_math_canonical_url', 'new_key' => 'canonical'], ['old_key' => 'rank_math_primary_category', 'new_key' => 'primary_category'], ['old_key' => 'rank_math_facebook_title', 'new_key' => 'opengraph-title'], ['old_key' => 'rank_math_facebook_description', 'new_key' => 'opengraph-description'], ['old_key' => 'rank_math_facebook_image', 'new_key' => 'opengraph-image'], ['old_key' => 'rank_math_facebook_image_id', 'new_key' => 'opengraph-image-id'], ['old_key' => 'rank_math_twitter_title', 'new_key' => 'twitter-title'], ['old_key' => 'rank_math_twitter_description', 'new_key' => 'twitter-description'], ['old_key' => 'rank_math_twitter_image', 'new_key' => 'twitter-image'], ['old_key' => 'rank_math_twitter_image_id', 'new_key' => 'twitter-image-id'], ['old_key' => 'rank_math_focus_keyword', 'new_key' => 'focuskw']];
    /**
     * Handles post meta data to import.
     *
     * @return bool Import success status.
     */
    protected function import()
    {
    }
    /**
     * RankMath stores robots meta quite differently, so we have to parse it out.
     */
    private function import_meta_robots()
    {
    }
    /**
     * Imports some of the RankMath settings.
     */
    private function import_settings()
    {
    }
    /**
     * Removes the plugin data from the database.
     *
     * @return bool Cleanup status.
     */
    protected function cleanup()
    {
    }
  }
  /**
   * File with the class to handle data from SEO Framework.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean SEO Framework post metadata.
   */
  class WPSEO_Import_SEO_Framework extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'SEO Framework';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_genesis_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_genesis_description', 'new_key' => 'metadesc'], ['old_key' => '_genesis_title', 'new_key' => 'title'], ['old_key' => '_genesis_noindex', 'new_key' => 'meta-robots-noindex'], ['old_key' => '_genesis_nofollow', 'new_key' => 'meta-robots-nofollow'], ['old_key' => '_genesis_canonical_uri', 'new_key' => 'canonical'], ['old_key' => '_open_graph_title', 'new_key' => 'opengraph-title'], ['old_key' => '_open_graph_description', 'new_key' => 'opengraph-description'], ['old_key' => '_social_image_url', 'new_key' => 'opengraph-image'], ['old_key' => '_twitter_title', 'new_key' => 'twitter-title'], ['old_key' => '_twitter_description', 'new_key' => 'twitter-description']];
    /**
     * Removes all the metadata set by the SEO Framework plugin.
     *
     * @return bool
     */
    protected function cleanup()
    {
    }
  }
  /**
   * File with the class to handle data from SEOPressor.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Import_SEOPressor.
   *
   * Class with functionality to import & clean SEOPressor post metadata.
   */
  class WPSEO_Import_SEOPressor extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'SEOpressor';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_seop_settings';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_seop_settings']];
    /**
     * Imports the post meta values to Yoast SEO.
     *
     * @return bool Import success status.
     */
    protected function import()
    {
    }
    /**
     * Removes all the post meta fields SEOpressor creates.
     *
     * @return bool Cleanup status.
     */
    protected function cleanup()
    {
    }
    /**
     * Imports the data. SEOpressor stores most of the data in one post array, this loops over it.
     *
     * @param int $post_id Post ID.
     *
     * @return void
     */
    private function import_seopressor_post_settings($post_id)
    {
    }
    /**
     * Imports the focus keywords, and stores them for later use.
     *
     * @param int $post_id Post ID.
     *
     * @return void
     */
    private function import_post_focus_keywords($post_id)
    {
    }
    /**
     * Retrieves the SEOpressor robot value and map this to Yoast SEO values.
     *
     * @param string $meta_rules The meta rules taken from the SEOpressor settings array.
     * @param int    $post_id    The post id of the current post.
     *
     * @return void
     */
    private function import_post_robots($meta_rules, $post_id)
    {
    }
    /**
     * Gets the robot config by given SEOpressor robots value.
     *
     * @param array $seopressor_robots The value in SEOpressor that needs to be converted to the Yoast format.
     *
     * @return array The robots values in Yoast format.
     */
    private function get_robot_value($seopressor_robots)
    {
    }
  }
  /**
   * File with the class to handle data from Smartcrawl SEO.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean Smartcrawl SEO post metadata.
   */
  class WPSEO_Import_Smartcrawl_SEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'Smartcrawl SEO';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_wds_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_wds_metadesc', 'new_key' => 'metadesc'], ['old_key' => '_wds_title', 'new_key' => 'title'], ['old_key' => '_wds_canonical', 'new_key' => 'canonical'], ['old_key' => '_wds_focus-keywords', 'new_key' => 'focuskw'], ['old_key' => '_wds_meta-robots-noindex', 'new_key' => 'meta-robots-noindex'], ['old_key' => '_wds_meta-robots-nofollow', 'new_key' => 'meta-robots-nofollow']];
    /**
     * Used for importing Twitter and Facebook meta's.
     *
     * @var array
     */
    protected $social_keys = [];
    /**
     * Handles post meta data to import.
     *
     * @return bool Import success status.
     */
    protected function import()
    {
    }
    /**
     * Imports the OpenGraph meta keys saved by Smartcrawl.
     *
     * @return bool Import status.
     */
    protected function import_opengraph()
    {
    }
    /**
     * Imports the Twitter meta keys saved by Smartcrawl.
     *
     * @return bool Import status.
     */
    protected function import_twitter()
    {
    }
    /**
     * Imports a post's serialized post meta values.
     *
     * @param int    $post_id Post ID.
     * @param string $key     The meta key to import.
     *
     * @return void
     */
    protected function import_serialized_post_meta($post_id, $key)
    {
    }
    /**
     * Finds all the posts with a certain meta key and imports its values.
     *
     * @param string $key The meta key to search for.
     *
     * @return bool Import status.
     */
    protected function post_find_import($key)
    {
    }
  }
  /**
   * File with the class to handle data from Ultimate SEO.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean Ultimate SEO post metadata.
   */
  class WPSEO_Import_Ultimate_SEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'Ultimate SEO';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_su_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_su_description', 'new_key' => 'metadesc'], ['old_key' => '_su_title', 'new_key' => 'title'], ['old_key' => '_su_og_title', 'new_key' => 'opengraph-title'], ['old_key' => '_su_og_description', 'new_key' => 'opengraph-description'], ['old_key' => '_su_og_image', 'new_key' => 'opengraph-image'], ['old_key' => '_su_meta_robots_noindex', 'new_key' => 'meta-robots-noindex', 'convert' => ['on' => 1]], ['old_key' => '_su_meta_robots_nofollow', 'new_key' => 'meta-robots-nofollow', 'convert' => ['on' => 1]]];
  }
  /**
   * File with the class to handle data from WooThemes SEO.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Import_WooThemes_SEO
   *
   * Class with functionality to import & clean WooThemes SEO post metadata.
   */
  class WPSEO_Import_WooThemes_SEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'WooThemes SEO';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = 'seo_title';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => 'seo_description', 'new_key' => 'metadesc'], ['old_key' => 'seo_title', 'new_key' => 'title'], ['old_key' => 'seo_noindex', 'new_key' => 'meta-robots-noindex'], ['old_key' => 'seo_follow', 'new_key' => 'meta-robots-nofollow']];
    /**
     * Holds the meta fields we can delete after import.
     *
     * @var array
     */
    protected $cleanup_metas = ['seo_follow', 'seo_noindex', 'seo_title', 'seo_description', 'seo_keywords'];
    /**
     * Holds the options we can delete after import.
     *
     * @var array
     */
    protected $cleanup_options = ['seo_woo_archive_layout', 'seo_woo_single_layout', 'seo_woo_page_layout', 'seo_woo_wp_title', 'seo_woo_meta_single_desc', 'seo_woo_meta_single_key', 'seo_woo_home_layout'];
    /**
     * Cleans up the WooThemes SEO settings.
     *
     * @return bool Cleanup status.
     */
    protected function cleanup()
    {
    }
    /**
     * Removes the Woo Options from the database.
     *
     * @return void
     */
    private function cleanup_options()
    {
    }
    /**
     * Removes the post meta fields from the database.
     *
     * @return bool Cleanup status.
     */
    private function cleanup_meta()
    {
    }
    /**
     * Removes a single meta field from the postmeta table in the database.
     *
     * @param string $key The meta_key to delete.
     *
     * @return bool Cleanup status.
     */
    private function cleanup_meta_key($key)
    {
    }
  }
  /**
   * File with the class to handle data from WP Meta SEO.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class with functionality to import & clean WP Meta SEO post metadata.
   */
  class WPSEO_Import_WP_Meta_SEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'WP Meta SEO';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_metaseo_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_metaseo_metadesc', 'new_key' => 'metadesc'], ['old_key' => '_metaseo_metatitle', 'new_key' => 'title'], ['old_key' => '_metaseo_metaopengraph-title', 'new_key' => 'opengraph-title'], ['old_key' => '_metaseo_metaopengraph-desc', 'new_key' => 'opengraph-description'], ['old_key' => '_metaseo_metaopengraph-image', 'new_key' => 'opengraph-image'], ['old_key' => '_metaseo_metatwitter-title', 'new_key' => 'twitter-title'], ['old_key' => '_metaseo_metatwitter-desc', 'new_key' => 'twitter-description'], ['old_key' => '_metaseo_metatwitter-image', 'new_key' => 'twitter-image'], ['old_key' => '_metaseo_metaindex', 'new_key' => 'meta-robots-noindex', 'convert' => ['index' => 0, 'noindex' => 1]], ['old_key' => '_metaseo_metafollow', 'new_key' => 'meta-robots-nofollow', 'convert' => ['follow' => 0, 'nofollow' => 1]]];
  }
  /**
   * File with the class to handle data from wpSEO.de.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Import_WPSEO.
   *
   * Class with functionality to import & clean wpSEO.de post metadata.
   */
  class WPSEO_Import_WPSEO extends \WPSEO_Plugin_Importer
  {
    /**
     * The plugin name.
     *
     * @var string
     */
    protected $plugin_name = 'wpSEO.de';
    /**
     * Meta key, used in SQL LIKE clause for delete query.
     *
     * @var string
     */
    protected $meta_key = '_wpseo_edit_%';
    /**
     * Array of meta keys to detect and import.
     *
     * @var array
     */
    protected $clone_keys = [['old_key' => '_wpseo_edit_description', 'new_key' => 'metadesc'], ['old_key' => '_wpseo_edit_title', 'new_key' => 'title'], ['old_key' => '_wpseo_edit_canonical', 'new_key' => 'canonical'], ['old_key' => '_wpseo_edit_og_title', 'new_key' => 'opengraph-title'], ['old_key' => '_wpseo_edit_og_description', 'new_key' => 'opengraph-description'], ['old_key' => '_wpseo_edit_og_image', 'new_key' => 'opengraph-image'], ['old_key' => '_wpseo_edit_twittercard_title', 'new_key' => 'twitter-title'], ['old_key' => '_wpseo_edit_twittercard_description', 'new_key' => 'twitter-description'], ['old_key' => '_wpseo_edit_twittercard_image', 'new_key' => 'twitter-image']];
    /**
     * The values 1 - 6 are the configured values from wpSEO. This array will map the values of wpSEO to our values.
     *
     * There are some double array like 1-6 and 3-4. The reason is they only set the index value. The follow value is
     * the default we use in the cases there isn't a follow value present.
     *
     * @var array
     */
    private $robot_values = [
      // In wpSEO: index, follow.
      1 => ['index' => 2, 'follow' => 0],
      // In wpSEO: index, nofollow.
      2 => ['index' => 2, 'follow' => 1],
      // In wpSEO: noindex.
      3 => ['index' => 1, 'follow' => 0],
      // In wpSEO: noindex, follow.
      4 => ['index' => 1, 'follow' => 0],
      // In wpSEO: noindex, nofollow.
      5 => ['index' => 1, 'follow' => 1],
      // In wpSEO: index.
      6 => ['index' => 2, 'follow' => 0],
    ];
    /**
     * Imports wpSEO settings.
     *
     * @return bool Import success status.
     */
    protected function import()
    {
    }
    /**
     * Removes wpseo.de post meta's.
     *
     * @return bool Cleanup status.
     */
    protected function cleanup()
    {
    }
    /**
     * Detects whether there is post meta data to import.
     *
     * @return bool Boolean indicating whether there is something to import.
     */
    protected function detect()
    {
    }
    /**
     * Imports the robot values from WPSEO plugin. These have to be converted to the Yoast format.
     *
     * @return void
     */
    private function import_post_robots()
    {
    }
    /**
     * Gets the wpSEO robot value and map this to Yoast SEO values.
     *
     * @param int $post_id The post id of the current post.
     *
     * @return void
     */
    private function import_post_robot($post_id)
    {
    }
    /**
     * Imports the taxonomy metas from wpSEO.
     *
     * @return void
     */
    private function import_taxonomy_metas()
    {
    }
    /**
     * Imports the meta description to Yoast SEO.
     *
     * @param array  $tax_meta The array with the current metadata.
     * @param string $taxonomy String with the name of the taxonomy.
     * @param string $term_id  The ID of the current term.
     *
     * @return void
     */
    private function import_taxonomy_description(&$tax_meta, $taxonomy, $term_id)
    {
    }
    /**
     * Imports the robot value to Yoast SEO.
     *
     * @param array  $tax_meta The array with the current metadata.
     * @param string $taxonomy String with the name of the taxonomy.
     * @param string $term_id  The ID of the current term.
     *
     * @return void
     */
    private function import_taxonomy_robots(&$tax_meta, $taxonomy, $term_id)
    {
    }
    /**
     * Deletes the wpSEO taxonomy meta data.
     *
     * @param string $taxonomy String with the name of the taxonomy.
     * @param string $term_id  The ID of the current term.
     *
     * @return void
     */
    private function delete_taxonomy_metas($taxonomy, $term_id)
    {
    }
    /**
     * Gets the robot config by given wpSEO robots value.
     *
     * @param string $wpseo_robots The value in wpSEO that needs to be converted to the Yoast format.
     *
     * @return string The correct robot value.
     */
    private function get_robot_value($wpseo_robots)
    {
    }
    /**
     * Deletes wpSEO postmeta from the database.
     *
     * @return bool Cleanup status.
     */
    private function cleanup_post_meta()
    {
    }
    /**
     * Cleans up the wpSEO term meta.
     *
     * @return void
     */
    private function cleanup_term_meta()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Import\Plugins
   */
  /**
   * Class WPSEO_Plugin_Importers.
   *
   * Object which contains all importers.
   */
  class WPSEO_Plugin_Importers
  {
    /**
     * List of supported importers.
     *
     * @var array
     */
    private static $importers = ['WPSEO_Import_AIOSEO', 'WPSEO_Import_AIOSEO_V4', 'WPSEO_Import_Greg_SEO', 'WPSEO_Import_HeadSpace', 'WPSEO_Import_Jetpack_SEO', 'WPSEO_Import_WP_Meta_SEO', 'WPSEO_Import_Platinum_SEO', 'WPSEO_Import_Premium_SEO_Pack', 'WPSEO_Import_RankMath', 'WPSEO_Import_SEOPressor', 'WPSEO_Import_SEO_Framework', 'WPSEO_Import_Smartcrawl_SEO', 'WPSEO_Import_Squirrly', 'WPSEO_Import_Ultimate_SEO', 'WPSEO_Import_WooThemes_SEO', 'WPSEO_Import_WPSEO'];
    /**
     * Returns an array of importers available.
     *
     * @return array Available importers.
     */
    public static function get()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Interface that represents a collection.
   */
  interface WPSEO_Collection
  {
    /**
     * Returns the collection data.
     *
     * @return array The collection data.
     */
    public function get();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Represents the interface for an installable object.
   */
  interface WPSEO_Installable
  {
    /**
     * Runs the installation routine.
     *
     * @return void
     */
    public function install();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Listeners
   */
  /**
   * Dictates the required methods for a Listener implementation.
   */
  interface WPSEO_Listener
  {
    /**
     * Listens to an argument in the request URL and triggers an action.
     *
     * @return void
     */
    public function listen();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Menu
   */
  /**
   * Admin menu base class.
   */
  abstract class WPSEO_Base_Menu implements \WPSEO_WordPress_Integration
  {
    /**
     * A menu.
     *
     * @var WPSEO_Menu
     */
    protected $menu;
    /**
     * Constructs the Admin Menu.
     *
     * @param WPSEO_Menu $menu Menu to use.
     */
    public function __construct(\WPSEO_Menu $menu)
    {
    }
    /**
     * Returns the list of registered submenu pages.
     *
     * @return array List of registered submenu pages.
     */
    public abstract function get_submenu_pages();
    /**
     * Creates a submenu formatted array.
     *
     * @param string          $page_title Page title to use.
     * @param string          $page_slug  Page slug to use.
     * @param callable|null   $callback   Optional. Callback which handles the page request.
     * @param callable[]|null $hook       Optional. Hook to trigger when the page is registered.
     *
     * @return array Formatted submenu.
     */
    protected function get_submenu_page($page_title, $page_slug, $callback = \null, $hook = \null)
    {
    }
    /**
     * Registers submenu pages as menu pages.
     *
     * This method should only be used if the user does not have the required capabilities
     * to access the parent menu page.
     *
     * @param array $submenu_pages List of submenu pages to register.
     *
     * @return void
     */
    protected function register_menu_pages($submenu_pages)
    {
    }
    /**
     * Registers submenu pages.
     *
     * @param array $submenu_pages List of submenu pages to register.
     *
     * @return void
     */
    protected function register_submenu_pages($submenu_pages)
    {
    }
    /**
     * Registers a submenu page as a menu page.
     *
     * This method should only be used if the user does not have the required capabilities
     * to access the parent menu page.
     *
     * @param array $submenu_page {
     *     Submenu page definition.
     *
     *     @type string   $0 Parent menu page slug.
     *     @type string   $1 Page title, currently unused.
     *     @type string   $2 Title to display in the menu.
     *     @type string   $3 Required capability to access the page.
     *     @type string   $4 Page slug.
     *     @type callable $5 Callback to run when the page is rendered.
     *     @type array    $6 Optional. List of callbacks to run when the page is loaded.
     * }
     *
     * @return void
     */
    protected function register_menu_page($submenu_page)
    {
    }
    /**
     * Registers a submenu page.
     *
     * This method will override the capability of the page to automatically use the
     * general manage capability. Use the `register_menu_page()` method if the submenu
     * page should actually use a different capability.
     *
     * @param array $submenu_page {
     *     Submenu page definition.
     *
     *     @type string   $0 Parent menu page slug.
     *     @type string   $1 Page title, currently unused.
     *     @type string   $2 Title to display in the menu.
     *     @type string   $3 Required capability to access the page.
     *     @type string   $4 Page slug.
     *     @type callable $5 Callback to run when the page is rendered.
     *     @type array    $6 Optional. List of callbacks to run when the page is loaded.
     * }
     *
     * @return void
     */
    protected function register_submenu_page($submenu_page)
    {
    }
    /**
     * Adds hook callbacks for a given admin page hook suffix.
     *
     * @param string $hook_suffix Admin page hook suffix, as returned by `add_menu_page()`
     *                            or `add_submenu_page()`.
     * @param array  $callbacks   Callbacks to add.
     *
     * @return void
     */
    protected function add_page_hooks($hook_suffix, array $callbacks)
    {
    }
    /**
     * Gets the main admin page identifier.
     *
     * @return string Admin page identifier.
     */
    protected function get_page_identifier()
    {
    }
    /**
     * Checks whether the current user has capabilities to manage all options.
     *
     * @return bool True if capabilities are sufficient, false otherwise.
     */
    protected function check_manage_capability()
    {
    }
    /**
     * Returns the capability that is required to manage all options.
     *
     * @return string Capability to check against.
     */
    protected abstract function get_manage_capability();
    /**
     * Returns the page handler callback.
     *
     * @return array Callback page handler.
     */
    protected function get_admin_page_callback()
    {
    }
    /**
     * Returns the page title to use for the licenses page.
     *
     * @return string The title for the license page.
     */
    protected function get_license_page_title()
    {
    }
    /**
     * Returns a base64 URL for the svg for use in the menu.
     *
     * @param bool $base64 Whether or not to return base64'd output.
     *
     * @return string SVG icon.
     */
    public function get_icon_svg($base64 = \true)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Menu
   */
  /**
   * Registers the admin menu on the left of the admin area.
   */
  class WPSEO_Admin_Menu extends \WPSEO_Base_Menu
  {
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the menu item submenus.
     */
    public function register_settings_page()
    {
    }
    /**
     * Returns the list of registered submenu pages.
     *
     * @return array List of registered submenu pages.
     */
    public function get_submenu_pages()
    {
    }
    /**
     * Returns the notification count in HTML format.
     *
     * @return string The notification count in HTML format.
     */
    protected function get_notification_counter()
    {
    }
    /**
     * Returns the capability that is required to manage all options.
     *
     * @return string Capability to check against.
     */
    protected function get_manage_capability()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Menu
   */
  /**
   * Registers the regular admin menu and network admin menu implementations.
   */
  class WPSEO_Menu implements \WPSEO_WordPress_Integration
  {
    /**
     * The page identifier used in WordPress to register the admin page.
     *
     * !DO NOT CHANGE THIS!
     *
     * @var string
     */
    const PAGE_IDENTIFIER = 'wpseo_dashboard';
    /**
     * List of classes that add admin functionality.
     *
     * @var array
     */
    protected $admin_features;
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the main menu page identifier.
     *
     * @return string Page identifier to use.
     */
    public function get_page_identifier()
    {
    }
    /**
     * Loads the requested admin settings page.
     *
     * @return void
     */
    public function load_page()
    {
    }
    /**
     * Shows an admin settings page.
     *
     * @param string $page Page to display.
     *
     * @return void
     */
    protected function show_page($page)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Menu
   */
  /**
   * Network Admin Menu handler.
   */
  class WPSEO_Network_Admin_Menu extends \WPSEO_Base_Menu
  {
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Register the settings page for the Network settings.
     *
     * @return void
     */
    public function register_settings_page()
    {
    }
    /**
     * Returns the list of registered submenu pages.
     *
     * @return array List of registered submenu pages.
     */
    public function get_submenu_pages()
    {
    }
    /**
     * Loads the form for the network configuration page.
     *
     * @return void
     */
    public function network_config_page()
    {
    }
    /**
     * Checks whether the current user has capabilities to manage all options.
     *
     * @return bool True if capabilities are sufficient, false otherwise.
     */
    protected function check_manage_capability()
    {
    }
    /**
     * Returns the capability that is required to manage all options.
     *
     * @return string Capability to check against.
     */
    protected function get_manage_capability()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Menu
   */
  /**
   * Renders a replacement variable editor.
   */
  class WPSEO_Replacevar_Editor
  {
    /**
     * Yoast Forms instance.
     *
     * @var Yoast_Form
     */
    private $yform;
    /**
     * The arguments required for the div to render.
     *
     * @var array {
     *      @type string $title                   The title field id.
     *      @type string $description             The description field id.
     *      @type string $page_type_recommended   The page type for the context of the recommended replace vars.
     *      @type string $page_type_specific      The page type for the context of the editor specific replace vars.
     *      @type bool   $paper_style             Optional. Whether the editor has paper style.
     *      @type string $label_title             Optional. The label to use for the title field.
     *      @type string $label_description       Optional. The label to use for the description field.
     *      @type string $description_placeholder Optional. The placeholder text to use for the description field.
     *      @type bool   $has_new_badge           Optional. Whether to show the "New" badge.
     *      @type bool   $has_premium_badge       Optional. Whether to show the "Premium" badge.
     * }
     */
    private $arguments;
    /**
     * Constructs the object.
     *
     * @param Yoast_Form $yform     Yoast forms.
     * @param array      $arguments {
     *      The arguments that can be given.
     *
     *      @type string $title                   The title field id.
     *      @type string $description             The description field id.
     *      @type string $page_type_recommended   The page type for the context of the recommended replace vars.
     *      @type string $page_type_specific      The page type for the context of the editor specific replace vars.
     *      @type bool   $paper_style             Optional. Whether the editor has paper style.
     *      @type string $label_title             Optional. The label to use for the title field.
     *      @type string $label_description       Optional. The label to use for the description field.
     *      @type string $description_placeholder Optional. The placeholder text to use for the description field.
     *      @type bool   $has_new_badge           Optional. Whether to show the "New" badge.
     *      @type bool   $has_premium_badge       Optional. Whether to show the "Premium" badge.
     * }
     */
    public function __construct(\Yoast_Form $yform, $arguments)
    {
    }
    /**
     * Renders a div for the react application to mount to, and hidden inputs where
     * the app should store it's value so they will be properly saved when the form
     * is submitted.
     *
     * @return void
     */
    public function render()
    {
    }
    /**
     * Validates the replacement variable editor arguments.
     *
     * @param array $arguments The arguments to validate.
     *
     * @throws InvalidArgumentException Thrown when not all required arguments are present.
     */
    protected function validate_arguments(array $arguments)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Menu
   */
  /**
   * Renders a single replacement variable field.
   */
  class WPSEO_Replacevar_Field
  {
    /**
     * Forms instance.
     *
     * @var Yoast_Form Yoast
     */
    private $yform;
    /**
     * The id for the hidden field.
     *
     * @var string
     */
    private $field_id;
    /**
     * The label for the field.
     *
     * @var string
     */
    private $label;
    /**
     * The page type for the context of the recommended replace vars.
     *
     * @var string
     */
    private $page_type_recommended;
    /**
     * The page type for the context of the editor specific replace vars.
     *
     * @var string
     */
    private $page_type_specific;
    /**
     * Constructs the object.
     *
     * @param Yoast_Form $yform                 Yoast forms.
     * @param string     $field_id              The field id.
     * @param string     $label                 The field label.
     * @param string     $page_type_recommended The page type for the context of the recommended replace vars.
     * @param string     $page_type_specific    The page type for the context of the editor specific replace vars.
     */
    public function __construct(\Yoast_Form $yform, $field_id, $label, $page_type_recommended, $page_type_specific)
    {
    }
    /**
     * Renders a div for the react application to mount to, and hidden inputs where
     * the app should store it's value so they will be properly saved when the form
     * is submitted.
     *
     * @return void
     */
    public function render()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Menu
   */
  /**
   * Normalize submenu capabilities to `wpseo_manage_options`.
   */
  class WPSEO_Submenu_Capability_Normalize implements \WPSEO_WordPress_Integration
  {
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Normalizes any `manage_options` to `wpseo_manage_options`.
     *
     * This is needed as the module plugins are not updated with the new capabilities directly,
     * but they should not be shown as main menu items.
     *
     * @param array $submenu_pages List of subpages to convert.
     *
     * @return array Converted subpages.
     */
    public function normalize_submenus_capability($submenu_pages)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates and displays the HTML for a metabox section.
   */
  interface WPSEO_Metabox_Section
  {
    /**
     * Outputs the section link.
     */
    public function display_link();
    /**
     * Outputs the section content.
     */
    public function display_content();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Base class for metabox that consist of multiple sections.
   */
  abstract class WPSEO_Abstract_Metabox_Tab_With_Sections implements \WPSEO_Metabox_Section
  {
    /**
     * Holds the name of the tab.
     *
     * @var string
     */
    public $name;
    /**
     * Holds the HTML of the tab header.
     *
     * @var string
     */
    protected $link_content;
    /**
     * Holds the name of the tab header.
     *
     * @var string
     */
    protected $link_title;
    /**
     * Holds the classname of the tab header.
     *
     * @var string
     */
    protected $link_class;
    /**
     * Holds the aria label of the tab header.
     *
     * @var string
     */
    protected $link_aria_label;
    /**
     * Constructor.
     *
     * @param string $name         The name of the section, used as an identifier in the html.
     *                             Can only contain URL safe characters.
     * @param string $link_content The text content of the section link.
     * @param array  $options      Optional link attributes.
     */
    public function __construct($name, $link_content, array $options = [])
    {
    }
    /**
     * Outputs the section link if any section has been added.
     */
    public function display_link()
    {
    }
    /**
     * Checks whether the tab has any sections.
     *
     * @return bool Whether the tab has any sections
     */
    protected abstract function has_sections();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Metabox
   */
  /**
   * Describes an interface for an analysis that can either be enabled or disabled.
   */
  interface WPSEO_Metabox_Analysis
  {
    /**
     * Whether this analysis is enabled.
     *
     * @return bool Whether or not this analysis is enabled.
     */
    public function is_enabled();
    /**
     * Whether or not this analysis is enabled by the user.
     *
     * @return bool Whether or not this analysis is enabled by the user.
     */
    public function is_user_enabled();
    /**
     * Whether or not this analysis is enabled globally.
     *
     * @return bool Whether or not this analysis is enabled globally.
     */
    public function is_globally_enabled();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Metabox
   */
  /**
   * Represents the inclusive language analysis.
   */
  class WPSEO_Metabox_Analysis_Inclusive_Language implements \WPSEO_Metabox_Analysis
  {
    /**
     * Whether this analysis is enabled.
     *
     * @return bool Whether or not this analysis is enabled.
     */
    public function is_enabled()
    {
    }
    /**
     * Whether or not this analysis is enabled by the user.
     *
     * @return bool Whether or not this analysis is enabled by the user.
     */
    public function is_user_enabled()
    {
    }
    /**
     * Whether or not this analysis is enabled globally.
     *
     * @return bool Whether or not this analysis is enabled globally.
     */
    public function is_globally_enabled()
    {
    }
    /**
     * Whether the inclusive language analysis should be loaded in Free.
     *
     * It should always be loaded when Premium is not active. If Premium is active, it depends on the version. Some Premium
     * versions also have inclusive language code (when it was still a Premium only feature) which would result in rendering
     * the analysis twice. In those cases, the analysis should be only loaded from the Premium side.
     *
     * @return bool Whether or not the inclusive language analysis should be loaded.
     */
    private function is_current_version_supported()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Metabox
   */
  /**
   * Represents the readability analysis.
   */
  class WPSEO_Metabox_Analysis_Readability implements \WPSEO_Metabox_Analysis
  {
    /**
     * Whether this analysis is enabled.
     *
     * @return bool Whether or not this analysis is enabled.
     */
    public function is_enabled()
    {
    }
    /**
     * Whether or not this analysis is enabled by the user.
     *
     * @return bool Whether or not this analysis is enabled by the user.
     */
    public function is_user_enabled()
    {
    }
    /**
     * Whether or not this analysis is enabled globally.
     *
     * @return bool Whether or not this analysis is enabled globally.
     */
    public function is_globally_enabled()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Metabox
   */
  /**
   * Represents the SEO analysis.
   */
  class WPSEO_Metabox_Analysis_SEO implements \WPSEO_Metabox_Analysis
  {
    /**
     * Whether this analysis is enabled.
     *
     * @return bool Whether or not this analysis is enabled.
     */
    public function is_enabled()
    {
    }
    /**
     * Whether or not this analysis is enabled by the user.
     *
     * @return bool Whether or not this analysis is enabled by the user.
     */
    public function is_user_enabled()
    {
    }
    /**
     * Whether or not this analysis is enabled globally.
     *
     * @return bool Whether or not this analysis is enabled globally.
     */
    public function is_globally_enabled()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates the HTML for a metabox tab.
   */
  interface WPSEO_Metabox_Tab
  {
    /**
     * Returns the html for the tab link.
     *
     * @return string
     */
    public function link();
    /**
     * Returns the html for the tab content.
     *
     * @return string
     */
    public function content();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates the HTML for a metabox tab.
   */
  class WPSEO_Metabox_Collapsible implements \WPSEO_Metabox_Tab
  {
    /**
     * The collapsible's unique identifier.
     *
     * @var string
     */
    private $name;
    /**
     * The content to be displayed inside the collapsible.
     *
     * @var string
     */
    private $content;
    /**
     * The label.
     *
     * @var string
     */
    private $link_content;
    /**
     * Constructor.
     *
     * @param string $name         The name of the tab, used as an identifier in the html.
     * @param string $content      The tab content.
     * @param string $link_content The text content of the tab link.
     */
    public function __construct($name, $content, $link_content)
    {
    }
    /**
     * Returns the html for the tab link.
     *
     * @return string
     */
    public function link()
    {
    }
    /**
     * Returns the html for the tab content.
     *
     * @return string
     */
    public function content()
    {
    }
    /**
     * Returns the collapsible's unique identifier.
     *
     * @return string
     */
    public function get_name()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates and displays a metabox tab that consists of collapsible sections.
   */
  class WPSEO_Metabox_Collapsibles_Sections extends \WPSEO_Abstract_Metabox_Tab_With_Sections
  {
    /**
     * Holds the tab's collapsibles.
     *
     * @var WPSEO_Metabox_Collapsible[]
     */
    private $collapsibles = [];
    /**
     * Constructor.
     *
     * @param string $name         The name of the section, used as an identifier in the html.
     *                             Can only contain URL safe characters.
     * @param string $link_content The text content of the section link.
     * @param array  $collapsibles The metabox collapsibles (`WPSEO_Metabox_Collapsible[]`) to be included in the section.
     * @param array  $options      Optional link attributes.
     */
    public function __construct($name, $link_content, array $collapsibles = [], array $options = [])
    {
    }
    /**
     * Outputs the section content if any tab has been added.
     */
    public function display_content()
    {
    }
    /**
     * Checks whether the tab has any sections.
     *
     * @return bool Whether the tab has any sections
     */
    protected function has_sections()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Metabox
   */
  /**
   * Handles all things with the metabox in combination with the WordPress editor.
   */
  class WPSEO_Metabox_Editor
  {
    /**
     * Registers hooks to WordPress.
     *
     * @codeCoverageIgnore
     */
    public function register_hooks()
    {
    }
    /**
     * Adds our inside the editor CSS file to the list of CSS files to be loaded inside the editor.
     *
     * @param string $css_files The CSS files that WordPress wants to load inside the editor.
     * @return string The CSS files WordPress wants to load and our CSS file.
     */
    public function add_css_inside_editor($css_files)
    {
    }
    /**
     * Enqueues the CSS to use in the TinyMCE editor.
     */
    public function add_editor_styles()
    {
    }
    /**
     * Adds a custom element to the tinyMCE editor that we need for marking the content.
     *
     * @param array $tinymce_config The tinyMCE config as configured by WordPress.
     *
     * @return array The new tinyMCE config with our added custom elements.
     */
    public function add_custom_element($tinymce_config)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates the HTML for a metabox tab.
   */
  class WPSEO_Metabox_Form_Tab implements \WPSEO_Metabox_Tab
  {
    /**
     * The tab identifier.
     *
     * @var string
     */
    private $name;
    /**
     * The tab content.
     *
     * @var string
     */
    private $content;
    /**
     * The tab link content.
     *
     * @var string
     */
    private $link_content;
    /**
     * Additional tab content class.
     *
     * @var string
     */
    private $tab_class;
    /**
     * Additional tab link class.
     *
     * @var string
     */
    private $link_class;
    /**
     * Title attribute on the link span.
     *
     * @var string
     */
    private $link_title;
    /**
     * Arial label attribute on the link span.
     *
     * @var string
     */
    private $link_aria_label;
    /**
     * Does it contain a single tab.
     *
     * @var bool
     */
    private $single;
    /**
     * Constructor.
     *
     * @param string $name         The name of the tab, used as an identifier in the html.
     * @param string $content      The tab content.
     * @param string $link_content The text content of the tab link.
     * @param array  $options      Optional link attributes.
     */
    public function __construct($name, $content, $link_content, array $options = [])
    {
    }
    /**
     * Returns the html for the tab link.
     *
     * @return string
     */
    public function link()
    {
    }
    /**
     * Returns the html for the tab content.
     *
     * @return string
     */
    public function content()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates the HTML for a metabox tab.
   */
  class WPSEO_Metabox_Null_Tab implements \WPSEO_Metabox_Tab
  {
    /**
     * Returns the html for the tab link.
     *
     * @return string|null
     */
    public function link()
    {
    }
    /**
     * Returns the html for the tab content.
     *
     * @return string|null
     */
    public function content()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Metabox
   */
  /**
   * Generates and displays an additional metabox section.
   */
  class WPSEO_Metabox_Section_Additional implements \WPSEO_Metabox_Section
  {
    /**
     * Name of the section, used as an identifier in the HTML.
     *
     * @var string
     */
    public $name;
    /**
     * Content of the tab's section.
     *
     * @var string
     */
    public $content;
    /**
     * HTML to use in the tab header.
     *
     * @var string
     */
    private $link_content;
    /**
     * Class to add to the link.
     *
     * @var string
     */
    private $link_class;
    /**
     * Aria label to use for the link.
     *
     * @var string
     */
    private $link_aria_label;
    /**
     * Represents the content class.
     *
     * @var string
     */
    private $content_class;
    /**
     * Constructor.
     *
     * @param string $name         The name of the section, used as an identifier in the html.
     *                             Can only contain URL safe characters.
     * @param string $link_content The text content of the section link.
     * @param string $content      Optional. Content to use above the React root element.
     * @param array  $options      Optional link attributes.
     */
    public function __construct($name, $link_content, $content = '', array $options = [])
    {
    }
    /**
     * Outputs the section link.
     *
     * @return void
     */
    public function display_link()
    {
    }
    /**
     * Outputs the section content.
     *
     * @return void
     */
    public function display_content()
    {
    }
  }
  /**
   * Generates and displays the React root element for a metabox section.
   */
  class WPSEO_Metabox_Section_Inclusive_Language implements \WPSEO_Metabox_Section
  {
    /**
     * Name of the section, used as an identifier in the HTML.
     *
     * @var string
     */
    public $name = 'inclusive-language';
    /**
     * Outputs the section link.
     */
    public function display_link()
    {
    }
    /**
     * Outputs the section content.
     */
    public function display_content()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates and displays the React root element for a metabox section.
   */
  class WPSEO_Metabox_Section_React implements \WPSEO_Metabox_Section
  {
    /**
     * Name of the section, used as an identifier in the HTML.
     *
     * @var string
     */
    public $name;
    /**
     * Content to use before the React root node.
     *
     * @var string
     */
    public $content;
    /**
     * Content to use to display the button to open this content block.
     *
     * @var string
     */
    private $link_content;
    /**
     * Class to add to the link.
     *
     * @var string
     */
    private $link_class;
    /**
     * Aria label to use for the link.
     *
     * @var string
     */
    private $link_aria_label;
    /**
     * Additional html content to be displayed within the section.
     *
     * @var string
     */
    private $html_after;
    /**
     * Constructor.
     *
     * @param string $name         The name of the section, used as an identifier in the html.
     *                             Can only contain URL safe characters.
     * @param string $link_content The text content of the section link.
     * @param string $content      Optional. Content to use above the React root element.
     * @param array  $options      Optional link attributes.
     */
    public function __construct($name, $link_content, $content = '', array $options = [])
    {
    }
    /**
     * Outputs the section link.
     *
     * @return void
     */
    public function display_link()
    {
    }
    /**
     * Outputs the section content.
     *
     * @return void
     */
    public function display_content()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generates and displays the React root element for a metabox section.
   */
  class WPSEO_Metabox_Section_Readability implements \WPSEO_Metabox_Section
  {
    /**
     * Name of the section, used as an identifier in the HTML.
     *
     * @var string
     */
    public $name = 'readability';
    /**
     * Outputs the section link.
     */
    public function display_link()
    {
    }
    /**
     * Outputs the section content.
     */
    public function display_content()
    {
    }
  }
  /**
   * This class implements defaults and value validation for all WPSEO Post Meta values.
   *
   * Some guidelines:
   * - To update a meta value, you can just use update_post_meta() with the full (prefixed) meta key
   *   or the convenience method WPSEO_Meta::set_value() with the internal key.
   *   All updates will be automatically validated.
   *   Meta values will only be saved to the database if they are *not* the same as the default to
   *   keep database load low.
   * - To retrieve a WPSEO meta value, you **must** use WPSEO_Meta::get_value() which will always return a
   *   string value, either the saved value or the default.
   *   This method can also retrieve a complete set of WPSEO meta values for one specific post, see
   *   the method documentation for the parameters.
   *
   * {@internal Unfortunately there isn't a filter available to hook into before returning the results
   *            for get_post_meta(), get_post_custom() and the likes. That would have been the
   *            preferred solution.}}
   *
   * {@internal All WP native get_meta() results get cached internally, so no need to cache locally.}}
   * {@internal Use $key when the key is the WPSEO internal name (without prefix), $meta_key when it
   *            includes the prefix.}}
   */
  class WPSEO_Meta
  {
    /**
     * Prefix for all WPSEO meta values in the database.
     *
     * {@internal If at any point this would change, quite apart from an upgrade routine,
     *            this also will need to be changed in the wpml-config.xml file.}}
     *
     * @var string
     */
    public static $meta_prefix = '_yoast_wpseo_';
    /**
     * Prefix for all WPSEO meta value form field names and ids.
     *
     * @var string
     */
    public static $form_prefix = 'yoast_wpseo_';
    /**
     * Allowed length of the meta description.
     *
     * @var int
     */
    public static $meta_length = 156;
    /**
     * Reason the meta description is not the default length.
     *
     * @var string
     */
    public static $meta_length_reason = '';
    /**
     * Meta box field definitions for the meta box form.
     *
     * {@internal
     * - Titles, help texts, description text and option labels are added via a translate_meta_boxes() method
     *   in the relevant child classes (WPSEO_Metabox and WPSEO_Social_admin) as they are only needed there.
     * - Beware: even though the meta keys are divided into subsets, they still have to be uniquely named!}}
     *
     * @var array
     *            Array format:
     *                (required)       'type'          => (string) field type. i.e. text / textarea / checkbox /
     *                                                    radio / select / multiselect / upload etc.
     *                (required)       'title'         => (string) table row title.
     *                (recommended)    'default_value' => (string|array) default value for the field.
     *                                                    IMPORTANT:
     *                                                    - if the field has options, the default has to be the
     *                                                      key of one of the options.
     *                                                    - if the field is a text field, the default **has** to be
     *                                                      an empty string as otherwise the user can't save
     *                                                      an empty value/delete the meta value.
     *                                                    - if the field is a checkbox, the only valid values
     *                                                      are 'on' or 'off'.
     *                (semi-required)   'options'      => (array) options for used with (multi-)select and radio
     *                                                    fields, required if that's the field type.
     *                                                    key = (string) value which will be saved to db.
     *                                                    value = (string) text label for the option.
     *                (optional)        'autocomplete' => (bool) whether autocomplete is on for text fields,
     *                                                    defaults to true.
     *                (optional)        'class'        => (string) classname(s) to add to the actual <input> tag.
     *                (optional)        'description'  => (string) description to show underneath the field.
     *                (optional)        'expl'         => (string) label for a checkbox.
     *                (optional)        'help'         => (string) help text to show on mouse over ? image.
     *                (optional)        'rows'         => (int) number of rows for a textarea, defaults to 3.
     *                (optional)        'placeholder'  => (string) Currently only used by add-on plugins.
     *                (optional)        'serialized'   => (bool) whether the value is expected to be serialized,
     *                                                     i.e. an array or object, defaults to false.
     *                                                     Currently only used by add-on plugins.
     */
    public static $meta_fields = [
      'general' => ['focuskw' => ['type' => 'hidden', 'title' => ''], 'title' => [
        'type' => 'hidden',
        'title' => '',
        // Translation added later.
        'default_value' => '',
        'description' => '',
        // Translation added later.
        'help' => '',
      ], 'metadesc' => [
        'type' => 'hidden',
        'title' => '',
        // Translation added later.
        'default_value' => '',
        'class' => 'metadesc',
        'rows' => 2,
        'description' => '',
        // Translation added later.
        'help' => '',
      ], 'linkdex' => ['type' => 'hidden', 'title' => 'linkdex', 'default_value' => '0', 'description' => ''], 'content_score' => ['type' => 'hidden', 'title' => 'content_score', 'default_value' => '0', 'description' => ''], 'inclusive_language_score' => ['type' => 'hidden', 'title' => 'inclusive_language_score', 'default_value' => '0', 'description' => ''], 'is_cornerstone' => ['type' => 'hidden', 'title' => 'is_cornerstone', 'default_value' => 'false', 'description' => '']],
      'advanced' => ['meta-robots-noindex' => [
        'type' => 'hidden',
        'title' => '',
        // Translation added later.
        'default_value' => '0',
        // = post-type default.
        'options' => [
          '0' => '',
          // Post type default - translation added later.
          '2' => '',
          // Index - translation added later.
          '1' => '',
        ],
      ], 'meta-robots-nofollow' => [
        'type' => 'hidden',
        'title' => '',
        // Translation added later.
        'default_value' => '0',
        // = follow.
        'options' => [
          '0' => '',
          // Follow - translation added later.
          '1' => '',
        ],
      ], 'meta-robots-adv' => [
        'type' => 'hidden',
        'title' => '',
        // Translation added later.
        'default_value' => '',
        'description' => '',
        // Translation added later.
        'options' => [
          'noimageindex' => '',
          // Translation added later.
          'noarchive' => '',
          // Translation added later.
          'nosnippet' => '',
        ],
      ], 'bctitle' => [
        'type' => 'hidden',
        'title' => '',
        // Translation added later.
        'default_value' => '',
        'description' => '',
      ], 'canonical' => [
        'type' => 'hidden',
        'title' => '',
        // Translation added later.
        'default_value' => '',
        'description' => '',
      ], 'redirect' => [
        'type' => 'url',
        'title' => '',
        // Translation added later.
        'default_value' => '',
        'description' => '',
      ]],
      'social' => [],
      'schema' => ['schema_page_type' => ['type' => 'hidden', 'title' => '', 'options' => \Yoast\WP\SEO\Config\Schema_Types::PAGE_TYPES], 'schema_article_type' => ['type' => 'hidden', 'title' => '', 'hide_on_pages' => \true, 'options' => \Yoast\WP\SEO\Config\Schema_Types::ARTICLE_TYPES]],
      /* Fields we should validate & save, but not show on any form. */
      'non_form' => ['linkdex' => ['type' => \null, 'default_value' => '0'], 'zapier_trigger_sent' => ['type' => \null, 'default_value' => '0']],
    ];
    /**
     * Helper property - reverse index of the definition array.
     *
     * Format: [full meta key including prefix]    => array
     *         ['subset']    => (string) primary index
     *         ['key']       => (string) internal key
     *
     * @var array
     */
    public static $fields_index = [];
    /**
     * Helper property - array containing only the defaults in the format:
     * [full meta key including prefix]    => (string) default value
     *
     * @var array
     */
    public static $defaults = [];
    /**
     * Helper property to define the social network meta field definitions - networks.
     *
     * @var array
     */
    private static $social_networks = ['opengraph' => 'opengraph', 'twitter' => 'twitter'];
    /**
     * Helper property to define the social network meta field definitions - fields and their type.
     *
     * @var array
     */
    private static $social_fields = ['title' => 'hidden', 'description' => 'hidden', 'image' => 'hidden', 'image-id' => 'hidden'];
    /**
     * Register our actions and filters.
     *
     * @return void
     */
    public static function init()
    {
    }
    /**
     * Retrieve the meta box form field definitions for the given tab and post type.
     *
     * @param string $tab       Tab for which to retrieve the field definitions.
     * @param string $post_type Post type of the current post.
     *
     * @return array Array containing the meta box field definitions.
     */
    public static function get_meta_field_defs($tab, $post_type = 'post')
    {
    }
    /**
     * Validate the post meta values.
     *
     * @param mixed  $meta_value The new value.
     * @param string $meta_key   The full meta key (including prefix).
     *
     * @return string Validated meta value.
     */
    public static function sanitize_post_meta($meta_value, $meta_key)
    {
    }
    /**
     * Validate a meta-robots-adv meta value.
     *
     * @todo [JRF => Yoast] Verify that this logic for the prioritisation is correct.
     *
     * @param array|string $meta_value The value to validate.
     *
     * @return string Clean value.
     */
    public static function validate_meta_robots_adv($meta_value)
    {
    }
    /**
     * Prevent saving of default values and remove potential old value from the database if replaced by a default.
     *
     * @param bool   $check      The current status to allow updating metadata for the given type.
     * @param int    $object_id  ID of the current object for which the meta is being updated.
     * @param string $meta_key   The full meta key (including prefix).
     * @param string $meta_value New meta value.
     * @param string $prev_value The old meta value.
     *
     * @return bool|null True = stop saving, null = continue saving.
     */
    public static function remove_meta_if_default($check, $object_id, $meta_key, $meta_value, $prev_value = '')
    {
    }
    /**
     * Prevent adding of default values to the database.
     *
     * @param bool   $check      The current status to allow adding metadata for the given type.
     * @param int    $object_id  ID of the current object for which the meta is being added.
     * @param string $meta_key   The full meta key (including prefix).
     * @param string $meta_value New meta value.
     *
     * @return bool|null True = stop saving, null = continue saving.
     */
    public static function dont_save_meta_if_default($check, $object_id, $meta_key, $meta_value)
    {
    }
    /**
     * Is the given meta value the same as the default value ?
     *
     * @param string $meta_key   The full meta key (including prefix).
     * @param mixed  $meta_value The value to check.
     *
     * @return bool
     */
    public static function meta_value_is_default($meta_key, $meta_value)
    {
    }
    /**
     * Get a custom post meta value.
     *
     * Returns the default value if the meta value has not been set.
     *
     * {@internal Unfortunately there isn't a filter available to hook into before returning
     *            the results for get_post_meta(), get_post_custom() and the likes. That
     *            would have been the preferred solution.}}
     *
     * @param string $key    Internal key of the value to get (without prefix).
     * @param int    $postid Post ID of the post to get the value for.
     *
     * @return string All 'normal' values returned from get_post_meta() are strings.
     *                Objects and arrays are possible, but not used by this plugin
     *                and therefore discarted (except when the special 'serialized' field def
     *                value is set to true - only used by add-on plugins for now).
     *                Will return the default value if no value was found.
     *                Will return empty string if no default was found (not one of our keys) or
     *                if the post does not exist.
     */
    public static function get_value($key, $postid = 0)
    {
    }
    /**
     * Update a meta value for a post.
     *
     * @param string $key        The internal key of the meta value to change (without prefix).
     * @param mixed  $meta_value The value to set the meta to.
     * @param int    $post_id    The ID of the post to change the meta for.
     *
     * @return bool Whether the value was changed.
     */
    public static function set_value($key, $meta_value, $post_id)
    {
    }
    /**
     * Deletes a meta value for a post.
     *
     * @param string $key     The internal key of the meta value to change (without prefix).
     * @param int    $post_id The ID of the post to delete the meta for.
     *
     * @return bool Whether the delete was successful or not.
     */
    public static function delete($key, $post_id)
    {
    }
    /**
     * Used for imports, this functions imports the value of $old_metakey into $new_metakey for those post
     * where no WPSEO meta data has been set.
     * Optionally deletes the $old_metakey values.
     *
     * @param string $old_metakey The old key of the meta value.
     * @param string $new_metakey The new key, usually the WPSEO meta key (including prefix).
     * @param bool   $delete_old  Whether to delete the old meta key/value-sets.
     *
     * @return void
     */
    public static function replace_meta($old_metakey, $new_metakey, $delete_old = \false)
    {
    }
    /**
     * General clean-up of the saved meta values.
     * - Remove potentially lingering old meta keys;
     * - Remove all default and invalid values.
     *
     * @return void
     */
    public static function clean_up()
    {
    }
    /**
     * Recursively merge a variable number of arrays, using the left array as base,
     * giving priority to the right array.
     *
     * Difference with native array_merge_recursive():
     * array_merge_recursive converts values with duplicate keys to arrays rather than
     * overwriting the value in the first array with the duplicate value in the second array.
     *
     * array_merge_recursive_distinct does not change the data types of the values in the arrays.
     * Matching keys' values in the second array overwrite those in the first array, as is the
     * case with array_merge.
     *
     * Freely based on information found on http://www.php.net/manual/en/function.array-merge-recursive.php
     *
     * {@internal Should be moved to a general utility class.}}
     *
     * @return array
     */
    public static function array_merge_recursive_distinct()
    {
    }
    /**
     * Counts the total of all the keywords being used for posts except the given one.
     *
     * @param string $keyword The keyword to be counted.
     * @param int    $post_id The id of the post to which the keyword belongs.
     *
     * @return array
     */
    public static function keyword_usage($keyword, $post_id)
    {
    }
    /**
     * Returns the post types for the given post ids.
     *
     * @param array $post_ids The post ids to get the post types for.
     *
     * @return array The post types.
     */
    public static function post_types_for_ids($post_ids)
    {
    }
    /**
     * Filter the schema article types.
     *
     * @return void
     */
    public static function filter_schema_article_types()
    {
    }
  }
  /**
   * This class generates the metabox on the edit post / page as well as contains all page analysis functionality.
   */
  class WPSEO_Metabox extends \WPSEO_Meta
  {
    /**
     * Whether the social tab is enabled.
     *
     * @var bool
     */
    private $social_is_enabled;
    /**
     * Helper to determine whether the SEO analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_SEO
     */
    protected $seo_analysis;
    /**
     * Helper to determine whether the readability analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_Readability
     */
    protected $readability_analysis;
    /**
     * Helper to determine whether the inclusive language analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_Inclusive_Language
     */
    protected $inclusive_language_analysis;
    /**
     * The metabox editor object.
     *
     * @var WPSEO_Metabox_Editor
     */
    protected $editor;
    /**
     * The Metabox post.
     *
     * @var WP_Post
     */
    protected $post = \null;
    /**
     * Whether the advanced metadata is enabled.
     *
     * @var bool
     */
    protected $is_advanced_metadata_enabled;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Checks whether the request comes from an IE 11 browser.
     *
     * @return bool Whether the request comes from an IE 11 browser.
     */
    public static function is_internet_explorer()
    {
    }
    /**
     * Adds an alternative metabox for internet explorer users.
     */
    public function internet_explorer_metabox()
    {
    }
    /**
     * Renders the content for the internet explorer metabox.
     *
     * @return void
     */
    public function render_internet_explorer_notice()
    {
    }
    /**
     * Translates text strings for use in the meta box.
     *
     * IMPORTANT: if you want to add a new string (option) somewhere, make sure you add that array key to
     * the main meta box definition array in the class WPSEO_Meta() as well!!!!
     */
    public static function translate_meta_boxes()
    {
    }
    /**
     * Determines whether the metabox should be shown for the passed identifier.
     *
     * By default the check is done for post types, but can also be used for taxonomies.
     *
     * @param string|null $identifier The identifier to check.
     * @param string      $type       The type of object to check. Defaults to post_type.
     *
     * @return bool Whether or not the metabox should be displayed.
     */
    public function display_metabox($identifier = \null, $type = 'post_type')
    {
    }
    /**
     * Adds the Yoast SEO meta box to the edit boxes in the edit post, page,
     * attachment, and custom post types pages.
     *
     * @return void
     */
    public function add_meta_box()
    {
    }
    /**
     * Adds CSS classes to the meta box.
     *
     * @param array $classes An array of postbox CSS classes.
     *
     * @return array List of classes that will be applied to the editbox container.
     */
    public function wpseo_metabox_class($classes)
    {
    }
    /**
     * Passes variables to js for use with the post-scraper.
     *
     * @return array
     */
    public function get_metabox_script_data()
    {
    }
    /**
     * Determines whether or not the current post type has registered taxonomies.
     *
     * @return bool Whether the current post type has taxonomies.
     */
    private function current_post_type_has_taxonomies()
    {
    }
    /**
     * Determines the scope based on the post type.
     * This can be used by the replacevar plugin to determine if a replacement needs to be executed.
     *
     * @return string String describing the current scope.
     */
    private function determine_scope()
    {
    }
    /**
     * Outputs the meta box.
     */
    public function meta_box()
    {
    }
    /**
     * Renders the metabox hidden fields.
     *
     * @return void
     */
    protected function render_hidden_fields()
    {
    }
    /**
     * Renders the metabox tabs.
     *
     * @return void
     */
    protected function render_tabs()
    {
    }
    /**
     * Returns the relevant metabox tabs for the current view.
     *
     * @return WPSEO_Metabox_Section[]
     */
    private function get_tabs()
    {
    }
    /**
     * Returns the metabox tabs that have been added by other plugins.
     *
     * @return WPSEO_Metabox_Section_Additional[]
     */
    protected function get_additional_tabs()
    {
    }
    /**
     * Adds a line in the meta box.
     *
     * @todo [JRF] Check if $class is added appropriately everywhere.
     *
     * @param array  $meta_field_def Contains the vars based on which output is generated.
     * @param string $key            Internal key (without prefix).
     *
     * @return string
     */
    public function do_meta_box($meta_field_def, $key = '')
    {
    }
    /**
     * Saves the WP SEO metadata for posts.
     *
     * {@internal $_POST parameters are validated via sanitize_post_meta().}}
     *
     * @param int $post_id Post ID.
     *
     * @return bool|void Boolean false if invalid save post request.
     */
    public function save_postdata($post_id)
    {
    }
    /**
     * Determines if the given meta value key is disabled.
     *
     * @param string $key The key of the meta value.
     *
     * @return bool Whether the given meta value key is disabled.
     */
    public function is_meta_value_disabled($key)
    {
    }
    /**
     * Enqueues all the needed JS and CSS.
     *
     * @todo [JRF => whomever] Create css/metabox-mp6.css file and add it to the below allowed colors array when done.
     */
    public function enqueue()
    {
    }
    /**
     * Returns post in metabox context.
     *
     * @return WP_Post|array
     */
    protected function get_metabox_post()
    {
    }
    /**
     * Returns an array with shortcode tags for all registered shortcodes.
     *
     * @return array
     */
    private function get_valid_shortcode_tags()
    {
    }
    /**
     * Prepares the replace vars for localization.
     *
     * @return array Replace vars.
     */
    private function get_replace_vars()
    {
    }
    /**
     * Returns the list of replace vars that should be hidden inside the editor.
     *
     * @return string[] The hidden replace vars.
     */
    protected function get_hidden_replace_vars()
    {
    }
    /**
     * Prepares the recommended replace vars for localization.
     *
     * @return array Recommended replacement variables.
     */
    private function get_recommended_replace_vars()
    {
    }
    /**
     * Gets the custom replace variables for custom taxonomies and fields.
     *
     * @param WP_Post $post The post to check for custom taxonomies and fields.
     *
     * @return array Array containing all the replacement variables.
     */
    private function get_custom_replace_vars($post)
    {
    }
    /**
     * Gets the custom replace variables for custom taxonomies.
     *
     * @param WP_Post $post The post to check for custom taxonomies.
     *
     * @return array Array containing all the replacement variables.
     */
    private function get_custom_taxonomies_replace_vars($post)
    {
    }
    /**
     * Gets the custom replace variables for custom fields.
     *
     * @param WP_Post $post The post to check for custom fields.
     *
     * @return array Array containing all the replacement variables.
     */
    private function get_custom_fields_replace_vars($post)
    {
    }
    /**
     * Checks if the page is the post overview page.
     *
     * @param string $page The page to check for the post overview page.
     *
     * @return bool Whether or not the given page is the post overview page.
     */
    public static function is_post_overview($page)
    {
    }
    /**
     * Checks if the page is the post edit page.
     *
     * @param string $page The page to check for the post edit page.
     *
     * @return bool Whether or not the given page is the post edit page.
     */
    public static function is_post_edit($page)
    {
    }
    /**
     * Retrieves the product title.
     *
     * @return string The product title.
     */
    protected function get_product_title()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Notifiers
   */
  /**
   * Dictates the required methods for a Notification Handler implementation.
   */
  interface WPSEO_Notification_Handler
  {
    /**
     * Handles the notification object.
     *
     * @param Yoast_Notification_Center $notification_center The notification center object.
     *
     * @return void
     */
    public function handle(\Yoast_Notification_Center $notification_center);
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Notifiers
   */
  /**
   * Abstract class representing a dismissible notification.
   */
  abstract class WPSEO_Dismissible_Notification implements \WPSEO_Listener, \WPSEO_Notification_Handler
  {
    /**
     * The identifier for the notification.
     *
     * @var string
     */
    protected $notification_identifier = '';
    /**
     * Retrieves instance of a notification.
     *
     * @return Yoast_Notification The notification.
     */
    protected abstract function get_notification();
    /**
     * Listens to an argument in the request URL and triggers an action.
     *
     * @return void
     */
    public function listen()
    {
    }
    /**
     * Adds the notification if applicable, otherwise removes it.
     *
     * @param Yoast_Notification_Center $notification_center The notification center object.
     *
     * @return void
     */
    public function handle(\Yoast_Notification_Center $notification_center)
    {
    }
    /**
     * Listens to an argument in the request URL and triggers an action.
     *
     * @return void
     */
    protected function dismiss()
    {
    }
    /**
     * Checks if a notice is applicable.
     *
     * @return bool Whether a notice should be shown or not.
     */
    protected function is_applicable()
    {
    }
    /**
     * Checks whether the notification has been dismissed.
     *
     * @codeCoverageIgnore
     *
     * @return bool True when notification is dismissed.
     */
    protected function is_notice_dismissed()
    {
    }
    /**
     * Retrieves the value where listener is listening for.
     *
     * @codeCoverageIgnore
     *
     * @return string|null The listener value or null if not set.
     */
    protected function get_listener_value()
    {
    }
    /**
     * Dismisses the notification.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    protected function set_dismissal_state()
    {
    }
    /**
     * Redirects the user back to the dashboard.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    protected function redirect_to_dashboard()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Roles
   */
  /**
   * Role Manager interface.
   */
  interface WPSEO_Role_Manager
  {
    /**
     * Registers a role.
     *
     * @param string      $role         Role to register.
     * @param string      $display_name Display name to use.
     * @param string|null $template     Optional. Role to base the new role on.
     *
     * @return void
     */
    public function register($role, $display_name, $template = \null);
    /**
     * Adds the registered roles.
     *
     * @return void
     */
    public function add();
    /**
     * Removes the registered roles.
     *
     * @return void
     */
    public function remove();
    /**
     * Returns the list of registered roles.
     *
     * @return string[] List or registered roles.
     */
    public function get_roles();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Roles
   */
  /**
   * Abstract Role Manager template.
   */
  abstract class WPSEO_Abstract_Role_Manager implements \WPSEO_Role_Manager
  {
    /**
     * Registered roles.
     *
     * @var array
     */
    protected $roles = [];
    /**
     * Registers a role.
     *
     * @param string      $role         Role to register.
     * @param string      $display_name Display name to use.
     * @param string|null $template     Optional. Role to base the new role on.
     *
     * @return void
     */
    public function register($role, $display_name, $template = \null)
    {
    }
    /**
     * Returns the list of registered roles.
     *
     * @return string[] List or registered roles.
     */
    public function get_roles()
    {
    }
    /**
     * Adds the registered roles.
     *
     * @return void
     */
    public function add()
    {
    }
    /**
     * Removes the registered roles.
     *
     * @return void
     */
    public function remove()
    {
    }
    /**
     * Returns the capabilities for the specified role.
     *
     * @param string $role Role to fetch capabilities from.
     *
     * @return array List of capabilities.
     */
    protected function get_capabilities($role)
    {
    }
    /**
     * Returns true if the capability exists on the role.
     *
     * @param WP_Role $role       Role to check capability against.
     * @param string  $capability Capability to check.
     *
     * @return bool True if the capability is defined for the role.
     */
    protected function capability_exists(\WP_Role $role, $capability)
    {
    }
    /**
     * Filters out capabilities that are already set for the role.
     *
     * This makes sure we don't override configurations that have been previously set.
     *
     * @param string $role         The role to check against.
     * @param array  $capabilities The capabilities that should be set.
     *
     * @return array Capabilties that can be safely set.
     */
    protected function filter_existing_capabilties($role, array $capabilities)
    {
    }
    /**
     * Adds a role to the system.
     *
     * @param string $role         Role to add.
     * @param string $display_name Name to display for the role.
     * @param array  $capabilities Capabilities to add to the role.
     *
     * @return void
     */
    protected abstract function add_role($role, $display_name, array $capabilities = []);
    /**
     * Removes a role from the system.
     *
     * @param string $role Role to remove.
     *
     * @return void
     */
    protected abstract function remove_role($role);
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Roles
   */
  /**
   * Role registration class.
   */
  class WPSEO_Register_Roles implements \WPSEO_WordPress_Integration
  {
    /**
     * Adds hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the roles.
     *
     * @return void
     */
    public function register()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Roles
   */
  /**
   * Role Manager Factory.
   */
  class WPSEO_Role_Manager_Factory
  {
    /**
     * Retrieves the Role manager to use.
     *
     * @return WPSEO_Role_Manager
     */
    public static function get()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Roles
   */
  /**
   * VIP implementation of the Role Manager.
   *
   * @deprecated 19.9
   * @codeCoverageIgnore
   */
  final class WPSEO_Role_Manager_VIP extends \WPSEO_Abstract_Role_Manager
  {
    /**
     * Adds a role to the system.
     *
     * @deprecated 19.9
     * @codeCoverageIgnore
     *
     * @param string $role         Role to add.
     * @param string $display_name Name to display for the role.
     * @param array  $capabilities Capabilities to add to the role.
     *
     * @return void
     */
    protected function add_role($role, $display_name, array $capabilities = [])
    {
    }
    /**
     * Removes a role from the system.
     *
     * @deprecated 19.9
     * @codeCoverageIgnore
     *
     * @param string $role Role to remove.
     *
     * @return void
     */
    protected function remove_role($role)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Roles
   */
  /**
   * WordPress' default implementation of the Role Manager.
   */
  final class WPSEO_Role_Manager_WP extends \WPSEO_Abstract_Role_Manager
  {
    /**
     * Adds a role to the system.
     *
     * @param string $role         Role to add.
     * @param string $display_name Name to display for the role.
     * @param array  $capabilities Capabilities to add to the role.
     *
     * @return void
     */
    protected function add_role($role, $display_name, array $capabilities = [])
    {
    }
    /**
     * Removes a role from the system.
     *
     * @param string $role Role to remove.
     *
     * @return void
     */
    protected function remove_role($role)
    {
    }
    /**
     * Formats the capabilities to the required format.
     *
     * @param array $capabilities Capabilities to format.
     * @param bool  $enabled      Whether these capabilities should be enabled or not.
     *
     * @return array Formatted capabilities.
     */
    protected function format_capabilities(array $capabilities, $enabled = \true)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Services
   */
  /**
   * Represents the file size service.
   */
  class WPSEO_File_Size_Service
  {
    /**
     * Retrieves an indexable.
     *
     * @param WP_REST_Request $request The request object.
     *
     * @return WP_REST_Response The response.
     */
    public function get(\WP_REST_Request $request)
    {
    }
    /**
     * Retrieves the file url.
     *
     * @param WP_REST_Request $request The request to retrieve file url from.
     *
     * @return string The file url.
     * @throws WPSEO_File_Size_Exception The file is hosted externally.
     */
    protected function get_file_url(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if the file is hosted externally.
     *
     * @param string $file_url The file url.
     *
     * @return bool True if it is hosted externally.
     */
    protected function is_externally_hosted($file_url)
    {
    }
    /**
     * Returns the file size.
     *
     * @param string $file_url The file url to get the size for.
     *
     * @return int The file size.
     * @throws WPSEO_File_Size_Exception Retrieval of file size went wrong for unknown reasons.
     */
    protected function get_file_size($file_url)
    {
    }
    /**
     * Calculates the file size using the Utils class.
     *
     * @param string $file_url The file to retrieve the size for.
     *
     * @return int|bool The file size or False if it could not be retrieved.
     */
    protected function calculate_file_size($file_url)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Statistics
   */
  /**
   * Class WPSEO_Statistic_Integration.
   */
  class WPSEO_Statistic_Integration implements \WPSEO_WordPress_Integration
  {
    /**
     * Adds hooks to clear the cache.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Clears the dashboard widget items cache.
     *
     * @return void
     */
    public function clear_cache()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Statistics
   */
  /**
   * Class WPSEO_Statistics_Service.
   */
  class WPSEO_Statistics_Service
  {
    /**
     * Cache transient id.
     *
     * @var string
     */
    const CACHE_TRANSIENT_KEY = 'wpseo-statistics-totals';
    /**
     * Class that generates interesting statistics about things.
     *
     * @var WPSEO_Statistics
     */
    protected $statistics;
    /**
     * Statistics labels.
     *
     * @var string[]
     */
    protected $labels;
    /**
     * WPSEO_Statistics_Service contructor.
     *
     * @param WPSEO_Statistics $statistics The statistics class to retrieve statistics from.
     */
    public function __construct(\WPSEO_Statistics $statistics)
    {
    }
    /**
     * Fetches statistics by REST request.
     *
     * @return WP_REST_Response The response object.
     */
    public function get_statistics()
    {
    }
    /**
     * Gets a header summarizing the given statistics results.
     *
     * @param array $statistics The statistics results.
     *
     * @return string The header summing up the statistics results.
     */
    private function get_header_from_statistics(array $statistics)
    {
    }
    /**
     * An array representing items to be added to the At a Glance dashboard widget.
     *
     * @return array The statistics for the current user.
     */
    private function statistic_items()
    {
    }
    /**
     * Gets the statistics transient value. Returns array if transient wasn't set.
     *
     * @return array|mixed Returns the transient or an empty array if the transient doesn't exist.
     */
    private function get_transient()
    {
    }
    /**
     * Set the statistics transient cache for a specific user.
     *
     * @param array $transient The current stored transient with the cached data.
     * @param int   $user      The user's ID to assign the retrieved values to.
     *
     * @return array The statistics transient for the user.
     */
    private function set_statistic_items_for_user($transient, $user)
    {
    }
    /**
     * Gets the division of SEO scores.
     *
     * @param array $scores The SEO scores.
     *
     * @return array|bool The division of SEO scores, false if there are no posts.
     */
    private function get_seo_score_division(array $scores)
    {
    }
    /**
     * Get all SEO ranks and data associated with them.
     *
     * @return array An array of SEO scores and associated data.
     */
    private function get_seo_scores_with_post_count()
    {
    }
    /**
     * Converts a rank to data usable in the dashboard widget.
     *
     * @param WPSEO_Rank $rank The rank to map.
     *
     * @return array The mapped rank.
     */
    private function map_rank_to_widget(\WPSEO_Rank $rank)
    {
    }
    /**
     * Returns a dashboard widget label to use for a certain rank.
     *
     * @param WPSEO_Rank $rank The rank to return a label for.
     *
     * @return string The label for the rank.
     */
    private function get_label_for_rank(\WPSEO_Rank $rank)
    {
    }
    /**
     * Determines the labels for the various scoring ranks that are known within Yoast SEO.
     *
     * @return array Array containing the translatable labels.
     */
    private function labels()
    {
    }
    /**
     * Filter items if they have a count of zero.
     *
     * @param array $item The item to potentially filter out.
     *
     * @return bool Whether or not the count is zero.
     */
    private function filter_items($item)
    {
    }
    /**
     * Returns a link for the overview of posts of a certain rank.
     *
     * @param WPSEO_Rank $rank The rank to return a link for.
     *
     * @return string The link that shows an overview of posts with that rank.
     */
    private function get_link_for_rank(\WPSEO_Rank $rank)
    {
    }
  }
  /**
   * This class adds columns to the taxonomy table.
   */
  class WPSEO_Taxonomy_Columns
  {
    /**
     * The SEO analysis.
     *
     * @var WPSEO_Metabox_Analysis_SEO
     */
    private $analysis_seo;
    /**
     * The readability analysis.
     *
     * @var WPSEO_Metabox_Analysis_Readability
     */
    private $analysis_readability;
    /**
     * The current taxonomy.
     *
     * @var string
     */
    private $taxonomy;
    /**
     * Holds the Indexable_Repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Holds the Score_Icon_Helper.
     *
     * @var Score_Icon_Helper
     */
    protected $score_icon_helper;
    /**
     * WPSEO_Taxonomy_Columns constructor.
     */
    public function __construct()
    {
    }
    /**
     * Adds an SEO score column to the terms table, right after the description column.
     *
     * @param array $columns Current set columns.
     *
     * @return array
     */
    public function add_columns(array $columns)
    {
    }
    /**
     * Parses the column.
     *
     * @param string $content     The current content of the column.
     * @param string $column_name The name of the column.
     * @param int    $term_id     ID of requested taxonomy.
     *
     * @return string
     */
    public function parse_column($content, $column_name, $term_id)
    {
    }
    /**
     * Retrieves the taxonomy from the $_GET or $_POST variable.
     *
     * @return string|null The current taxonomy or null when it is not set.
     */
    public function get_current_taxonomy()
    {
    }
    /**
     * Returns the posted/get taxonomy value if it is set.
     *
     * @return string|null
     */
    private function get_taxonomy()
    {
    }
    /**
     * Parses the value for the score column.
     *
     * @param int $term_id ID of requested term.
     *
     * @return string
     */
    private function get_score_value($term_id)
    {
    }
    /**
     * Parses the value for the readability score column.
     *
     * @param int $term_id ID of the requested term.
     *
     * @return string The HTML for the readability score indicator.
     */
    private function get_score_readability_value($term_id)
    {
    }
    /**
     * Check if the taxonomy is indexable.
     *
     * @param mixed $term The current term.
     *
     * @return bool Whether the term is indexable.
     */
    private function is_indexable($term)
    {
    }
    /**
     * Wraps the WPSEO_Metabox check to determine whether the metabox should be displayed either by
     * choice of the admin or because the taxonomy is not public.
     *
     * @since 7.0
     *
     * @param string|null $taxonomy Optional. The taxonomy to test, defaults to the current taxonomy.
     *
     * @return bool Whether the meta box (and associated columns etc) should be hidden.
     */
    private function display_metabox($taxonomy = \null)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class WPSEO_Taxonomy_Presenter.
   */
  class WPSEO_Taxonomy_Fields_Presenter
  {
    /**
     * The taxonomy meta data for the current term.
     *
     * @var array
     */
    private $tax_meta;
    /**
     * Constructs the WPSEO_Taxonomy_Fields_Presenter class.
     *
     * @param stdClass $term The current term.
     */
    public function __construct($term)
    {
    }
    /**
     * Displaying the form fields.
     *
     * @param array $fields Array with the fields that will be displayed.
     *
     * @return string
     */
    public function html(array $fields)
    {
    }
    /**
     * Create a row in the form table.
     *
     * @param string $field_name          Variable the row controls.
     * @param array  $field_configuration Array with the field configuration.
     *
     * @return string
     */
    private function form_row($field_name, array $field_configuration)
    {
    }
    /**
     * Generates the html for the given field config.
     *
     * @param string $field_type  The fieldtype, e.g: text, checkbox, etc.
     * @param string $field_name  The name of the field.
     * @param string $field_value The value of the field.
     * @param array  $options     Array with additional options.
     *
     * @return string
     */
    private function get_field($field_type, $field_name, $field_value, array $options)
    {
    }
    /**
     * Getting the value for given field_name.
     *
     * @param string $field_name The fieldname to get the value for.
     *
     * @return string
     */
    private function get_field_value($field_name)
    {
    }
    /**
     * Getting the class attributes if $options contains a class key.
     *
     * @param array $options The array with field options.
     *
     * @return string
     */
    private function get_class(array $options)
    {
    }
    /**
     * Getting the label HTML.
     *
     * @param string $label      The label value.
     * @param string $field_name The target field.
     *
     * @return string
     */
    private function get_label($label, $field_name)
    {
    }
    /**
     * Returns the HTML for the row which contains label, help and the field.
     *
     * @param string                 $label The html for the label if there was a label set.
     * @param WPSEO_Admin_Help_Panel $help  The help panel to render in this row.
     * @param string                 $field The html for the field.
     *
     * @return string
     */
    private function parse_row($label, \WPSEO_Admin_Help_Panel $help, $field)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class WPSEO_Taxonomy_Tab.
   *
   * Contains the basics for each class extending this one.
   */
  class WPSEO_Taxonomy_Fields
  {
    /**
     * Returns the taxonomy fields.
     *
     * @param string $field_group The field group.
     *
     * @return array
     */
    public function get($field_group)
    {
    }
    /**
     * Returns array with the fields for the general tab.
     *
     * @return array
     */
    protected function get_content_fields()
    {
    }
    /**
     * Returns array with the fields for the settings tab.
     *
     * @return array
     */
    protected function get_settings_fields()
    {
    }
    /**
     * Returning the fields for the social media tab.
     *
     * @return array
     */
    protected function get_social_fields()
    {
    }
    /**
     * Filter the hidden fields.
     *
     * @param array $fields Array with the form fields that has will be filtered.
     *
     * @return array
     */
    protected function filter_hidden_fields(array $fields)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * This class generates the metabox on the edit term page.
   */
  class WPSEO_Taxonomy_Metabox
  {
    /**
     * The term currently being edited.
     *
     * @var WP_Term
     */
    private $term;
    /**
     * The term's taxonomy.
     *
     * @var string
     */
    private $taxonomy;
    /**
     * Whether or not the social tab is enabled for this metabox.
     *
     * @var bool
     */
    private $is_social_enabled;
    /**
     * Helper to determine whether or not the SEO analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_SEO
     */
    protected $seo_analysis;
    /**
     * Helper to determine whether or not the readability analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_Readability
     */
    protected $readability_analysis;
    /**
     * Helper to determine whether or not the inclusive language analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_Inclusive_Language
     */
    protected $inclusive_language_analysis;
    /**
     * The constructor.
     *
     * @param string   $taxonomy The taxonomy.
     * @param stdClass $term     The term.
     */
    public function __construct($taxonomy, $term)
    {
    }
    /**
     * Shows the Yoast SEO metabox for the term.
     */
    public function display()
    {
    }
    /**
     * Renders the metabox hidden fields.
     *
     * @return void
     */
    protected function render_hidden_fields()
    {
    }
    /**
     * Renders the metabox tabs.
     *
     * @return void
     */
    protected function render_tabs()
    {
    }
    /**
     * Returns the relevant metabox sections for the current view.
     *
     * @return WPSEO_Metabox_Section[]
     */
    private function get_tabs()
    {
    }
    /**
     * Returns the metabox tabs that have been added by other plugins.
     *
     * @return WPSEO_Metabox_Section_Additional[]
     */
    protected function get_additional_tabs()
    {
    }
    /**
     * Retrieves the product title.
     *
     * @return string The product title.
     */
    protected function get_product_title()
    {
    }
  }
  /**
   * Class that handles the edit boxes on taxonomy edit pages.
   */
  class WPSEO_Taxonomy
  {
    /**
     * The current active taxonomy.
     *
     * @var string
     */
    private $taxonomy = '';
    /**
     * Holds the metabox SEO analysis instance.
     *
     * @var WPSEO_Metabox_Analysis_SEO
     */
    private $analysis_seo;
    /**
     * Holds the metabox readability analysis instance.
     *
     * @var WPSEO_Metabox_Analysis_Readability
     */
    private $analysis_readability;
    /**
     * Holds the metabox inclusive language analysis instance.
     *
     * @var WPSEO_Metabox_Analysis_Inclusive_Language
     */
    private $analysis_inclusive_language;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Add hooks late enough for taxonomy object to be available for checks.
     */
    public function admin_init()
    {
    }
    /**
     * Show the SEO inputs for term.
     *
     * @param stdClass|WP_Term $term Term to show the edit boxes for.
     */
    public function term_metabox($term)
    {
    }
    /**
     * Renders the content for the internet explorer metabox.
     *
     * @return void
     */
    private function show_internet_explorer_notice()
    {
    }
    /**
     * Queue assets for taxonomy screens.
     *
     * @since 1.5.0
     */
    public function admin_enqueue_scripts()
    {
    }
    /**
     * Update the taxonomy meta data on save.
     *
     * @param int    $term_id  ID of the term to save data for.
     * @param int    $tt_id    The taxonomy_term_id for the term.
     * @param string $taxonomy The taxonomy the term belongs to.
     */
    public function update_term($term_id, $tt_id, $taxonomy)
    {
    }
    /**
     * Determines if the given meta value key is disabled.
     *
     * @param string $key The key of the meta value.
     * @return bool Whether the given meta value key is disabled.
     */
    public function is_meta_value_disabled($key)
    {
    }
    /**
     * Allows post-kses-filtered HTML in term descriptions.
     */
    public function custom_category_descriptions_allow_html()
    {
    }
    /**
     * Output the WordPress editor.
     */
    public function custom_category_description_editor()
    {
    }
    /**
     * Pass variables to js for use with the term-scraper.
     *
     * @param int $term_id The ID of the term to localize the script for.
     *
     * @return array
     */
    public function localize_term_scraper_script($term_id)
    {
    }
    /**
     * Pass some variables to js for replacing variables.
     *
     * @return array
     */
    public function localize_replace_vars_script()
    {
    }
    /**
     * Determines the scope based on the current taxonomy.
     * This can be used by the replacevar plugin to determine if a replacement needs to be executed.
     *
     * @return string String decribing the current scope.
     */
    private function determine_scope()
    {
    }
    /**
     * Determines if a given page is the term overview page.
     *
     * @param string $page The string to check for the term overview page.
     *
     * @return bool
     */
    public static function is_term_overview($page)
    {
    }
    /**
     * Determines if a given page is the term edit page.
     *
     * @param string $page The string to check for the term edit page.
     *
     * @return bool
     */
    public static function is_term_edit($page)
    {
    }
    /**
     * Function to get the labels for the current taxonomy.
     *
     * @return object|null Labels for the current taxonomy or null if the taxonomy is not set.
     */
    public static function get_labels()
    {
    }
    /**
     * Retrieves a template.
     * Check if metabox for current taxonomy should be displayed.
     *
     * @return bool
     */
    private function show_metabox()
    {
    }
    /**
     * Getting the taxonomy from the URL.
     *
     * @return string
     */
    private static function get_taxonomy()
    {
    }
    /**
     * Get the current tag ID from the GET parameters.
     *
     * @return int|null the tag ID if it exists, null otherwise.
     */
    private static function get_tag_id()
    {
    }
    /**
     * Prepares the replace vars for localization.
     *
     * @return array The replacement variables.
     */
    private function get_replace_vars()
    {
    }
    /**
     * Prepares the recommended replace vars for localization.
     *
     * @return array The recommended replacement variables.
     */
    private function get_recommended_replace_vars()
    {
    }
  }
  /**
   * Represents the addon option data.
   */
  class WPSEO_Tracking_Addon_Data implements \WPSEO_Collection
  {
    /**
     * The local options we want to track.
     *
     * @var string[] The option_names for the options we want to track.
     */
    private $local_include_list = ['use_multiple_locations', 'multiple_locations_same_organization', 'business_type', 'woocommerce_local_pickup_setting'];
    /**
     * The woo options we want to track.
     *
     * @var string[] The option_names for the options we want to track.
     */
    private $woo_include_list = [];
    /**
     * The news options we want to track.
     *
     * @var string[] The option_names for the options we want to track.
     */
    private $news_include_list = [];
    /**
     * The video options we want to track.
     *
     * @var string[] The option_names for the options we want to track.
     */
    private $video_include_list = [];
    /**
     * Returns the collection data.
     *
     * @return array The collection data.
     */
    public function get()
    {
    }
    /**
     * Gets the tracked options from the addon
     *
     * @param array  $addon_settings      The current list of addon settings.
     * @param string $source_name         The option key of the addon.
     * @param string $slug                The addon slug.
     * @param array  $option_include_list All the options to be included in tracking.
     *
     * @return array
     */
    public function get_addon_settings(array $addon_settings, $source_name, $slug, $option_include_list)
    {
    }
    /**
     * Filter business_type in local addon settings.
     *
     * Remove the business_type setting when 'multiple_locations_shared_business_info' setting is turned off.
     *
     * @param array  $addon_settings      The current list of addon settings.
     * @param string $source_name         The option key of the addon.
     * @param string $slug                The addon slug.
     * @param array  $option_include_list All the options to be included in tracking.
     *
     * @return array
     */
    public function get_local_addon_settings(array $addon_settings, $source_name, $slug, $option_include_list)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Tracking
   */
  /**
   * Represents the default data.
   */
  class WPSEO_Tracking_Default_Data implements \WPSEO_Collection
  {
    /**
     * Returns the collection data.
     *
     * @return array The collection data.
     */
    public function get()
    {
    }
    /**
     * Returns the number of posts of a certain type.
     *
     * @param string $post_type The post type return the count for.
     *
     * @return int The count for this post type.
     */
    protected function get_post_count($post_type)
    {
    }
    /**
     * Returns the WordPress version.
     *
     * @return string The version.
     */
    protected function get_wordpress_version()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Tracking
   */
  /**
   * Represents the plugin data.
   */
  class WPSEO_Tracking_Plugin_Data implements \WPSEO_Collection
  {
    /**
     * Plugins with auto updating enabled.
     *
     * @var array
     */
    private $auto_update_plugin_list;
    /**
     * Returns the collection data.
     *
     * @return array The collection data.
     */
    public function get()
    {
    }
    /**
     * Returns all plugins.
     *
     * @return array The formatted plugins.
     */
    protected function get_plugin_data()
    {
    }
    /**
     * Sets all auto updating plugin data so it can be used in the tracking list.
     *
     * @return void
     */
    public function set_auto_update_plugin_list()
    {
    }
    /**
     * Formats the plugin array.
     *
     * @param array $plugin The plugin details.
     *
     * @return array The formatted array.
     */
    protected function format_plugin(array $plugin)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Tracking
   */
  /**
   * Represents the server data.
   */
  class WPSEO_Tracking_Server_Data implements \WPSEO_Collection
  {
    /**
     * Returns the collection data.
     *
     * @return array The collection data.
     */
    public function get()
    {
    }
    /**
     * Returns the values with server details.
     *
     * @return array Array with the value.
     */
    protected function get_server_data()
    {
    }
    /**
     * Returns details about the curl version.
     *
     * @return array|null The curl info. Or null when curl isn't available..
     */
    protected function get_curl_info()
    {
    }
    /**
     * Returns a list with php extensions.
     *
     * @return array Returns the state of the php extensions.
     */
    protected function get_php_extensions()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Tracking
   */
  /**
   * Collects anonymized settings data.
   */
  class WPSEO_Tracking_Settings_Data implements \WPSEO_Collection
  {
    /**
     * The options that need to be anonymized before they can be sent elsewhere.
     *
     * @var array All of the option_names which need to be
     * anonymized before they can be sent elsewhere.
     */
    private $anonymous_settings = ['baiduverify', 'googleverify', 'msverify', 'yandexverify', 'myyoast-oauth', 'website_name', 'alternate_website_name', 'company_logo', 'company_name', 'company_alternate_name', 'person_name', 'person_logo', 'person_logo_id', 'company_logo_id', 'facebook_site', 'instagram_url', 'linkedin_url', 'myspace_url', 'og_default_image', 'og_default_image_id', 'og_frontpage_title', 'og_frontpage_desc', 'og_frontpage_image', 'og_frontpage_image_id', 'open_graph_frontpage_title', 'open_graph_frontpage_desc', 'open_graph_frontpage_image', 'open_graph_frontpage_image_id', 'other_social_urls', 'mastodon_url', 'pinterest_url', 'pinterestverify', 'twitter_site', 'youtube_url', 'wikipedia_url', 'semrush_tokens', 'zapier_api_key', 'wincher_tokens', 'wincher_website_id', 'least_readability_ignore_list', 'least_seo_score_ignore_list', 'most_linked_ignore_list', 'least_linked_ignore_list', 'indexables_page_reading_list'];
    /**
     * The options we want to track.
     *
     * @var array The option_names for the options we want to track.
     */
    private $include_list = ['ms_defaults_set', 'version', 'disableadvanced_meta', 'ryte_indexability', 'baiduverify', 'googleverify', 'msverify', 'yandexverify', 'site_type', 'has_multiple_authors', 'environment_type', 'content_analysis_active', 'keyword_analysis_active', 'inclusive_language_analysis_active', 'enable_admin_bar_menu', 'enable_cornerstone_content', 'enable_xml_sitemap', 'enable_text_link_counter', 'show_onboarding_notice', 'first_activated_on', 'myyoast-oauth', 'dynamic_permalinks', 'website_name', 'alternate_website_name', 'company_logo', 'company_name', 'company_or_person', 'person_name', 'forcerewritetitle', 'separator', 'title-home-wpseo', 'title-author-wpseo', 'title-archive-wpseo', 'title-search-wpseo', 'title-404-wpseo', 'metadesc-home-wpseo', 'metadesc-author-wpseo', 'metadesc-archive-wpseo', 'rssbefore', 'rssafter', 'noindex-author-wpseo', 'noindex-author-noposts-wpseo', 'noindex-archive-wpseo', 'disable-author', 'disable-date', 'disable-post_format', 'disable-attachment', 'breadcrumbs-404crumb', 'breadcrumbs-display-blog-page', 'breadcrumbs-boldlast', 'breadcrumbs-archiveprefix', 'breadcrumbs-enable', 'breadcrumbs-home', 'breadcrumbs-prefix', 'breadcrumbs-searchprefix', 'breadcrumbs-sep', 'person_logo', 'person_logo_id', 'company_logo_id', 'company_or_person_user_id', 'stripcategorybase', 'noindex-post', 'display-metabox-pt-post', 'noindex-page', 'display-metabox-pt-page', 'noindex-attachment', 'display-metabox-pt-attachment', 'display-metabox-tax-category', 'noindex-tax-category', 'display-metabox-tax-post_tag', 'noindex-tax-post_tag', 'display-metabox-tax-post_format', 'noindex-tax-post_format', 'taxonomy-category-ptparent', 'taxonomy-post_tag-ptparent', 'taxonomy-post_format-ptparent', 'breadcrumbs-blog-remove', 'hideeditbox-post', 'hideeditbox-page', 'hideeditbox-attachment', 'hideeditbox-tax-category', 'hideeditbox-tax-post_tag', 'hideeditbox-tax-post_format', 'facebook_site', 'instagram_url', 'linkedin_url', 'myspace_url', 'og_default_image', 'og_default_image_id', 'og_frontpage_title', 'og_frontpage_desc', 'og_frontpage_image', 'og_frontpage_image_id', 'open_graph_frontpage_title', 'open_graph_frontpage_desc', 'open_graph_frontpage_image', 'open_graph_frontpage_image_id', 'opengraph', 'pinterest_url', 'pinterestverify', 'twitter', 'twitter_site', 'twitter_card_type', 'youtube_url', 'wikipedia_url', 'mastodon_url', 'indexables_indexing_completed', 'semrush_integration_active', 'semrush_tokens', 'semrush_country_code', 'enable_enhanced_slack_sharing', 'zapier_integration_active', 'zapier_api_key', 'enable_metabox_insights', 'enable_link_suggestions', 'enable_index_now', 'workouts', 'wincher_integration_active', 'wincher_tokens', 'wincher_website_id', 'wincher_automatically_add_keyphrases', 'first_time_install', 'other_social_urls', 'remove_feed_global', 'remove_feed_global_comments', 'remove_feed_post_comments', 'remove_feed_authors', 'remove_feed_categories', 'remove_feed_tags', 'remove_feed_custom_taxonomies', 'remove_feed_post_types', 'remove_feed_search', 'remove_atom_rdf_feeds', 'remove_shortlinks', 'remove_rest_api_links', 'remove_rsd_wlw_links', 'remove_oembed_links', 'remove_generator', 'remove_emoji_scripts', 'remove_powered_by_header', 'remove_pingback_header', 'clean_campaign_tracking_urls', 'clean_permalinks', 'clean_permalinks_extra_variables', 'search_cleanup', 'search_cleanup_emoji', 'search_cleanup_patterns', 'search_character_limit', 'redirect_search_pretty_urls', 'wordproof_integration_active', 'indexables_overview_state', 'deny_search_crawling', 'deny_wp_json_crawling'];
    /**
     * Returns the collection data.
     *
     * @return array The collection data.
     */
    public function get()
    {
    }
    /**
     * Anonimizes the WPSEO_Options array by replacing all $anonymous_settings values to 'used'.
     *
     * @param array $settings The settings.
     *
     * @return array The anonymized settings.
     */
    private function anonymize_settings($settings)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Tracking
   */
  /**
   * Represents the theme data.
   */
  class WPSEO_Tracking_Theme_Data implements \WPSEO_Collection
  {
    /**
     * Returns the collection data.
     *
     * @return array The collection data.
     */
    public function get()
    {
    }
    /**
     * Returns the name of the parent theme.
     *
     * @param WP_Theme $theme The theme object.
     *
     * @return string|null The name of the parent theme or null.
     */
    private function get_parent_theme(\WP_Theme $theme)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Tracking
   */
  /**
   * This class handles the tracking routine.
   */
  class WPSEO_Tracking implements \WPSEO_WordPress_Integration
  {
    /**
     * The tracking option name.
     *
     * @var string
     */
    protected $option_name = 'wpseo_tracking_last_request';
    /**
     * The limit for the option.
     *
     * @var int
     */
    protected $threshold = 0;
    /**
     * The endpoint to send the data to.
     *
     * @var string
     */
    protected $endpoint = '';
    /**
     * The current time.
     *
     * @var int
     */
    private $current_time;
    /**
     * WPSEO_Tracking constructor.
     *
     * @param string $endpoint  The endpoint to send the data to.
     * @param int    $threshold The limit for the option.
     */
    public function __construct($endpoint, $threshold)
    {
    }
    /**
     * Registers all hooks to WordPress.
     */
    public function register_hooks()
    {
    }
    /**
     * Schedules a new sending of the tracking data after a WordPress core update.
     *
     * @param bool|WP_Upgrader $upgrader Optional. WP_Upgrader instance or false.
     *                                   Depending on context, it might be a Theme_Upgrader,
     *                                   Plugin_Upgrader, Core_Upgrade, or Language_Pack_Upgrader.
     *                                   instance. Default false.
     * @param array            $data     Array of update data.
     *
     * @return void
     */
    public function schedule_tracking_data_sending($upgrader = \false, $data = [])
    {
    }
    /**
     * Sends the tracking data.
     *
     * @param bool $force Whether to send the tracking data ignoring the two
     *                    weeks time threshold. Default false.
     */
    public function send($force = \false)
    {
    }
    /**
     * Determines whether to send the tracking data.
     *
     * Returns false if tracking is disabled or the current page is one of the
     * admin plugins pages. Returns true when there's no tracking data stored or
     * the data was sent more than two weeks ago. The two weeks interval is set
     * when instantiating the class.
     *
     * @param bool $ignore_time_treshhold Whether to send the tracking data ignoring
     *                                    the two weeks time treshhold. Default false.
     *
     * @return bool True when tracking data should be sent.
     */
    protected function should_send_tracking($ignore_time_treshhold = \false)
    {
    }
    /**
     * Checks if the given amount of seconds exceeds the set threshold.
     *
     * @param int $seconds The amount of seconds to check.
     *
     * @return bool True when seconds is bigger than threshold.
     */
    protected function exceeds_treshhold($seconds)
    {
    }
    /**
     * Returns the collector for collecting the data.
     *
     * @return WPSEO_Collector The instance of the collector.
     */
    public function get_collector()
    {
    }
    /**
     * See if we should run tracking at all.
     *
     * @return bool True when we can track, false when we can't.
     */
    private function tracking_enabled()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class representing a feature toggle.
   */
  class Yoast_Feature_Toggle
  {
    /**
     * Feature toggle identifier.
     *
     * @var string
     */
    protected $name = '';
    /**
     * Name of the setting the feature toggle is associated with.
     *
     * @var string
     */
    protected $setting = '';
    /**
     * Whether the feature is premium or not.
     *
     * @var bool
     */
    protected $premium = \false;
    /**
     * Whether the feature is in beta or not.
     *
     * @var bool
     */
    protected $in_beta = \false;
    /**
     * The Premium version in which this feature has been added.
     *
     * @var string
     */
    protected $premium_version = '';
    /**
     * The languages in which this feature is supported.
     * E.g. for language specific analysis support.
     *
     * If empty, the feature is considered to have support in all languages.
     *
     * @var string[]
     */
    protected $supported_languages = [];
    /**
     * Feature toggle label.
     *
     * @var string
     */
    protected $label = '';
    /**
     * URL to learn more about the feature.
     *
     * @var string
     */
    protected $read_more_url = '';
    /**
     * URL to learn more about the premium feature.
     *
     * @var string
     */
    protected $premium_url = '';
    /**
     * URL to buy premium.
     *
     * @var string
     */
    protected $premium_upsell_url = '';
    /**
     * Label for the learn more link.
     *
     * @var string
     */
    protected $read_more_label = '';
    /**
     * Additional help content for the feature.
     *
     * @var string
     */
    protected $extra = '';
    /**
     * Additional content to be rendered after the toggle.
     *
     * @var string
     */
    protected $after = '';
    /**
     * Value to specify the feature toggle order.
     *
     * @var string
     */
    protected $order = 100;
    /**
     * Disable the integration toggle.
     *
     * @var bool
     */
    protected $disabled = \false;
    /**
     * Whether the feature is new or not.
     *
     * @var bool
     */
    protected $new = \false;
    /**
     * Constructor.
     *
     * Sets the feature toggle arguments.
     *
     * @param array $args {
     *     Feature toggle arguments.
     *
     *     @type string $name                Required. Feature toggle identifier.
     *     @type string $setting             Required. Name of the setting the feature toggle is associated with.
     *     @type string $disabled            Whether the feature is premium or not.
     *     @type string $label               Feature toggle label.
     *     @type string $read_more_url       URL to learn more about the feature. Default empty string.
     *     @type string $premium_upsell_url  URL to buy premium. Default empty string.
     *     @type string $read_more_label     Label for the learn more link. Default empty string.
     *     @type string $extra               Additional help content for the feature. Default empty string.
     *     @type int    $order               Value to specify the feature toggle order. A lower value indicates
     *                                       a higher priority. Default 100.
     *     @type bool   $disabled            Disable the integration toggle. Default false.
     *     @type string $new                 Whether the feature is new or not.
     *     @type bool   $in_beta             Whether the feature is in beta or not.
     *     @type array  $supported_languages The languages that this feature supports.
     *     @type string $premium_version     The Premium version in which this feature was added.
     * }
     *
     * @throws InvalidArgumentException Thrown when a required argument is missing.
     */
    public function __construct(array $args)
    {
    }
    /**
     * Magic isset-er.
     *
     * @param string $key Key to check whether a value for it is set.
     *
     * @return bool True if set, false otherwise.
     */
    public function __isset($key)
    {
    }
    /**
     * Magic getter.
     *
     * @param string $key Key to get the value for.
     *
     * @return mixed Value for the key, or null if not set.
     */
    public function __get($key)
    {
    }
    /**
     * Checks whether the feature for this toggle is enabled.
     *
     * @return bool True if the feature is enabled, false otherwise.
     */
    public function is_enabled()
    {
    }
  }
  /**
   * Class for managing feature toggles.
   */
  class Yoast_Feature_Toggles
  {
    /**
     * Available feature toggles.
     *
     * @var array
     */
    protected $toggles;
    /**
     * Instance holder.
     *
     * @var self|null
     */
    protected static $instance = \null;
    /**
     * Gets the main feature toggles manager instance used.
     *
     * This essentially works like a Singleton, but for its drawbacks does not restrict
     * instantiation otherwise.
     *
     * @return self Main instance.
     */
    public static function instance()
    {
    }
    /**
     * Gets all available feature toggles.
     *
     * @return array List of sorted Yoast_Feature_Toggle instances.
     */
    public function get_all()
    {
    }
    /**
     * Loads the available feature toggles.
     *
     * Also ensures that the toggles are all Yoast_Feature_Toggle instances and sorted by their order value.
     *
     * @return array List of sorted Yoast_Feature_Toggle instances.
     */
    protected function load_toggles()
    {
    }
    /**
     * Returns html for a warning that core sitemaps are enabled when yoast seo sitemaps are disabled.
     *
     * @return string HTML string for the warning.
     */
    protected function sitemaps_toggle_after()
    {
    }
    /**
     * Ensures that the passed value is a Yoast_Feature_Toggle.
     *
     * @param Yoast_Feature_Toggle|object|array $toggle_data Feature toggle instance, or raw object or array
     *                                                       containing feature toggle data.
     * @return Yoast_Feature_Toggle Feature toggle instance based on $toggle_data.
     */
    protected function ensure_toggle($toggle_data)
    {
    }
    /**
     * Callback for sorting feature toggles by their order.
     *
     * {@internal Once the minimum PHP version goes up to PHP 7.0, the logic in the function
     * can be replaced with the spaceship operator `<=>`.}
     *
     * @param Yoast_Feature_Toggle $feature_a Feature A.
     * @param Yoast_Feature_Toggle $feature_b Feature B.
     *
     * @return int An integer less than, equal to, or greater than zero indicating respectively
     *             that feature A is considered to be less than, equal to, or greater than feature B.
     */
    protected function sort_toggles_callback(\Yoast_Feature_Toggle $feature_a, \Yoast_Feature_Toggle $feature_b)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class for generating a html select.
   */
  class Yoast_Input_Select
  {
    /**
     * The id attribute value.
     *
     * @var string
     */
    private $select_id;
    /**
     * The name attribute value.
     *
     * @var string
     */
    private $select_name;
    /**
     * Additional select attributes.
     *
     * @var array
     */
    private $select_attributes = [];
    /**
     * Array with the options to parse.
     *
     * @var array
     */
    private $select_options;
    /**
     * The current selected option.
     *
     * @var string
     */
    private $selected_option;
    /**
     * Constructor.
     *
     * @param string $select_id       ID for the select.
     * @param string $select_name     Name for the select.
     * @param array  $select_options  Array with the options to parse.
     * @param string $selected_option The current selected option.
     */
    public function __construct($select_id, $select_name, array $select_options, $selected_option)
    {
    }
    /**
     * Print the rendered view.
     */
    public function output_html()
    {
    }
    /**
     * Return the rendered view.
     *
     * @return string
     */
    public function get_html()
    {
    }
    /**
     * Add an attribute to the attributes property.
     *
     * @param string $attribute The name of the attribute to add.
     * @param string $value     The value of the attribute.
     */
    public function add_attribute($attribute, $value)
    {
    }
    /**
     * Return the set fields for the select.
     *
     * @return array
     */
    private function get_select_values()
    {
    }
    /**
     * Return the attribute string, when there are attributes set.
     *
     * @return string
     */
    private function get_attributes()
    {
    }
    /**
     * Get an attribute from the attributes.
     *
     * @param string $value     The value of the attribute.
     * @param string $attribute The attribute to look for.
     */
    private function parse_attribute(&$value, $attribute)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Class for managing integration toggles.
   */
  class Yoast_Integration_Toggles
  {
    /**
     * Available integration toggles.
     *
     * @var array
     */
    protected $toggles;
    /**
     * Instance holder.
     *
     * @var self|null
     */
    protected static $instance = \null;
    /**
     * Gets the main integration toggles manager instance used.
     *
     * This essentially works like a Singleton, but for its drawbacks does not restrict
     * instantiation otherwise.
     *
     * @return self Main instance.
     */
    public static function instance()
    {
    }
    /**
     * Gets all available integration toggles.
     *
     * @return array List of sorted Yoast_Feature_Toggle instances.
     */
    public function get_all()
    {
    }
    /**
     * Loads the available integration toggles.
     *
     * Also ensures that the toggles are all Yoast_Feature_Toggle instances and sorted by their order value.
     *
     * @return array List of sorted Yoast_Feature_Toggle instances.
     */
    protected function load_toggles()
    {
    }
    /**
     * Ensures that the passed value is a Yoast_Feature_Toggle.
     *
     * @param Yoast_Feature_Toggle|object|array $toggle_data Feature toggle instance, or raw object or array
     *                                                       containing integration toggle data.
     * @return Yoast_Feature_Toggle Feature toggle instance based on $toggle_data.
     */
    protected function ensure_toggle($toggle_data)
    {
    }
    /**
     * Callback for sorting integration toggles by their order.
     *
     * {@internal Once the minimum PHP version goes up to PHP 7.0, the logic in the function
     * can be replaced with the spaceship operator `<=>`.}
     *
     * @param Yoast_Feature_Toggle $feature_a Feature A.
     * @param Yoast_Feature_Toggle $feature_b Feature B.
     *
     * @return int An integer less than, equal to, or greater than zero indicating respectively
     *             that feature A is considered to be less than, equal to, or greater than feature B.
     */
    protected function sort_toggles_callback(\Yoast_Feature_Toggle $feature_a, \Yoast_Feature_Toggle $feature_b)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin
   */
  /**
   * Generate the HTML for a form element.
   */
  interface Yoast_Form_Element
  {
    /**
     * Return the HTML for the form element.
     *
     * @return string
     */
    public function get_html();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\Watchers
   */
  /**
   * Class WPSEO_Slug_Change_Watcher.
   */
  class WPSEO_Slug_Change_Watcher implements \WPSEO_WordPress_Integration
  {
    /**
     * Registers all hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Enqueues the quick edit handler.
     *
     * @return void
     */
    public function enqueue_assets()
    {
    }
    /**
     * Shows an message when a post is about to get trashed.
     *
     * @param int $post_id The current post ID.
     *
     * @return void
     */
    public function detect_post_trash($post_id)
    {
    }
    /**
     * Shows an message when a post is about to get trashed.
     *
     * @param int $post_id The current post ID.
     *
     * @return void
     */
    public function detect_post_delete($post_id)
    {
    }
    /**
     * Shows a message when a term is about to get deleted.
     *
     * @param int $term_id The term ID that will be deleted.
     *
     * @return void
     */
    public function detect_term_delete($term_id)
    {
    }
    /**
     * Checks if the post is viewable.
     *
     * @param string $post_id The post id to check.
     *
     * @return bool Whether the post is viewable or not.
     */
    protected function is_post_viewable($post_id)
    {
    }
    /**
     * Checks if the term is viewable.
     *
     * @param string $term_id The term ID to check.
     *
     * @return bool Whether the term is viewable or not.
     */
    protected function is_term_viewable($term_id)
    {
    }
    /**
     * Gets the taxonomy label to use for a term.
     *
     * @param int $term_id The term ID.
     *
     * @return string The taxonomy's singular label.
     */
    protected function get_taxonomy_label_for_term($term_id)
    {
    }
    /**
     * Retrieves the singular post type label.
     *
     * @param string $post_type Post type to retrieve label from.
     *
     * @return string The singular post type name.
     */
    protected function get_post_type_label($post_type)
    {
    }
    /**
     * Checks whether the given post status is visible or not.
     *
     * @param string $post_status The post status to check.
     *
     * @return bool Whether or not the post is visible.
     */
    protected function check_visible_post_status($post_status)
    {
    }
    /**
     * Returns the message around changed URLs.
     *
     * @param string $first_sentence The first sentence of the notification.
     *
     * @return string The full notification.
     */
    protected function get_message($first_sentence)
    {
    }
    /**
     * Adds a notification to be shown on the next page request since posts are updated in an ajax request.
     *
     * @param string $message The message to add to the notification.
     *
     * @return void
     */
    protected function add_notification($message)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Inc
   */
  /**
   * Represents the addon manager.
   */
  class WPSEO_Addon_Manager
  {
    /**
     * Holds the name of the transient.
     *
     * @var string
     */
    const SITE_INFORMATION_TRANSIENT = 'wpseo_site_information';
    /**
     * Holds the name of the transient.
     *
     * @var string
     */
    const SITE_INFORMATION_TRANSIENT_QUICK = 'wpseo_site_information_quick';
    /**
     * Holds the slug for YoastSEO free.
     *
     * @var string
     */
    const FREE_SLUG = 'yoast-seo-wordpress';
    /**
     * Holds the slug for YoastSEO Premium.
     *
     * @var string
     */
    const PREMIUM_SLUG = 'yoast-seo-wordpress-premium';
    /**
     * Holds the slug for Yoast News.
     *
     * @var string
     */
    const NEWS_SLUG = 'yoast-seo-news';
    /**
     * Holds the slug for Video.
     *
     * @var string
     */
    const VIDEO_SLUG = 'yoast-seo-video';
    /**
     * Holds the slug for WooCommerce.
     *
     * @var string
     */
    const WOOCOMMERCE_SLUG = 'yoast-seo-woocommerce';
    /**
     * Holds the slug for Local.
     *
     * @var string
     */
    const LOCAL_SLUG = 'yoast-seo-local';
    /**
     * The expected addon data.
     *
     * @var array
     */
    protected static $addons = ['wp-seo-premium.php' => self::PREMIUM_SLUG, 'wpseo-news.php' => self::NEWS_SLUG, 'video-seo.php' => self::VIDEO_SLUG, 'wpseo-woocommerce.php' => self::WOOCOMMERCE_SLUG, 'local-seo.php' => self::LOCAL_SLUG];
    /**
     * The addon data for the shortlinks.
     *
     * @var array
     */
    private $addon_details = [self::PREMIUM_SLUG => ['name' => 'Yoast SEO Premium', 'short_link_activation' => 'https://yoa.st/13j', 'short_link_renewal' => 'https://yoa.st/4ey'], self::NEWS_SLUG => ['name' => 'Yoast News SEO', 'short_link_activation' => 'https://yoa.st/4xq', 'short_link_renewal' => 'https://yoa.st/4xv'], self::WOOCOMMERCE_SLUG => ['name' => 'Yoast WooCommerce SEO', 'short_link_activation' => 'https://yoa.st/4xs', 'short_link_renewal' => 'https://yoa.st/4xx'], self::VIDEO_SLUG => ['name' => 'Yoast Video SEO', 'short_link_activation' => 'https://yoa.st/4xr', 'short_link_renewal' => 'https://yoa.st/4xw'], self::LOCAL_SLUG => ['name' => 'Yoast Local SEO', 'short_link_activation' => 'https://yoa.st/4xp', 'short_link_renewal' => 'https://yoa.st/4xu']];
    /**
     * Holds the site information data.
     *
     * @var stdClass
     */
    private $site_information;
    /**
     * Hooks into WordPress.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers "expired subscription" warnings to the update messages of our addons.
     *
     * @return void
     */
    public function register_expired_messages()
    {
    }
    /**
     * Gets the subscriptions for current site.
     *
     * @return stdClass The subscriptions.
     */
    public function get_subscriptions()
    {
    }
    /**
     * Provides a list of addon filenames.
     *
     * @return string[] List of addon filenames with their slugs.
     */
    public function get_addon_filenames()
    {
    }
    /**
     * Finds the plugin file.
     *
     * @param string $plugin_slug The plugin slug to search.
     *
     * @return bool|string Plugin file when installed, False when plugin isn't installed.
     */
    public function get_plugin_file($plugin_slug)
    {
    }
    /**
     * Retrieves the subscription for the given slug.
     *
     * @param string $slug The plugin slug to retrieve.
     *
     * @return stdClass|false Subscription data when found, false when not found.
     */
    public function get_subscription($slug)
    {
    }
    /**
     * Retrieves a list of (subscription) slugs by the active addons.
     *
     * @return array The slugs.
     */
    public function get_subscriptions_for_active_addons()
    {
    }
    /**
     * Retrieves a list of versions for each addon.
     *
     * @return array The addon versions.
     */
    public function get_installed_addons_versions()
    {
    }
    /**
     * Retrieves the plugin information from the subscriptions.
     *
     * @param stdClass|false $data   The result object. Default false.
     * @param string         $action The type of information being requested from the Plugin Installation API.
     * @param stdClass       $args   Plugin API arguments.
     *
     * @return object Extended plugin data.
     */
    public function get_plugin_information($data, $action, $args)
    {
    }
    /**
     * Retrieves information from MyYoast about which addons are connected to the current site.
     *
     * @return stdClass The list of addons activated for this site.
     */
    public function get_myyoast_site_information()
    {
    }
    /**
     * Checks if the subscription for the given slug is valid.
     *
     * @param string $slug The plugin slug to retrieve.
     *
     * @return bool True when the subscription is valid.
     */
    public function has_valid_subscription($slug)
    {
    }
    /**
     * Checks if there are addon updates.
     *
     * @param stdClass|mixed $data The current data for update_plugins.
     *
     * @return stdClass Extended data for update_plugins.
     */
    public function check_for_updates($data)
    {
    }
    /**
     * Extracts Yoast SEO Free's data from the wp.org API response.
     *
     * @param object $data The wp.org API response.
     *
     * @return object Yoast Free's data from wp.org.
     */
    protected function extract_yoast_data($data)
    {
    }
    /**
     * If the plugin is lacking an active subscription, throw a warning.
     *
     * @param array $plugin_data The data for the plugin in this row.
     */
    public function expired_subscription_warning($plugin_data)
    {
    }
    /**
     * Checks if there are any installed addons.
     *
     * @return bool True when there are installed Yoast addons.
     */
    public function has_installed_addons()
    {
    }
    /**
     * Checks if the plugin is installed and activated in WordPress.
     *
     * @param string $slug The class' slug.
     *
     * @return bool True when installed and activated.
     */
    public function is_installed($slug)
    {
    }
    /**
     * Validates the addons and show a notice for the ones that are invalid.
     */
    public function validate_addons()
    {
    }
    /**
     * Removes the site information transients.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    public function remove_site_information_transients()
    {
    }
    /**
     * Creates an instance of Yoast_Notification.
     *
     * @param string $product_name The product to create the notification for.
     * @param string $short_link   The short link for the addon notification.
     *
     * @return Yoast_Notification The created notification.
     */
    protected function create_notification($product_name, $short_link)
    {
    }
    /**
     * Checks whether a plugin expiry date has been passed.
     *
     * @param stdClass $subscription Plugin subscription.
     *
     * @return bool Has the plugin expired.
     */
    protected function has_subscription_expired($subscription)
    {
    }
    /**
     * Converts a subscription to plugin based format.
     *
     * @param stdClass      $subscription    The subscription to convert.
     * @param stdClass|null $yoast_free_data The Yoast Free's data.
     * @param bool          $plugin_info     Whether we're in the plugin information modal.
     * @param string        $plugin_file     The plugin filename.
     *
     * @return stdClass The converted subscription.
     */
    protected function convert_subscription_to_plugin($subscription, $yoast_free_data = \null, $plugin_info = \false, $plugin_file = '')
    {
    }
    /**
     * Returns the plugin's icon URL.
     *
     * @param string $slug The plugin slug.
     *
     * @return string The icon URL for this plugin.
     */
    protected function get_icon($slug)
    {
    }
    /**
     * Return an array of plugin banner URLs.
     *
     * @param string $slug The plugin slug.
     *
     * @return string[]
     */
    protected function get_banners($slug)
    {
    }
    /**
     * Checks if the given plugin_file belongs to a Yoast addon.
     *
     * @param string $plugin_file Path to the plugin.
     *
     * @return bool True when plugin file is for a Yoast addon.
     */
    protected function is_yoast_addon($plugin_file)
    {
    }
    /**
     * Retrieves the addon slug by given plugin file path.
     *
     * @param string $plugin_file The file path to the plugin.
     *
     * @return string The slug when found or empty string when not.
     */
    protected function get_slug_by_plugin_file($plugin_file)
    {
    }
    /**
     * Retrieves the installed Yoast addons.
     *
     * @return array The installed plugins.
     */
    protected function get_installed_addons()
    {
    }
    /**
     * Retrieves a list of active addons.
     *
     * @return array The active addons.
     */
    protected function get_active_addons()
    {
    }
    /**
     * Retrieves the current sites from the API.
     *
     * @codeCoverageIgnore
     *
     * @return bool|stdClass Object when request is successful. False if not.
     */
    protected function request_current_sites()
    {
    }
    /**
     * Retrieves the transient value with the site information.
     *
     * @codeCoverageIgnore
     *
     * @return stdClass|false The transient value.
     */
    protected function get_site_information_transient()
    {
    }
    /**
     * Sets the site information transient.
     *
     * @codeCoverageIgnore
     *
     * @param stdClass $site_information The site information to save.
     *
     * @return void
     */
    protected function set_site_information_transient($site_information)
    {
    }
    /**
     * Retrieves all installed WordPress plugins.
     *
     * @codeCoverageIgnore
     *
     * @return array The plugins.
     */
    protected function get_plugins()
    {
    }
    /**
     * Checks if the given plugin file belongs to an active plugin.
     *
     * @codeCoverageIgnore
     *
     * @param string $plugin_file The file path to the plugin.
     *
     * @return bool True when plugin is active.
     */
    protected function is_plugin_active($plugin_file)
    {
    }
    /**
     * Returns an object with no subscriptions.
     *
     * @codeCoverageIgnore
     *
     * @return stdClass Site information.
     */
    protected function get_site_information_default()
    {
    }
    /**
     * Maps the plugin API response.
     *
     * @param object $site_information Site information as received from the API.
     *
     * @return stdClass Mapped site information.
     */
    protected function map_site_information($site_information)
    {
    }
    /**
     * Maps a plugin subscription.
     *
     * @param object $subscription Subscription information as received from the API.
     *
     * @return stdClass Mapped subscription.
     */
    protected function map_subscription($subscription)
    {
    }
    /**
     * Retrieves the site information.
     *
     * @return stdClass The site information.
     */
    private function get_site_information()
    {
    }
    /**
     * Retrieves the contents for the support section.
     *
     * @return string The support section content.
     */
    protected function get_support_section()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Inc
   */
  /**
   * Handles requests to MyYoast.
   */
  class WPSEO_MyYoast_Api_Request
  {
    /**
     * The Request URL.
     *
     * @var string
     */
    protected $url;
    /**
     * The request parameters.
     *
     * @var array
     */
    protected $args = ['method' => 'GET', 'timeout' => 5, 'headers' => ['Accept-Encoding' => '*', 'Expect' => '']];
    /**
     * Contains the fetched response.
     *
     * @var stdClass
     */
    protected $response;
    /**
     * Contains the error message when request went wrong.
     *
     * @var string
     */
    protected $error_message = '';
    /**
     * Constructor.
     *
     * @codeCoverageIgnore
     *
     * @param string $url  The request url.
     * @param array  $args The request arguments.
     */
    public function __construct($url, array $args = [])
    {
    }
    /**
     * Fires the request.
     *
     * @return bool True when request is successful.
     */
    public function fire()
    {
    }
    /**
     * Retrieves the error message.
     *
     * @return string The set error message.
     */
    public function get_error_message()
    {
    }
    /**
     * Retrieves the response.
     *
     * @return stdClass The response object.
     */
    public function get_response()
    {
    }
    /**
     * Performs the request using WordPress internals.
     *
     * @codeCoverageIgnore
     *
     * @param string $url               The request URL.
     * @param array  $request_arguments The request arguments.
     *
     * @return string                                 The retrieved body.
     * @throws WPSEO_MyYoast_Bad_Request_Exception    When request is invalid.
     */
    protected function do_request($url, $request_arguments)
    {
    }
    /**
     * Decodes the JSON encoded response.
     *
     * @param string $response The response to decode.
     *
     * @return stdClass                             The json decoded response.
     * @throws WPSEO_MyYoast_Invalid_JSON_Exception When decoded string is not a JSON object.
     */
    protected function decode_response($response)
    {
    }
    /**
     * Checks if MyYoast tokens are allowed and adds the token to the request body.
     *
     * When tokens are disallowed it will add the url to the request body.
     *
     * @param array $request_arguments The arguments to enrich.
     *
     * @return array The enriched arguments.
     */
    protected function enrich_request_arguments(array $request_arguments)
    {
    }
    /**
     * Retrieves the request body based on URL or access token support.
     *
     * @codeCoverageIgnore
     *
     * @return array The request body.
     */
    public function get_request_body()
    {
    }
    /**
     * Wraps the get current user id function.
     *
     * @codeCoverageIgnore
     *
     * @return int The user id.
     */
    protected function get_current_user_id()
    {
    }
    /**
     * Retrieves the installed addons as http headers.
     *
     * @codeCoverageIgnore
     *
     * @return array The installed addon versions.
     */
    protected function get_installed_addon_versions()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Inc
   */
  /**
   * Represents the post type utils.
   */
  class WPSEO_Post_Type
  {
    /**
     * Returns an array with the accessible post types.
     *
     * An accessible post type is a post type that is public and isn't set as no-index (robots).
     *
     * @return array Array with all the accessible post_types.
     */
    public static function get_accessible_post_types()
    {
    }
    /**
     * Returns whether the passed post type is considered accessible.
     *
     * @param string $post_type The post type to check.
     *
     * @return bool Whether or not the post type is considered accessible.
     */
    public static function is_post_type_accessible($post_type)
    {
    }
    /**
     * Checks if the request post type is public and indexable.
     *
     * @param string $post_type_name The name of the post type to lookup.
     *
     * @return bool True when post type is set to index.
     */
    public static function is_post_type_indexable($post_type_name)
    {
    }
    /**
     * Filters the attachment post type from an array with post_types.
     *
     * @param array $post_types The array to filter the attachment post type from.
     *
     * @return array The filtered array.
     */
    public static function filter_attachment_post_type(array $post_types)
    {
    }
    /**
     * Checks if the post type is enabled in the REST API.
     *
     * @param string $post_type The post type to check.
     *
     * @return bool Whether or not the post type is available in the REST API.
     */
    public static function is_rest_enabled($post_type)
    {
    }
    /**
     * Checks if the current post type has an archive.
     *
     * Context: The has_archive value can be a string or a boolean. In most case it will be a boolean,
     * but it can be defined as a string. When it is a string the archive_slug will be overwritten to
     * define another endpoint.
     *
     * @param WP_Post_Type $post_type The post type object.
     *
     * @return bool True whether the post type has an archive.
     */
    public static function has_archive($post_type)
    {
    }
    /**
     * Checks if the Yoast Metabox has been enabled for the post type.
     *
     * @param string $post_type The post type name.
     *
     * @return bool True whether the metabox is enabled.
     */
    public static function has_metabox_enabled($post_type)
    {
    }
    /**
     * Removes the notification related to the post types which have been made public.
     *
     * @return void
     */
    public static function remove_post_types_made_public_notification()
    {
    }
    /**
     * Removes the notification related to the taxonomies which have been made public.
     *
     * @return void
     */
    public static function remove_taxonomies_made_public_notification()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Frontend
   */
  /**
   * This code handles the category rewrites.
   */
  class WPSEO_Rewrite
  {
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Trigger a rewrite_rule flush on shutdown.
     *
     * @since 1.2.8
     */
    public function schedule_flush()
    {
    }
    /**
     * Override the category link to remove the category base.
     *
     * @param string  $link     Term link, overridden by the function for categories.
     * @param WP_Term $term     Unused, term object.
     * @param string  $taxonomy Taxonomy slug.
     *
     * @return string
     */
    public function no_category_base($link, $term, $taxonomy)
    {
    }
    /**
     * Update the query vars with the redirect var when stripcategorybase is active.
     *
     * @param array $query_vars Main query vars to filter.
     *
     * @return array
     */
    public function query_vars($query_vars)
    {
    }
    /**
     * Checks whether the redirect needs to be created.
     *
     * @param array $query_vars Query vars to check for existence of redirect var.
     *
     * @return array|void The query vars.
     */
    public function request($query_vars)
    {
    }
    /**
     * This function taken and only slightly adapted from WP No Category Base plugin by Saurabh Gupta.
     *
     * @return array
     */
    public function category_rewrite_rules()
    {
    }
    /**
     * Adds required category rewrites rules.
     *
     * @param array  $rewrites        The current set of rules.
     * @param string $category_name   Category nicename.
     * @param string $blog_prefix     Multisite blog prefix.
     * @param string $pagination_base WP_Query pagination base.
     *
     * @return array The added set of rules.
     */
    protected function add_category_rewrites($rewrites, $category_name, $blog_prefix, $pagination_base)
    {
    }
    /**
     * Walks through category nicename and convert encoded parts
     * into uppercase using $this->encode_to_upper().
     *
     * @param string $name The encoded category URI string.
     *
     * @return string The convered URI string.
     */
    protected function convert_encoded_to_upper($name)
    {
    }
    /**
     * Converts the encoded URI string to uppercase.
     *
     * @param string $encoded The encoded string.
     *
     * @return string The uppercased string.
     */
    public function encode_to_upper($encoded)
    {
    }
    /**
     * Redirect the "old" category URL to the new one.
     *
     * @codeCoverageIgnore
     *
     * @param string $category_redirect The category page to redirect to.
     * @return void
     */
    protected function redirect($category_redirect)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internal
   */
  /**
   * This class handles storing the current options for future reference.
   *
   * This should only be used during an upgrade routine.
   */
  class WPSEO_Upgrade_History
  {
    /**
     * Option to use to store/retrieve data from.
     *
     * @var string
     */
    protected $option_name = 'wpseo_upgrade_history';
    /**
     * WPSEO_Upgrade_History constructor.
     *
     * @param string|null $option_name Optional. Custom option to use to store/retrieve history from.
     */
    public function __construct($option_name = \null)
    {
    }
    /**
     * Retrieves the content of the history items currently stored.
     *
     * @return array The contents of the history option.
     */
    public function get()
    {
    }
    /**
     * Adds a new history entry in the storage.
     *
     * @param string $old_version  The version we are upgrading from.
     * @param string $new_version  The version we are upgrading to.
     * @param array  $option_names The options that need to be stored.
     */
    public function add($old_version, $new_version, array $option_names)
    {
    }
    /**
     * Retrieves the data for the specified option names from the database.
     *
     * @param array $option_names The option names to retrieve.
     *
     * @return array
     */
    protected function get_options_data(array $option_names)
    {
    }
    /**
     * Stores the new history state.
     *
     * @param array $data The data to store.
     *
     * @return void
     */
    protected function set(array $data)
    {
    }
    /**
     * Retrieves the WPDB object.
     *
     * @return wpdb The WPDB object to use.
     */
    protected function get_wpdb()
    {
    }
    /**
     * Retrieves the option name to store the history in.
     *
     * @return string The option name to store the history in.
     */
    protected function get_option_name()
    {
    }
  }
  /**
   * This code handles the option upgrades.
   */
  class WPSEO_Upgrade
  {
    /**
     * The taxonomy helper.
     *
     * @var Taxonomy_Helper
     */
    private $taxonomy_helper;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Runs the upgrade routine.
     *
     * @param string $routine         The method to call.
     * @param string $version         The new version.
     * @param string $current_version The current set version.
     *
     * @return void
     */
    protected function run_upgrade_routine($routine, $version, $current_version)
    {
    }
    /**
     * Adds a new upgrade history entry.
     *
     * @param string $current_version The old version from which we are upgrading.
     * @param string $new_version     The version we are upgrading to.
     */
    protected function add_upgrade_history($current_version, $new_version)
    {
    }
    /**
     * Runs the needed cleanup after an update, setting the DB version to latest version, flushing caches etc.
     *
     * @param string|null $previous_version The previous version.
     *
     * @return void
     */
    protected function finish_up($previous_version = \null)
    {
    }
    /**
     * Run the Yoast SEO 1.5 upgrade routine.
     *
     * @param string $version Current plugin version.
     */
    private function upgrade_15($version)
    {
    }
    /**
     * Moves options that moved position in WPSEO 2.0.
     */
    private function upgrade_20()
    {
    }
    /**
     * Detects if taxonomy terms were split and updates the corresponding taxonomy meta's accordingly.
     */
    private function upgrade_21()
    {
    }
    /**
     * Performs upgrade functions to Yoast SEO 2.2.
     */
    private function upgrade_22()
    {
    }
    /**
     * Schedules upgrade function to Yoast SEO 2.3.
     */
    private function upgrade_23()
    {
    }
    /**
     * Performs upgrade query to Yoast SEO 2.3.
     */
    public function upgrade_23_query()
    {
    }
    /**
     * Performs upgrade functions to Yoast SEO 3.0.
     */
    private function upgrade_30()
    {
    }
    /**
     * Performs upgrade functions to Yoast SEO 3.3.
     */
    private function upgrade_33()
    {
    }
    /**
     * Performs upgrade functions to Yoast SEO 3.6.
     */
    private function upgrade_36()
    {
    }
    /**
     * Removes the about notice when its still in the database.
     */
    private function upgrade_40()
    {
    }
    /**
     * Moves the content-analysis-active and keyword-analysis-acive options from wpseo-titles to wpseo.
     */
    private function upgrade_44()
    {
    }
    /**
     * Renames the meta name for the cornerstone content. It was a public meta field and it has to be private.
     */
    private function upgrade_47()
    {
    }
    /**
     * Removes the 'wpseo-dismiss-about' notice for every user that still has it.
     */
    private function upgrade_49()
    {
    }
    /**
     * Removes the wpseo-dismiss-about notice from a list of notifications.
     *
     * @param Yoast_Notification[] $notifications The notifications to filter.
     *
     * @return Yoast_Notification[] The filtered list of notifications. Excluding the wpseo-dismiss-about notification.
     */
    public function remove_about_notice($notifications)
    {
    }
    /**
     * Adds the yoast_seo_links table to the database.
     */
    private function upgrade_50()
    {
    }
    /**
     * Register new capabilities and roles.
     */
    private function upgrade_55()
    {
    }
    /**
     * Removes some no longer used options for noindexing subpages and for meta keywords and its associated templates.
     *
     * @return void
     */
    private function upgrade_63()
    {
    }
    /**
     * Perform the 7.0 upgrade, moves settings around, deletes several options.
     *
     * @return void
     */
    private function upgrade_70()
    {
    }
    /**
     * Perform the 7.1 upgrade.
     *
     * @return void
     */
    private function upgrade_71()
    {
    }
    /**
     * Perform the 7.3 upgrade.
     *
     * @return void
     */
    private function upgrade_73()
    {
    }
    /**
     * Performs the 7.4 upgrade.
     *
     * @return void
     */
    private function upgrade_74()
    {
    }
    /**
     * Performs the 7.5.3 upgrade.
     *
     * When upgrading purging media is potentially relevant.
     *
     * @return void
     */
    private function upgrade_753()
    {
    }
    /**
     * Performs the 7.7 upgrade.
     *
     * @return void
     */
    private function upgrade_77()
    {
    }
    /**
     * Performs the 7.7.2 upgrade.
     *
     * @return void
     */
    private function upgrade_772()
    {
    }
    /**
     * Performs the 9.0 upgrade.
     *
     * @return void
     */
    private function upgrade_90()
    {
    }
    /**
     * Performs the 10.0 upgrade.
     *
     * @return void
     */
    private function upgrade_100()
    {
    }
    /**
     * Performs the 11.1 upgrade.
     *
     * @return void
     */
    private function upgrade_111()
    {
    }
    /**
     * Performs the 12.3 upgrade.
     *
     * Removes the about notice when its still in the database.
     */
    private function upgrade_123()
    {
    }
    /**
     * Performs the 12.4 upgrade.
     *
     * Removes the Google plus defaults from the database.
     */
    private function upgrade_124()
    {
    }
    /**
     * Performs the 12.5 upgrade.
     */
    public function upgrade_125()
    {
    }
    /**
     * Performs the 12.8 upgrade.
     */
    private function upgrade_128()
    {
    }
    /**
     * Performs the 13.2 upgrade.
     */
    private function upgrade_132()
    {
    }
    /**
     * Perform the 14.0.3 upgrade.
     */
    private function upgrade_1403()
    {
    }
    /**
     * Performs the 14.1 upgrade.
     */
    private function upgrade_141()
    {
    }
    /**
     * Performs the 14.2 upgrade.
     *
     * Removes the yoast-acf-analysis notice when it's still in the database.
     */
    private function upgrade_142()
    {
    }
    /**
     * Performs the 14.5 upgrade.
     */
    private function upgrade_145()
    {
    }
    /**
     * Performs the 14.9 upgrade.
     */
    private function upgrade_149()
    {
    }
    /**
     * Performs the 15.1 upgrade.
     *
     * @return void
     */
    private function upgrade_151()
    {
    }
    /**
     * Performs the 15.3 upgrade.
     *
     * @return void
     */
    private function upgrade_153()
    {
    }
    /**
     * Performs the 15.5 upgrade.
     *
     * @return void
     */
    private function upgrade_155()
    {
    }
    /**
     * Performs the 15.7 upgrade.
     *
     * @return void
     */
    private function upgrade_157()
    {
    }
    /**
     * Performs the 15.9.1 upgrade routine.
     */
    private function upgrade_1591()
    {
    }
    /**
     * Performs the 16.2 upgrade routine.
     */
    private function upgrade_162()
    {
    }
    /**
     * Performs the 16.5 upgrade.
     *
     * @return void
     */
    private function upgrade_165()
    {
    }
    /**
     * Performs the 17.2 upgrade. Cleans out any unnecessary indexables. See $cleanup_integration->get_cleanup_tasks() to see what will be cleaned out.
     *
     * @return void
     */
    private function upgrade_172()
    {
    }
    /**
     * Performs the 17.7.1 upgrade routine.
     */
    private function upgrade_1771()
    {
    }
    /**
     * Performs the 17.9 upgrade routine.
     */
    private function upgrade_179()
    {
    }
    /**
     * Performs the 18.3 upgrade routine.
     */
    private function upgrade_183()
    {
    }
    /**
     * Performs the 18.6 upgrade routine.
     */
    private function upgrade_186()
    {
    }
    /**
     * Performs the 18.9 upgrade routine.
     */
    private function upgrade_189()
    {
    }
    /**
     * Performs the 19.1 upgrade routine.
     */
    private function upgrade_191()
    {
    }
    /**
     * Performs the 19.3 upgrade routine.
     */
    private function upgrade_193()
    {
    }
    /**
     * Performs the 19.6 upgrade routine.
     */
    private function upgrade_196()
    {
    }
    /**
     * Performs the 19.11 upgrade routine.
     */
    private function upgrade_1911()
    {
    }
    /**
     * Performs the 20.2 upgrade routine.
     */
    private function upgrade_202()
    {
    }
    /**
     * Performs the 20.5 upgrade routine.
     */
    private function upgrade_205()
    {
    }
    /**
     * Sets the home_url option for the 15.1 upgrade routine.
     *
     * @return void
     */
    protected function set_home_url_for_151()
    {
    }
    /**
     * Moves the `indexables_indexation_reason` option to the
     * renamed `indexing_reason` option.
     *
     * @return void
     */
    protected function move_indexables_indexation_reason_for_151()
    {
    }
    /**
     * Checks if the indexable indexation is completed.
     * If so, sets the `indexables_indexation_completed` option to `true`,
     * else to `false`.
     */
    public function set_indexation_completed_option_for_145()
    {
    }
    /**
     * Cleans up the private taxonomies from the indexables table for the upgrade routine to 14.1.
     */
    public function clean_up_private_taxonomies_for_141()
    {
    }
    /**
     * Resets the permalinks of attachments to `null` in the indexable table for the upgrade routine to 14.1.
     */
    private function reset_permalinks_of_attachments_for_141()
    {
    }
    /**
     * Removes notifications from the Notification center for the 14.1 upgrade.
     *
     * @return void
     */
    public function remove_notifications_for_141()
    {
    }
    /**
     * Removes the wpseo-suggested-plugin-yoast-acf-analysis notification from the Notification center for the 14.2 upgrade.
     *
     * @return void
     */
    public function remove_acf_notification_for_142()
    {
    }
    /**
     * Removes the wpseo-plugin-updated notification from the Notification center for the 15.7 upgrade.
     *
     * @return void
     */
    public function remove_plugin_updated_notification_for_157()
    {
    }
    /**
     * Removes all notifications saved in the database under 'wp_yoast_notifications'.
     *
     * @return void
     */
    private function clean_all_notifications()
    {
    }
    /**
     * Removes the post meta fields for a given meta key.
     *
     * @param string $meta_key The meta key.
     *
     * @return void
     */
    private function delete_post_meta($meta_key)
    {
    }
    /**
     * Removes all sitemap validators.
     *
     * This should be executed on every upgrade routine until we have removed the sitemap caching in the database.
     *
     * @return void
     */
    private function remove_sitemap_validators()
    {
    }
    /**
     * Retrieves the option value directly from the database.
     *
     * @param string $option_name Option to retrieve.
     *
     * @return array|mixed The content of the option if exists, otherwise an empty array.
     */
    protected function get_option_from_database($option_name)
    {
    }
    /**
     * Cleans the option to make sure only relevant settings are there.
     *
     * @param string $option_name Option name save.
     *
     * @return void
     */
    protected function cleanup_option_data($option_name)
    {
    }
    /**
     * Saves an option setting to where it should be stored.
     *
     * @param array       $source_data    The option containing the value to be migrated.
     * @param string      $source_setting Name of the key in the "from" option.
     * @param string|null $target_setting Name of the key in the "to" option.
     *
     * @return void
     */
    protected function save_option_setting($source_data, $source_setting, $target_setting = \null)
    {
    }
    /**
     * Migrates WooCommerce archive settings to the WooCommerce Shop page meta-data settings.
     *
     * If no Shop page is defined, nothing will be migrated.
     *
     * @return void
     */
    private function migrate_woocommerce_archive_setting_to_shop_page()
    {
    }
    /**
     * Stores the initial `permalink_structure` option.
     *
     * @return void
     */
    public function set_permalink_structure_option_for_151()
    {
    }
    /**
     * Stores the initial slugs of custom taxonomies.
     *
     * @return void
     */
    public function store_custom_taxonomy_slugs_for_151()
    {
    }
    /**
     * Copies the frontpage social settings to the titles options.
     *
     * @return void
     */
    public function copy_og_settings_from_social_to_titles()
    {
    }
    /**
     * Reset the social options with the correct default values.
     *
     * @return void
     */
    public function reset_og_settings_to_default_values()
    {
    }
    /**
     * Removes all indexables for posts that are not publicly viewable.
     * This method should be called after init, because post_types can still be registered.
     *
     * @return void
     */
    public function remove_indexable_rows_for_non_public_post_types()
    {
    }
    /**
     * Removes all indexables for terms that are not publicly viewable.
     * This method should be called after init, because taxonomies can still be registered.
     *
     * @return void
     */
    public function remove_indexable_rows_for_non_public_taxonomies()
    {
    }
    /**
     * De-duplicates indexables that have more than one "unindexed" rows for the same object. Keeps the newest indexable.
     *
     * @return void
     */
    private function deduplicate_unindexed_indexable_rows()
    {
    }
    /**
     * Cleans up "unindexed" indexable rows when appropriate, aka when there's no object ID even though it should.
     *
     * @return void
     */
    private function clean_unindexed_indexable_rows_with_no_object_id()
    {
    }
    /**
     * Removes all user indexable rows when the author archive is disabled.
     *
     * @return void
     */
    private function remove_indexable_rows_for_disabled_authors_archive()
    {
    }
    /**
     * Creates a query for de-duplicating indexables for a particular type.
     *
     * @param string $object_type The object type to deduplicate.
     * @param array  $duplicates  The result of the duplicate query.
     * @param wpdb   $wpdb        The wpdb object.
     *
     * @return string The query that removes all but one duplicate for each object of the object type.
     */
    private function get_indexable_deduplication_query_for_type($object_type, $duplicates, $wpdb)
    {
    }
  }
  /**
   * Class for the Yoast SEO admin bar menu.
   */
  class WPSEO_Admin_Bar_Menu implements \WPSEO_WordPress_Integration
  {
    /**
     * The identifier used for the menu.
     *
     * @var string
     */
    const MENU_IDENTIFIER = 'wpseo-menu';
    /**
     * The identifier used for the Keyword Research submenu.
     *
     * @var string
     */
    const KEYWORD_RESEARCH_SUBMENU_IDENTIFIER = 'wpseo-kwresearch';
    /**
     * The identifier used for the Analysis submenu.
     *
     * @var string
     */
    const ANALYSIS_SUBMENU_IDENTIFIER = 'wpseo-analysis';
    /**
     * The identifier used for the Settings submenu.
     *
     * @var string
     */
    const SETTINGS_SUBMENU_IDENTIFIER = 'wpseo-settings';
    /**
     * The identifier used for the Network Settings submenu.
     *
     * @var string
     */
    const NETWORK_SETTINGS_SUBMENU_IDENTIFIER = 'wpseo-network-settings';
    /**
     * Asset manager instance.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * Holds the Score_Icon_Helper instance.
     *
     * @var Score_Icon_Helper
     */
    protected $indexable_repository;
    /**
     * Holds the Score_Icon_Helper instance.
     *
     * @var Score_Icon_Helper
     */
    protected $score_icon_helper;
    /**
     * Holds the Product_Helper instance.
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * Holds the shortlinker instance.
     *
     * @var WPSEO_Shortlinker
     */
    protected $shortlinker;
    /**
     * Whether SEO Score is enabled.
     *
     * @var bool
     */
    protected $is_seo_enabled = \null;
    /**
     * Whether readability is enabled.
     *
     * @var bool
     */
    protected $is_readability_enabled = \null;
    /**
     * The indexable for the current WordPress page, if found.
     *
     * @var bool|Indexable
     */
    protected $current_indexable = \null;
    /**
     * Constructs the WPSEO_Admin_Bar_Menu.
     *
     * @param WPSEO_Admin_Asset_Manager|null $asset_manager        Optional. Asset manager to use.
     * @param Indexable_Repository|null      $indexable_repository Optional. The Indexable_Repository.
     * @param Score_Icon_Helper|null         $score_icon_helper    Optional. The Score_Icon_Helper.
     * @param Product_Helper|null            $product_helper       Optional. The product helper.
     * @param WPSEO_Shortlinker|null         $shortlinker          The shortlinker.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $asset_manager = \null, \Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository = \null, \Yoast\WP\SEO\Helpers\Score_Icon_Helper $score_icon_helper = \null, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper = \null, \WPSEO_Shortlinker $shortlinker = \null)
    {
    }
    /**
     * Gets whether SEO score is enabled, with cache applied.
     *
     * @return bool True if SEO score is enabled, false otherwise.
     */
    protected function get_is_seo_enabled()
    {
    }
    /**
     * Gets whether readability is enabled, with cache applied.
     *
     * @return bool True if readability is enabled, false otherwise.
     */
    protected function get_is_readability_enabled()
    {
    }
    /**
     * Returns the indexable for the current WordPress page, with cache applied.
     *
     * @return bool|Indexable The indexable, false if none could be found.
     */
    protected function get_current_indexable()
    {
    }
    /**
     * Adds the admin bar menu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    public function add_menu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Enqueues admin bar assets.
     *
     * @return void
     */
    public function enqueue_assets()
    {
    }
    /**
     * Registers the hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks whether the requirements to use this class are met.
     *
     * @return bool True if requirements are met, false otherwise.
     */
    public function meets_requirements()
    {
    }
    /**
     * Adds the admin bar root menu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_root_menu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Adds the admin bar analysis submenu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_analysis_submenu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Adds the admin bar tools submenu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_seo_tools_submenu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Adds the admin bar How To submenu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_how_to_submenu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Adds the admin bar How To submenu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_get_help_submenu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Adds the admin bar How To submenu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_premium_link(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Adds the admin bar settings submenu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_settings_submenu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Adds the admin bar network settings submenu.
     *
     * @param WP_Admin_Bar $wp_admin_bar Admin bar instance to add the menu to.
     *
     * @return void
     */
    protected function add_network_settings_submenu(\WP_Admin_Bar $wp_admin_bar)
    {
    }
    /**
     * Gets the menu title markup.
     *
     * @return string Admin bar title markup.
     */
    protected function get_title()
    {
    }
    /**
     * Gets the current post if in a singular post context.
     *
     * @global string       $pagenow Current page identifier.
     * @global WP_Post|null $post    Current post object, or null if none available.
     *
     * @return WP_Post|null Post object, or null if not in singular context.
     */
    protected function get_singular_post()
    {
    }
    /**
     * Gets the focus keyword for a given post.
     *
     * @param WP_Post $post Post object to get its focus keyword.
     *
     * @return string Focus keyword, or empty string if none available.
     */
    protected function get_post_focus_keyword($post)
    {
    }
    /**
     * Gets the score for a given post.
     *
     * @param WP_Post $post Post object to get its score.
     *
     * @return string Score markup, or empty string if none available.
     */
    protected function get_post_score($post)
    {
    }
    /**
     * Gets the current term if in a singular term context.
     *
     * @global string       $pagenow  Current page identifier.
     * @global WP_Query     $wp_query Current query object.
     * @global WP_Term|null $tag      Current term object, or null if none available.
     *
     * @return WP_Term|null Term object, or null if not in singular context.
     */
    protected function get_singular_term()
    {
    }
    /**
     * Gets the score for a given term.
     *
     * @param WP_Term $term Term object to get its score.
     *
     * @return string Score markup, or empty string if none available.
     */
    protected function get_term_score($term)
    {
    }
    /**
     * Create the score icon.
     *
     * @return string The score icon, or empty string.
     */
    protected function get_score_icon()
    {
    }
    /**
     * Gets the URL to the main admin settings page.
     *
     * @return string Admin settings page URL.
     */
    protected function get_settings_page_url()
    {
    }
    /**
     * Gets the notification counter if in a valid context.
     *
     * @return string Notification counter markup, or empty string if not available.
     */
    protected function get_notification_counter()
    {
    }
    /**
     * Gets the notification popup if in a valid context.
     *
     * @return string Notification popup markup, or empty string if not available.
     */
    protected function get_notification_popup()
    {
    }
    /**
     * Checks whether the current user can manage options in the current context.
     *
     * @return bool True if capabilities are sufficient, false otherwise.
     */
    protected function can_manage_options()
    {
    }
    /**
     * Add submenu items to a menu item.
     *
     * @param array        $submenu_items Submenu items array.
     * @param WP_Admin_Bar $wp_admin_bar  Admin bar object.
     * @param string       $parent_id     Parent menu item ID.
     *
     * @return void
     */
    protected function add_submenu_items(array $submenu_items, \WP_Admin_Bar $wp_admin_bar, $parent_id)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO
   */
  /**
   * WPSEO_Custom_Fields.
   */
  class WPSEO_Custom_Fields
  {
    /**
     * Custom fields cache.
     *
     * @var array
     */
    protected static $custom_fields = \null;
    /**
     * Retrieves the custom field names as an array.
     *
     * @link WordPress core: wp-admin/includes/template.php. Reused query from it.
     *
     * @return array The custom fields.
     */
    public static function get_custom_fields()
    {
    }
    /**
     * Adds the cf_ prefix to a field.
     *
     * @param string $field The field to prefix.
     *
     * @return string The prefixed field.
     */
    private static function add_custom_field_prefix($field)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO
   */
  /**
   * WPSEO_Custom_Taxonomies.
   */
  class WPSEO_Custom_Taxonomies
  {
    /**
     * Custom taxonomies cache.
     *
     * @var array
     */
    protected static $custom_taxonomies = \null;
    /**
     * Gets the names of the custom taxonomies, prepends 'ct_' and 'ct_desc', and returns them in an array.
     *
     * @return array The custom taxonomy prefixed names.
     */
    public static function get_custom_taxonomies()
    {
    }
    /**
     * Adds the ct_ prefix to a taxonomy.
     *
     * @param string $taxonomy The taxonomy to prefix.
     *
     * @return string The prefixed taxonomy.
     */
    private static function add_custom_taxonomies_prefix($taxonomy)
    {
    }
    /**
     * Adds the ct_desc_ prefix to a taxonomy.
     *
     * @param string $taxonomy The taxonomy to prefix.
     *
     * @return string The prefixed taxonomy.
     */
    private static function add_custom_taxonomies_description_prefix($taxonomy)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO
   */
  /**
   * WPSEO_Image_Utils.
   */
  class WPSEO_Image_Utils
  {
    /**
     * Find an attachment ID for a given URL.
     *
     * @param string $url The URL to find the attachment for.
     *
     * @return int The found attachment ID, or 0 if none was found.
     */
    public static function get_attachment_by_url($url)
    {
    }
    /**
     * Implements the attachment_url_to_postid with use of WP Cache.
     *
     * @param string $url The attachment URL for which we want to know the Post ID.
     *
     * @return int The Post ID belonging to the attachment, 0 if not found.
     */
    protected static function attachment_url_to_postid($url)
    {
    }
    /**
     * Tries getting the ID of a potentially scaled image.
     *
     * @param string $url The URL of the image.
     *
     * @return int|false The ID of the image or false for failure.
     */
    protected static function get_scaled_image_id($url)
    {
    }
    /**
     * Retrieves the image data.
     *
     * @param array $image         Image array with URL and metadata.
     * @param int   $attachment_id Attachment ID.
     *
     * @return false|array {
     *     Array of image data
     *
     *     @type string $alt      Image's alt text.
     *     @type string $path     Path of image.
     *     @type int    $width    Width of image.
     *     @type int    $height   Height of image.
     *     @type string $type     Image's MIME type.
     *     @type string $size     Image's size.
     *     @type string $url      Image's URL.
     *     @type int    $filesize The file size in bytes, if already set.
     * }
     */
    public static function get_data($image, $attachment_id)
    {
    }
    /**
     * Checks a size version of an image to see if it's not too heavy.
     *
     * @param array $image Image to check the file size of.
     *
     * @return bool True when the image is within limits, false if not.
     */
    public static function has_usable_file_size($image)
    {
    }
    /**
     * Find the right version of an image based on size.
     *
     * @param int          $attachment_id Attachment ID.
     * @param string|array $size     Size name, or array of width and height in pixels (e.g [800,400]).
     *
     * @return array|false Returns an array with image data on success, false on failure.
     */
    public static function get_image($attachment_id, $size)
    {
    }
    /**
     * Returns the image data for the full size image.
     *
     * @param int $attachment_id Attachment ID.
     *
     * @return array|false Array when there is a full size image. False if not.
     */
    protected static function get_full_size_image_data($attachment_id)
    {
    }
    /**
     * Finds the full file path for a given image file.
     *
     * @param string $path The relative file path.
     *
     * @return string The full file path.
     */
    public static function get_absolute_path($path)
    {
    }
    /**
     * Get the relative path of the image.
     *
     * @param string $img Image URL.
     *
     * @return string The expanded image URL.
     */
    public static function get_relative_path($img)
    {
    }
    /**
     * Get the image file size.
     *
     * @param array $image An image array object.
     *
     * @return int The file size in bytes.
     */
    public static function get_file_size($image)
    {
    }
    /**
     * Returns the different image variations for consideration.
     *
     * @param int $attachment_id The attachment to return the variations for.
     *
     * @return array The different variations possible for this attachment ID.
     */
    public static function get_variations($attachment_id)
    {
    }
    /**
     * Check original size of image. If original image is too small, return false, else return true.
     *
     * Filters a list of variations by a certain set of usable dimensions.
     *
     * @param array $usable_dimensions {
     *    The parameters to check against.
     *
     *    @type int    $min_width     Minimum width of image.
     *    @type int    $max_width     Maximum width of image.
     *    @type int    $min_height    Minimum height of image.
     *    @type int    $max_height    Maximum height of image.
     * }
     * @param array $variations        The variations that should be considered.
     *
     * @return array Whether a variation is fit for display or not.
     */
    public static function filter_usable_dimensions($usable_dimensions, $variations)
    {
    }
    /**
     * Filters a list of variations by (disk) file size.
     *
     * @param array $variations The variations to consider.
     *
     * @return array The validations that pass the required file size limits.
     */
    public static function filter_usable_file_size($variations)
    {
    }
    /**
     * Retrieve the internal WP image file sizes.
     *
     * @return array An array of image sizes.
     */
    public static function get_sizes()
    {
    }
    /**
     * Grabs an image alt text.
     *
     * @param int $attachment_id The attachment ID.
     *
     * @return string The image alt text.
     */
    public static function get_alt_tag($attachment_id)
    {
    }
    /**
     * Checks whether an img sizes up to the parameters.
     *
     * @param array $dimensions        The image values.
     * @param array $usable_dimensions The parameters to check against.
     *
     * @return bool True if the image has usable measurements, false if not.
     */
    private static function has_usable_dimensions($dimensions, $usable_dimensions)
    {
    }
    /**
     * Gets the post's first usable content image. Null if none is available.
     *
     * @param int|null $post_id The post id.
     *
     * @return string|null The image URL.
     */
    public static function get_first_usable_content_image_for_post($post_id = \null)
    {
    }
    /**
     * Gets the term's first usable content image. Null if none is available.
     *
     * @param int $term_id The term id.
     *
     * @return string|null The image URL.
     */
    public static function get_first_content_image_for_term($term_id)
    {
    }
    /**
     * Retrieves an attachment ID for an image uploaded in the settings.
     *
     * Due to self::get_attachment_by_url returning 0 instead of false.
     * 0 is also a possibility when no ID is available.
     *
     * @param string $setting The setting the image is stored in.
     *
     * @return int|bool The attachment id, or false or 0 if no ID is available.
     */
    public static function get_attachment_id_from_settings($setting)
    {
    }
    /**
     * Retrieves the first possible image url from an array of images.
     *
     * @param array $images The array to extract image url from.
     *
     * @return string|null The extracted image url when found, null when not found.
     */
    protected static function get_first_image($images)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals
   * @since   3.6
   */
  /**
   * This class checks if the wpseo option doesn't exists. In the case it doesn't it will set a property that is
   * accessible via a method to check if the installation is fresh.
   */
  class WPSEO_Installation
  {
    /**
     * Checks if Yoast SEO is installed for the first time.
     */
    public function __construct()
    {
    }
    /**
     * When the option doesn't exist, it should be a new install.
     *
     * @return bool
     */
    private function is_first_install()
    {
    }
    /**
     * Sets the options on first install for showing the installation notice and disabling of the settings pages.
     */
    public function set_first_install_options()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO
   */
  /**
   * Represents a post's primary term.
   */
  class WPSEO_Primary_Term
  {
    /**
     * Taxonomy name for the term.
     *
     * @var string
     */
    protected $taxonomy_name;
    /**
     * Post ID for the term.
     *
     * @var int
     */
    protected $post_ID;
    /**
     * The taxonomy this term is part of.
     *
     * @param string $taxonomy_name Taxonomy name for the term.
     * @param int    $post_id       Post ID for the term.
     */
    public function __construct($taxonomy_name, $post_id)
    {
    }
    /**
     * Returns the primary term ID.
     *
     * @return int|bool
     */
    public function get_primary_term()
    {
    }
    /**
     * Sets the new primary term ID.
     *
     * @param int $new_primary_term New primary term ID.
     */
    public function set_primary_term($new_primary_term)
    {
    }
    /**
     * Get the terms for the current post ID.
     * When $terms is not an array, set $terms to an array.
     *
     * @return array
     */
    protected function get_terms()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals
   */
  /**
   * Holder for SEO Rank information.
   */
  class WPSEO_Rank
  {
    /**
     * Constant used for determining a bad SEO rating.
     *
     * @var string
     */
    const BAD = 'bad';
    /**
     * Constant used for determining an OK SEO rating.
     *
     * @var string
     */
    const OK = 'ok';
    /**
     * Constant used for determining a good SEO rating.
     *
     * @var string
     */
    const GOOD = 'good';
    /**
     * Constant used for determining that no focus keyphrase is set.
     *
     * @var string
     */
    const NO_FOCUS = 'na';
    /**
     * Constant used for determining that this content is not indexed.
     *
     * @var string
     */
    const NO_INDEX = 'noindex';
    /**
     * All possible ranks.
     *
     * @var array
     */
    protected static $ranks = [self::BAD, self::OK, self::GOOD, self::NO_FOCUS, self::NO_INDEX];
    /**
     * Holds the translation from seo score slug to actual score range.
     *
     * @var array
     */
    protected static $ranges = [self::NO_FOCUS => ['start' => 0, 'end' => 0], self::BAD => ['start' => 1, 'end' => 40], self::OK => ['start' => 41, 'end' => 70], self::GOOD => ['start' => 71, 'end' => 100]];
    /**
     * The current rank.
     *
     * @var int
     */
    protected $rank;
    /**
     * WPSEO_Rank constructor.
     *
     * @param int $rank The actual rank.
     */
    public function __construct($rank)
    {
    }
    /**
     * Returns the saved rank for this rank.
     *
     * @return string
     */
    public function get_rank()
    {
    }
    /**
     * Returns a CSS class for this rank.
     *
     * @return string
     */
    public function get_css_class()
    {
    }
    /**
     * Returns a label for this rank.
     *
     * @return string
     */
    public function get_label()
    {
    }
    /**
     * Returns a label for use in a drop down.
     *
     * @return mixed
     */
    public function get_drop_down_label()
    {
    }
    /**
     * Gets the drop down labels for the readability score.
     *
     * @return string The readability rank label.
     */
    public function get_drop_down_readability_labels()
    {
    }
    /**
     * Get the starting score for this rank.
     *
     * @return int The start score.
     */
    public function get_starting_score()
    {
    }
    /**
     * Get the ending score for this rank.
     *
     * @return int The end score.
     */
    public function get_end_score()
    {
    }
    /**
     * Returns a rank for a specific numeric score.
     *
     * @param int $score The score to determine a rank for.
     *
     * @return self
     */
    public static function from_numeric_score($score)
    {
    }
    /**
     * Returns a list of all possible SEO Ranks.
     *
     * @return WPSEO_Rank[]
     */
    public static function get_all_ranks()
    {
    }
    /**
     * Returns a list of all possible Readability Ranks.
     *
     * @return WPSEO_Rank[]
     */
    public static function get_all_readability_ranks()
    {
    }
    /**
     * Converts a numeric rank into a WPSEO_Rank object, for use in functional array_* functions.
     *
     * @param string $rank SEO Rank.
     *
     * @return WPSEO_Rank
     */
    private static function create_rank($rank)
    {
    }
  }
  /**
   * Class: WPSEO_Replace_Vars.
   *
   * This class implements the replacing of `%%variable_placeholders%%` with their real value based on the current
   * requested page/post/cpt/etc in text strings.
   */
  class WPSEO_Replace_Vars
  {
    /**
     * Default post/page/cpt information.
     *
     * @var array
     */
    protected $defaults = ['ID' => '', 'name' => '', 'post_author' => '', 'post_content' => '', 'post_date' => '', 'post_excerpt' => '', 'post_modified' => '', 'post_title' => '', 'taxonomy' => '', 'term_id' => '', 'term404' => ''];
    /**
     * Current post/page/cpt information.
     *
     * @var stdClass
     */
    protected $args;
    /**
     * Help texts for use in WPSEO -> Search appearance tabs.
     *
     * @var array
     */
    protected static $help_texts = [];
    /**
     * Register of additional variable replacements registered by other plugins/themes.
     *
     * @var array
     */
    protected static $external_replacements = [];
    /**
     * Setup the help texts and external replacements as statics so they will be available to all instances.
     */
    public static function setup_statics_once()
    {
    }
    /**
     * Register new replacement %%variables%%.
     * For use by other plugins/themes to register extra variables.
     *
     * @see wpseo_register_var_replacement() for a usage example.
     *
     * @param string $var_to_replace   The name of the variable to replace, i.e. '%%var%%'.
     *                                 Note: the surrounding %% are optional.
     * @param mixed  $replace_function Function or method to call to retrieve the replacement value for the variable.
     *                                 Uses the same format as add_filter/add_action function parameter and
     *                                 should *return* the replacement value. DON'T echo it.
     * @param string $type             Type of variable: 'basic' or 'advanced', defaults to 'advanced'.
     * @param string $help_text        Help text to be added to the help tab for this variable.
     *
     * @return bool Whether the replacement function was succesfully registered.
     */
    public static function register_replacement($var_to_replace, $replace_function, $type = 'advanced', $help_text = '')
    {
    }
    /**
     * Replace `%%variable_placeholders%%` with their real value based on the current requested page/post/cpt/etc.
     *
     * @param string $text The string to replace the variables in.
     * @param array  $args The object some of the replacement values might come from,
     *                     could be a post, taxonomy or term.
     * @param array  $omit Variables that should not be replaced by this function.
     *
     * @return string
     */
    public function replace($text, $args, $omit = [])
    {
    }
    /**
     * Register a new replacement variable if it has not been registered already.
     *
     * @param string $var_to_replace   The name of the variable to replace, i.e. '%%var%%'.
     *                                 Note: the surrounding %% are optional.
     * @param mixed  $replace_function Function or method to call to retrieve the replacement value for the variable.
     *                                 Uses the same format as add_filter/add_action function parameter and
     *                                 should *return* the replacement value. DON'T echo it.
     * @param string $type             Type of variable: 'basic' or 'advanced', defaults to 'advanced'.
     * @param string $help_text        Help text to be added to the help tab for this variable.
     *
     * @return bool `true` if the replace var has been registered, `false` if not.
     */
    public function safe_register_replacement($var_to_replace, $replace_function, $type = 'advanced', $help_text = '')
    {
    }
    /**
     * Checks whether the given replacement variable has already been registered or not.
     *
     * @param string $replacement_variable The replacement variable to check, including the variable delimiter (e.g. `%%var%%`).
     *
     * @return bool `true` if the replacement variable has already been registered.
     */
    public function has_been_registered($replacement_variable)
    {
    }
    /**
     * Returns the list of hidden replace vars.
     *
     * E.g. the replace vars that should work, but are not advertised.
     *
     * @return string[] The list of hidden replace vars.
     */
    public function get_hidden_replace_vars()
    {
    }
    /**
     * Retrieve the replacements for the variables found.
     *
     * @param array $matches Variables found in the original string - regex result.
     * @param array $omit    Variables that should not be replaced by this function.
     *
     * @return array Retrieved replacements - this might be a smaller array as some variables
     *               may not yield a replacement in certain contexts.
     */
    private function set_up_replacements($matches, $omit)
    {
    }
    /* *********************** BASIC VARIABLES ************************** */
    /**
     * Retrieve the post/cpt categories (comma separated) for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_category()
    {
    }
    /**
     * Retrieve the category description for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_category_description()
    {
    }
    /**
     * Retrieve the date of the post/page/cpt for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_date()
    {
    }
    /**
     * Retrieve the post/page/cpt excerpt for use as replacement string.
     * The excerpt will be auto-generated if it does not exist.
     *
     * @return string|null
     */
    private function retrieve_excerpt()
    {
    }
    /**
     * Retrieve the post/page/cpt excerpt for use as replacement string (without auto-generation).
     *
     * @return string|null
     */
    private function retrieve_excerpt_only()
    {
    }
    /**
     * Retrieve the title of the parent page of the current page/cpt for use as replacement string.
     * Only applicable for hierarchical post types.
     *
     * @todo Check: shouldn't this use $this->args as well ?
     *
     * @return string|null
     */
    private function retrieve_parent_title()
    {
    }
    /**
     * Retrieve the current search phrase for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_searchphrase()
    {
    }
    /**
     * Retrieve the separator for use as replacement string.
     *
     * @return string Retrieves the title separator.
     */
    private function retrieve_sep()
    {
    }
    /**
     * Retrieve the site's tag line / description for use as replacement string.
     *
     * The `$replacement` variable is static because it doesn't change depending
     * on the context. See https://github.com/Yoast/wordpress-seo/pull/1172#issuecomment-46019482.
     *
     * @return string|null
     */
    private function retrieve_sitedesc()
    {
    }
    /**
     * Retrieve the site's name for use as replacement string.
     *
     * The `$replacement` variable is static because it doesn't change depending
     * on the context. See https://github.com/Yoast/wordpress-seo/pull/1172#issuecomment-46019482.
     *
     * @return string|null
     */
    private function retrieve_sitename()
    {
    }
    /**
     * Retrieve the current tag/tags for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_tag()
    {
    }
    /**
     * Retrieve the tag description for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_tag_description()
    {
    }
    /**
     * Retrieve the term description for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_term_description()
    {
    }
    /**
     * Retrieve the term name for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_term_title()
    {
    }
    /**
     * Retrieve the title of the post/page/cpt for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_title()
    {
    }
    /**
     * Retrieve primary category for use as replacement string.
     *
     * @return bool|int|null
     */
    private function retrieve_primary_category()
    {
    }
    /**
     * Retrieve the string generated by get_the_archive_title().
     *
     * @return string|null
     */
    private function retrieve_archive_title()
    {
    }
    /* *********************** ADVANCED VARIABLES ************************** */
    /**
     * Determine the page numbering of the current post/page/cpt.
     *
     * @param string $request Either 'nr'|'max' - whether to return the page number or the max number of pages.
     *
     * @return int|null
     */
    private function determine_pagenumbering($request = 'nr')
    {
    }
    /**
     * Determine the post type names for the current post/page/cpt.
     *
     * @param string $request Either 'single'|'plural' - whether to return the single or plural form.
     *
     * @return string|null
     */
    private function determine_pt_names($request = 'single')
    {
    }
    /**
     * Retrieve the attachment caption for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_caption()
    {
    }
    /**
     * Retrieve a post/page/cpt's custom field value for use as replacement string.
     *
     * @param string $var_to_replace The complete variable to replace which includes the name of
     *                               the custom field which value is to be retrieved.
     *
     * @return string|null
     */
    private function retrieve_cf_custom_field_name($var_to_replace)
    {
    }
    /**
     * Retrieve a post/page/cpt's custom taxonomies for use as replacement string.
     *
     * @param string $var_to_replace The complete variable to replace which includes the name of
     *                               the custom taxonomy which value(s) is to be retrieved.
     * @param bool   $single         Whether to retrieve only the first or all values for the taxonomy.
     *
     * @return string|null
     */
    private function retrieve_ct_custom_tax_name($var_to_replace, $single = \false)
    {
    }
    /**
     * Retrieve a post/page/cpt's custom taxonomies description for use as replacement string.
     *
     * @param string $var_to_replace The complete variable to replace which includes the name of
     *                               the custom taxonomy which description is to be retrieved.
     *
     * @return string|null
     */
    private function retrieve_ct_desc_custom_tax_name($var_to_replace)
    {
    }
    /**
     * Retrieve the current date for use as replacement string.
     *
     * The `$replacement` variable is static because it doesn't change depending
     * on the context. See https://github.com/Yoast/wordpress-seo/pull/1172#issuecomment-46019482.
     *
     * @return string The formatted current date.
     */
    private function retrieve_currentdate()
    {
    }
    /**
     * Retrieve the current day for use as replacement string.
     *
     * The `$replacement` variable is static because it doesn't change depending
     * on the context. See https://github.com/Yoast/wordpress-seo/pull/1172#issuecomment-46019482.
     *
     * @return string The current day.
     */
    private function retrieve_currentday()
    {
    }
    /**
     * Retrieve the current month for use as replacement string.
     *
     * The `$replacement` variable is static because it doesn't change depending
     * on the context. See https://github.com/Yoast/wordpress-seo/pull/1172#issuecomment-46019482.
     *
     * @return string The current month.
     */
    private function retrieve_currentmonth()
    {
    }
    /**
     * Retrieve the current time for use as replacement string.
     *
     * The `$replacement` variable is static because it doesn't change depending
     * on the context. See https://github.com/Yoast/wordpress-seo/pull/1172#issuecomment-46019482.
     *
     * @return string The formatted current time.
     */
    private function retrieve_currenttime()
    {
    }
    /**
     * Retrieve the current year for use as replacement string.
     *
     * The `$replacement` variable is static because it doesn't change depending
     * on the context. See https://github.com/Yoast/wordpress-seo/pull/1172#issuecomment-46019482.
     *
     * @return string The current year.
     */
    private function retrieve_currentyear()
    {
    }
    /**
     * Retrieve the post/page/cpt's focus keyword for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_focuskw()
    {
    }
    /**
     * Retrieve the post/page/cpt ID for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_id()
    {
    }
    /**
     * Retrieve the post/page/cpt modified time for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_modified()
    {
    }
    /**
     * Retrieve the post/page/cpt author's "nice name" for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_name()
    {
    }
    /**
     * Retrieve the post/page/cpt author's users description for use as a replacement string.
     *
     * @return string|null
     */
    private function retrieve_user_description()
    {
    }
    /**
     * Retrieve the current page number with context (i.e. 'page 2 of 4') for use as replacement string.
     *
     * @return string
     */
    private function retrieve_page()
    {
    }
    /**
     * Retrieve the current page number for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_pagenumber()
    {
    }
    /**
     * Retrieve the current page total for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_pagetotal()
    {
    }
    /**
     * Retrieve the post type plural label for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_pt_plural()
    {
    }
    /**
     * Retrieve the post type single label for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_pt_single()
    {
    }
    /**
     * Retrieve the slug which caused the 404 for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_term404()
    {
    }
    /**
     * Retrieve the post/page/cpt author's user id for use as replacement string.
     *
     * @return string
     */
    private function retrieve_userid()
    {
    }
    /**
     * Retrieve the post/page/cpt's published year for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_post_year()
    {
    }
    /**
     * Retrieve the post/page/cpt's published month for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_post_month()
    {
    }
    /**
     * Retrieve the post/page/cpt's published day for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_post_day()
    {
    }
    /**
     * Retrieve the post/page/cpt author's first name for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_author_first_name()
    {
    }
    /**
     * Retrieve the post/page/cpt author's last name for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_author_last_name()
    {
    }
    /**
     * Retrieve the post/page/cpt permalink for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_permalink()
    {
    }
    /**
     * Retrieve the post/page/cpt content for use as replacement string.
     *
     * @return string|null
     */
    private function retrieve_post_content()
    {
    }
    /**
     * Retrieve the current or first category title. To be used for import data from AIOSEO.
     * The code derives from AIOSEO's way of dealing with that var, so we can ensure 100% seamless transition.
     *
     * @return string|null
     */
    private function retrieve_category_title()
    {
    }
    /* *********************** HELP TEXT RELATED ************************** */
    /**
     * Set the help text for a user/plugin/theme defined extra variable.
     *
     * @param string                     $type                 Type of variable: 'basic' or 'advanced'.
     * @param WPSEO_Replacement_Variable $replacement_variable The replacement variable to register.
     */
    private static function register_help_text($type, \WPSEO_Replacement_Variable $replacement_variable)
    {
    }
    /**
     * Generates a list of replacement variables based on the help texts.
     *
     * @return array List of replace vars.
     */
    public function get_replacement_variables_with_labels()
    {
    }
    /**
     * Generates a list of replacement variables based on the help texts.
     *
     * @return array List of replace vars.
     */
    public function get_replacement_variables_list()
    {
    }
    /**
     * Creates a merged associative array of both the basic and advanced help texts.
     *
     * @return array Array with the replacement variables.
     */
    private function get_replacement_variables()
    {
    }
    /**
     * Checks whether the replacement variable contains a `ct_` or `cf_` prefix, because they follow different logic.
     *
     * @param string $replacement_variable The replacement variable.
     *
     * @return bool True when the replacement variable is not prefixed.
     */
    private function is_not_prefixed($replacement_variable)
    {
    }
    /**
     * Strip the prefix from a replacement variable name.
     *
     * @param string $replacement_variable The replacement variable.
     *
     * @return string The replacement variable name without the prefix.
     */
    private function strip_prefix($replacement_variable)
    {
    }
    /**
     * Gets the prefix from a replacement variable name.
     *
     * @param string $replacement_variable The replacement variable.
     *
     * @return string The prefix of the replacement variable.
     */
    private function get_prefix($replacement_variable)
    {
    }
    /**
     * Strips 'desc_' if present, and appends ' description' at the end.
     *
     * @param string $label The replacement variable.
     *
     * @return string The altered replacement variable name.
     */
    private function handle_description($label)
    {
    }
    /**
     * Creates a label for prefixed replacement variables that matches the format in the editors.
     *
     * @param string $replacement_variable The replacement variable.
     *
     * @return string The replacement variable label.
     */
    private function get_label($replacement_variable)
    {
    }
    /**
     * Formats the replacement variables.
     *
     * @param string $replacement_variable The replacement variable to format.
     *
     * @return array The formatted replacement variable.
     */
    private function format_replacement_variable($replacement_variable)
    {
    }
    /**
     * Set/translate the help texts for the WPSEO standard basic variables.
     */
    private static function set_basic_help_texts()
    {
    }
    /**
     * Set/translate the help texts for the WPSEO standard advanced variables.
     */
    private static function set_advanced_help_texts()
    {
    }
    /* *********************** GENERAL HELPER METHODS ************************** */
    /**
     * Remove the '%%' delimiters from a variable string.
     *
     * @param string $text Variable string to be cleaned.
     *
     * @return string
     */
    private static function remove_var_delimiter($text)
    {
    }
    /**
     * Add the '%%' delimiters to a variable string.
     *
     * @param string $text Variable string to be delimited.
     *
     * @return string
     */
    private static function add_var_delimiter($text)
    {
    }
    /**
     * Retrieve a post's terms, comma delimited.
     *
     * @param int    $id            ID of the post to get the terms for.
     * @param string $taxonomy      The taxonomy to get the terms for this post from.
     * @param bool   $return_single If true, return the first term.
     *
     * @return string Either a single term or a comma delimited string of terms.
     */
    public function get_terms($id, $taxonomy, $return_single = \false)
    {
    }
    /**
     * Gets a taxonomy term hierarchy including the term to get the parents for.
     *
     * @return string
     */
    private function get_term_hierarchy()
    {
    }
    /**
     * Retrieves the term ancestors hierarchy.
     *
     * @return string|null The term ancestors hierarchy.
     */
    private function retrieve_term_hierarchy()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals
   * @since   7.7
   */
  /**
   * Class WPSEO_Replacement_Variable.
   *
   * This class stores the data of a single snippet variable.
   */
  class WPSEO_Replacement_Variable
  {
    /**
     * The variable to use.
     *
     * @var string
     */
    protected $variable;
    /**
     * The label of the replacement variable.
     *
     * @var string
     */
    protected $label;
    /**
     * The description of the replacement variable.
     *
     * @var string
     */
    protected $description;
    /**
     * WPSEO_Replacement_Variable constructor.
     *
     * @param string $variable    The variable that is replaced.
     * @param string $label       The label of the replacement variable.
     * @param string $description The description of the replacement variable.
     */
    public function __construct($variable, $label, $description)
    {
    }
    /**
     * Returns the variable to use.
     *
     * @return string
     */
    public function get_variable()
    {
    }
    /**
     * Returns the label of the replacement variable.
     *
     * @return string
     */
    public function get_label()
    {
    }
    /**
     * Returns the description of the replacement variable.
     *
     * @return string
     */
    public function get_description()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO
   */
  /**
   * Helps with creating shortlinks in the plugin.
   */
  class WPSEO_Shortlinker
  {
    /**
     * Collects the additional data necessary for the shortlink.
     *
     * @return array The shortlink data.
     */
    protected function collect_additional_shortlink_data()
    {
    }
    /**
     * Builds a URL to use in the plugin as shortlink.
     *
     * @param string $url The URL to build upon.
     *
     * @return string The final URL.
     */
    public function build_shortlink($url)
    {
    }
    /**
     * Returns a version of the URL with a utm_content with the current version.
     *
     * @param string $url The URL to build upon.
     *
     * @return string The final URL.
     */
    public static function get($url)
    {
    }
    /**
     * Echoes a version of the URL with a utm_content with the current version.
     *
     * @param string $url The URL to build upon.
     */
    public static function show($url)
    {
    }
    /**
     * Gets the shortlink's query params.
     *
     * @return array The shortlink's query params.
     */
    public static function get_query_params()
    {
    }
    /**
     * Gets the current site's PHP version, without the extra info.
     *
     * @return string The PHP version.
     */
    private function get_php_version()
    {
    }
    /**
     * Gets the current site's platform version.
     *
     * @return string The wp_version.
     */
    protected function get_platform_version()
    {
    }
    /**
     * Get our software and whether it's active or not.
     *
     * @return string The software name + activation state.
     */
    private function get_software()
    {
    }
    /**
     * Gets the number of days the plugin has been active.
     *
     * @return int The number of days the plugin is active.
     */
    private function get_days_active()
    {
    }
    /**
     * Gets the user's language.
     *
     * @return string|false The user's language or `false` when it couldn't be retrieved.
     */
    private function get_user_language()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals
   */
  /**
   * Class that generates interesting statistics about things.
   */
  class WPSEO_Statistics
  {
    /**
     * Returns the post count for a certain SEO rank.
     *
     * @todo Merge/DRY this with the logic virtually the same in WPSEO_Metabox::column_sort_orderby().
     *
     * @param WPSEO_Rank $rank The SEO rank to get the post count for.
     *
     * @return int
     */
    public function get_post_count($rank)
    {
    }
  }
  /**
   * Group of utility methods for use by WPSEO.
   * All methods are static, this is just a sort of namespacing class wrapper.
   */
  class WPSEO_Utils
  {
    /**
     * Whether the PHP filter extension is enabled.
     *
     * @since 1.8.0
     *
     * @var bool
     */
    public static $has_filters;
    /**
     * Check whether file editing is allowed for the .htaccess and robots.txt files.
     *
     * {@internal current_user_can() checks internally whether a user is on wp-ms and adjusts accordingly.}}
     *
     * @since 1.8.0
     *
     * @return bool
     */
    public static function allow_system_file_edit()
    {
    }
    /**
     * Check if the web server is running on Apache or compatible (LiteSpeed).
     *
     * @since 1.8.0
     *
     * @return bool
     */
    public static function is_apache()
    {
    }
    /**
     * Check if the web server is running on Nginx.
     *
     * @since 1.8.0
     *
     * @return bool
     */
    public static function is_nginx()
    {
    }
    /**
     * Check whether a url is relative.
     *
     * @since 1.8.0
     *
     * @param string $url URL string to check.
     *
     * @return bool
     */
    public static function is_url_relative($url)
    {
    }
    /**
     * Recursively trim whitespace round a string value or of string values within an array.
     * Only trims strings to avoid typecasting a variable (to string).
     *
     * @since 1.8.0
     *
     * @param mixed $value Value to trim or array of values to trim.
     *
     * @return mixed Trimmed value or array of trimmed values.
     */
    public static function trim_recursive($value)
    {
    }
    /**
     * Emulate the WP native sanitize_text_field function in a %%variable%% safe way.
     *
     * Sanitize a string from user input or from the db.
     *
     * - Check for invalid UTF-8;
     * - Convert single < characters to entity;
     * - Strip all tags;
     * - Remove line breaks, tabs and extra white space;
     * - Strip octets - BUT DO NOT REMOVE (part of) VARIABLES WHICH WILL BE REPLACED.
     *
     * @link https://core.trac.wordpress.org/browser/trunk/src/wp-includes/formatting.php for the original.
     *
     * @since 1.8.0
     *
     * @param string $value String value to sanitize.
     *
     * @return string
     */
    public static function sanitize_text_field($value)
    {
    }
    /**
     * Sanitize a url for saving to the database.
     * Not to be confused with the old native WP function.
     *
     * @since 1.8.0
     *
     * @param string $value             String URL value to sanitize.
     * @param array  $allowed_protocols Optional set of allowed protocols.
     *
     * @return string
     */
    public static function sanitize_url($value, $allowed_protocols = ['http', 'https'])
    {
    }
    /**
     * Decode, sanitize and encode the array of strings or the string.
     *
     * @since 13.3
     *
     * @param array|string $value The value to sanitize and encode.
     *
     * @return array|string The sanitized value.
     */
    public static function sanitize_encoded_text_field($value)
    {
    }
    /**
     * Validate a value as boolean.
     *
     * @since 1.8.0
     *
     * @param mixed $value Value to validate.
     *
     * @return bool
     */
    public static function validate_bool($value)
    {
    }
    /**
     * Cast a value to bool.
     *
     * @since 1.8.0
     *
     * @param mixed $value Value to cast.
     *
     * @return bool
     */
    public static function emulate_filter_bool($value)
    {
    }
    /**
     * Validate a value as integer.
     *
     * @since 1.8.0
     *
     * @param mixed $value Value to validate.
     *
     * @return int|bool Int or false in case of failure to convert to int.
     */
    public static function validate_int($value)
    {
    }
    /**
     * Cast a value to integer.
     *
     * @since 1.8.0
     *
     * @param mixed $value Value to cast.
     *
     * @return int|bool
     */
    public static function emulate_filter_int($value)
    {
    }
    /**
     * Clears the WP or W3TC cache depending on which is used.
     *
     * @since 1.8.0
     */
    public static function clear_cache()
    {
    }
    /**
     * Clear rewrite rules.
     *
     * @since 1.8.0
     */
    public static function clear_rewrites()
    {
    }
    /**
     * Do simple reliable math calculations without the risk of wrong results.
     *
     * In the rare case that the bcmath extension would not be loaded, it will return the normal calculation results.
     *
     * @link http://floating-point-gui.de/
     * @link http://php.net/language.types.float.php See the big red warning.
     *
     * @since 1.5.0
     * @since 1.8.0 Moved from stand-alone function to this class.
     *
     * @param mixed  $number1   Scalar (string/int/float/bool).
     * @param string $action    Calculation action to execute. Valid input:
     *                          '+' or 'add' or 'addition',
     *                          '-' or 'sub' or 'subtract',
     *                          '*' or 'mul' or 'multiply',
     *                          '/' or 'div' or 'divide',
     *                          '%' or 'mod' or 'modulus'
     *                          '=' or 'comp' or 'compare'.
     * @param mixed  $number2   Scalar (string/int/float/bool).
     * @param bool   $round     Whether or not to round the result. Defaults to false.
     *                          Will be disregarded for a compare operation.
     * @param int    $decimals  Decimals for rounding operation. Defaults to 0.
     * @param int    $precision Calculation precision. Defaults to 10.
     *
     * @return mixed Calculation Result or false if either or the numbers isn't scalar or
     *               an invalid operation was passed.
     *               - For compare the result will always be an integer.
     *               - For all other operations, the result will either be an integer (preferred)
     *                 or a float.
     */
    public static function calc($number1, $action, $number2, $round = \false, $decimals = 0, $precision = 10)
    {
    }
    /**
     * Trim whitespace and NBSP (Non-breaking space) from string.
     *
     * @since 2.0.0
     *
     * @param string $text String input to trim.
     *
     * @return string
     */
    public static function trim_nbsp_from_string($text)
    {
    }
    /**
     * Check if a string is a valid datetime.
     *
     * @since 2.0.0
     *
     * @param string $datetime String input to check as valid input for DateTime class.
     *
     * @return bool
     */
    public static function is_valid_datetime($datetime)
    {
    }
    /**
     * Format the URL to be sure it is okay for using as a redirect url.
     *
     * This method will parse the URL and combine them in one string.
     *
     * @since 2.3.0
     *
     * @param string $url URL string.
     *
     * @return mixed
     */
    public static function format_url($url)
    {
    }
    /**
     * Retrieves the sitename.
     *
     * @since 3.0.0
     *
     * @return string
     */
    public static function get_site_name()
    {
    }
    /**
     * Check if the current opened page is a Yoast SEO page.
     *
     * @since 3.0.0
     *
     * @return bool
     */
    public static function is_yoast_seo_page()
    {
    }
    /**
     * Check if the current opened page belongs to Yoast SEO Free.
     *
     * @since 3.3.0
     *
     * @param string $current_page The current page the user is on.
     *
     * @return bool
     */
    public static function is_yoast_seo_free_page($current_page)
    {
    }
    /**
     * Determine if Yoast SEO is in development mode?
     *
     * Inspired by JetPack (https://github.com/Automattic/jetpack/blob/master/class.jetpack.php#L1383-L1406).
     *
     * @since 3.0.0
     *
     * @return bool
     */
    public static function is_development_mode()
    {
    }
    /**
     * Retrieve home URL with proper trailing slash.
     *
     * @since 3.3.0
     *
     * @param string      $path   Path relative to home URL.
     * @param string|null $scheme Scheme to apply.
     *
     * @return string Home URL with optional path, appropriately slashed if not.
     */
    public static function home_url($path = '', $scheme = \null)
    {
    }
    /**
     * Checks if the WP-REST-API is available.
     *
     * @since 3.6
     * @since 3.7 Introduced the $minimum_version parameter.
     *
     * @param string $minimum_version The minimum version the API should be.
     *
     * @return bool Returns true if the API is available.
     */
    public static function is_api_available($minimum_version = '2.0')
    {
    }
    /**
     * Determine whether or not the metabox should be displayed for a post type.
     *
     * @param string|null $post_type Optional. The post type to check the visibility of the metabox for.
     *
     * @return bool Whether or not the metabox should be displayed.
     */
    protected static function display_post_type_metabox($post_type = \null)
    {
    }
    /**
     * Determine whether or not the metabox should be displayed for a taxonomy.
     *
     * @param string|null $taxonomy Optional. The post type to check the visibility of the metabox for.
     *
     * @return bool Whether or not the metabox should be displayed.
     */
    protected static function display_taxonomy_metabox($taxonomy = \null)
    {
    }
    /**
     * Determines whether the metabox is active for the given identifier and type.
     *
     * @param string $identifier The identifier to check for.
     * @param string $type       The type to check for.
     *
     * @return bool Whether or not the metabox is active.
     */
    public static function is_metabox_active($identifier, $type)
    {
    }
    /**
     * Determines whether the plugin is active for the entire network.
     *
     * @return bool Whether the plugin is network-active.
     */
    public static function is_plugin_network_active()
    {
    }
    /**
     * Gets the type of the current post.
     *
     * @return string The post type, or an empty string.
     */
    public static function get_post_type()
    {
    }
    /**
     * Gets the type of the current page.
     *
     * @return string Returns 'post' if the current page is a post edit page. Taxonomy in other cases.
     */
    public static function get_page_type()
    {
    }
    /**
     * Getter for the Adminl10n array. Applies the wpseo_admin_l10n filter.
     *
     * @return array The Adminl10n array.
     */
    public static function get_admin_l10n()
    {
    }
    /**
     * Retrieves the analysis worker log level. Defaults to errors only.
     *
     * Uses bool YOAST_SEO_DEBUG as flag to enable logging. Off equals ERROR.
     * Uses string YOAST_SEO_DEBUG_ANALYSIS_WORKER as log level for the Analysis
     * Worker. Defaults to INFO.
     * Can be: TRACE, DEBUG, INFO, WARN or ERROR.
     *
     * @return string The log level to use.
     */
    public static function get_analysis_worker_log_level()
    {
    }
    /**
     * Returns the unfiltered home URL.
     *
     * In case WPML is installed, returns the original home_url and not the WPML version.
     * In case of a multisite setup we return the network_home_url.
     *
     * @codeCoverageIgnore
     *
     * @return string The home url.
     */
    public static function get_home_url()
    {
    }
    /**
     * Prepares data for outputting as JSON.
     *
     * @param array $data The data to format.
     *
     * @return false|string The prepared JSON string.
     */
    public static function format_json_encode($data)
    {
    }
    /**
     * Extends the allowed post tags with accessibility-related attributes.
     *
     * @codeCoverageIgnore
     *
     * @param array $allowed_post_tags The allowed post tags.
     *
     * @return array The allowed tags including post tags, input tags and select tags.
     */
    public static function extend_kses_post_with_a11y($allowed_post_tags)
    {
    }
    /**
     * Extends the allowed post tags with input, select and option tags.
     *
     * @codeCoverageIgnore
     *
     * @param array $allowed_post_tags The allowed post tags.
     *
     * @return array The allowed tags including post tags, input tags, select tags and option tags.
     */
    public static function extend_kses_post_with_forms($allowed_post_tags)
    {
    }
    /**
     * Gets an array of enabled features.
     *
     * @return string[] The array of enabled features.
     */
    public static function retrieve_enabled_features()
    {
    }
    /* ********************* DEPRECATED METHODS ********************* */
    /**
     * Translates a decimal analysis score into a textual one.
     *
     * @since 1.8.0
     * @deprecated 19.5
     * @codeCoverageIgnore
     *
     * @param int  $val       The decimal score to translate.
     * @param bool $css_value Whether to return the i18n translated score or the CSS class value.
     *
     * @return string
     */
    public static function translate_score($val, $css_value = \true)
    {
    }
  }
  /**
   * Date helper class.
   *
   * @package WPSEO\Internals
   */
  /**
   * Class WPSEO_Date_Helper
   *
   * Note: Move this class with namespace to the src/helpers directory and add a class_alias for BC.
   */
  class WPSEO_Date_Helper
  {
    /**
     * Formats a given date in UTC TimeZone format.
     *
     * @param string $date   String representing the date / time.
     * @param string $format The format that the passed date should be in.
     *
     * @return string The formatted date.
     */
    public function format($date, $format = \DATE_W3C)
    {
    }
    /**
     * Formats the given timestamp to the needed format.
     *
     * @param int    $timestamp The timestamp to use for the formatting.
     * @param string $format    The format that the passed date should be in.
     *
     * @return string The formatted date.
     */
    public function format_timestamp($timestamp, $format = \DATE_W3C)
    {
    }
    /**
     * Formats a given date in UTC TimeZone format and translate it to the set language.
     *
     * @param string $date   String representing the date / time.
     * @param string $format The format that the passed date should be in.
     *
     * @return string The formatted and translated date.
     */
    public function format_translated($date, $format = \DATE_W3C)
    {
    }
    /**
     * Check if a string is a valid datetime.
     *
     * @param string $datetime String input to check as valid input for DateTime class.
     *
     * @return bool True when datatime is valid.
     */
    public function is_valid_datetime($datetime)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals
   */
  /**
   * Class WPSEO_MyYoast_Bad_Request_Exception.
   */
  class WPSEO_MyYoast_Bad_Request_Exception extends \Exception
  {
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals
   * @since   5.9.0
   */
  /**
   * Group of language utility methods for use by WPSEO.
   * All methods are static, this is just a sort of namespacing class wrapper.
   */
  class WPSEO_Language_Utils
  {
    /**
     * Returns the language part of a given locale, defaults to english when the $locale is empty.
     *
     * @param string|null $locale The locale to get the language of.
     *
     * @return string The language part of the locale.
     */
    public static function get_language($locale = \null)
    {
    }
    /**
     * Returns the full name for the sites' language.
     *
     * @return string The language name.
     */
    public static function get_site_language_name()
    {
    }
    /**
     * Returns the l10n array for the knowledge graph company info missing.
     *
     * @deprecated 20.3
     * @codeCoverageIgnore
     *
     * @return array The l10n array.
     */
    public static function get_knowledge_graph_company_info_missing_l10n()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals\Options
   */
  /**
   * This abstract class and it's concrete classes implement defaults and value validation for
   * all WPSEO options and subkeys within options.
   *
   * Some guidelines:
   * [Retrieving options]
   * - Use the normal get_option() to retrieve an option. You will receive a complete array for the option.
   *   Any subkeys which were not set, will have their default values in place.
   * - In other words, you will normally not have to check whether a subkey isset() as they will *always* be set.
   *   They will also *always* be of the correct variable type.
   *   The only exception to this are the options with variable option names based on post_type or taxonomy
   *   as those will not always be available before the taxonomy/post_type is registered.
   *   (they will be available if a value was set, they won't be if it wasn't as the class won't know
   *   that a default needs to be injected).
   *
   * [Updating/Adding options]
   * - For multisite site_options, please use the WPSEO_Options::update_site_option() method.
   * - For normal options, use the normal add/update_option() functions. As long a the classes here
   *   are instantiated, validation for all options and their subkeys will be automatic.
   * - On (succesfull) update of a couple of options, certain related actions will be run automatically.
   *   Some examples:
   *   - on change of wpseo[yoast_tracking], the cron schedule will be adjusted accordingly
   *   - on change of wpseo and wpseo_title, some caches will be cleared
   *
   * [Important information about add/updating/changing these classes]
   * - Make sure that option array key names are unique across options. The WPSEO_Options::get_all()
   *   method merges most options together. If any of them have non-unique names, even if they
   *   are in a different option, they *will* overwrite each other.
   * - When you add a new array key in an option: make sure you add proper defaults and add the key
   *   to the validation routine in the proper place or add a new validation case.
   *   You don't need to do any upgrading as any option returned will always be merged with the
   *   defaults, so new options will automatically be available.
   *   If the default value is a string which need translating, add this to the concrete class
   *   translate_defaults() method.
   * - When you remove an array key from an option: if it's important that the option is really removed,
   *   add the WPSEO_Option::clean_up( $option_name ) method to the upgrade run.
   *   This will re-save the option and automatically remove the array key no longer in existance.
   * - When you rename a sub-option: add it to the clean_option() routine and run that in the upgrade run.
   * - When you change the default for an option sub-key, make sure you verify that the validation routine will
   *   still work the way it should.
   *   Example: changing a default from '' (empty string) to 'text' with a validation routine with tests
   *   for an empty string will prevent a user from saving an empty string as the real value. So the
   *   test for '' with the validation routine would have to be removed in that case.
   * - If an option needs specific actions different from defined in this abstract class, you can just overrule
   *   a method by defining it in the concrete class.
   *
   * @todo [JRF => testers] Double check that validation will not cause errors when called
   *       from upgrade routine (some of the WP functions may not yet be available).
   */
  abstract class WPSEO_Option
  {
    /**
     * Prefix for override option keys that allow or disallow the option key of the same name.
     *
     * @var string
     */
    const ALLOW_KEY_PREFIX = 'allow_';
    /**
     * Option name - MUST be set in concrete class and set to public.
     *
     * @var string
     */
    protected $option_name;
    /**
     * Option group name for use in settings forms.
     *
     * Will be set automagically if not set in concrete class (i.e.
     * if it confirm to the normal pattern 'yoast' . $option_name . 'options',
     * only set in conrete class if it doesn't).
     *
     * @var string
     */
    public $group_name;
    /**
     * Whether to include the option in the return for WPSEO_Options::get_all().
     *
     * Also determines which options are copied over for ms_(re)set_blog().
     *
     * @var bool
     */
    public $include_in_all = \true;
    /**
     * Whether this option is only for when the install is multisite.
     *
     * @var bool
     */
    public $multisite_only = \false;
    /**
     * Array of defaults for the option - MUST be set in concrete class.
     *
     * Shouldn't be requested directly, use $this->get_defaults();
     *
     * @var array
     */
    protected $defaults;
    /**
     * Array of variable option name patterns for the option - if any -.
     *
     * Set this when the option contains array keys which vary based on post_type
     * or taxonomy.
     *
     * @var array
     */
    protected $variable_array_key_patterns;
    /**
     * Array of sub-options which should not be overloaded with multi-site defaults.
     *
     * @var array
     */
    public $ms_exclude = [];
    /**
     * Name for an option higher in the hierarchy to override setting access.
     *
     * @var string
     */
    protected $override_option_name;
    /**
     * Instance of this class.
     *
     * @var WPSEO_Option
     */
    protected static $instance;
    /* *********** INSTANTIATION METHODS *********** */
    /**
     * Add all the actions and filters for the option.
     */
    protected function __construct()
    {
    }
    /*
         * All concrete classes *must* contain the get_instance method.
         *
         * {@internal Unfortunately I can't define it as an abstract as it also *has* to be static...}}
         *
         * ```
         * abstract protected static function get_instance();
         * ```
         * ---------------
         *
         * Concrete classes *may* contain a translate_defaults method.
         * ```
         * abstract public function translate_defaults();
         * ```
         * ---------------
         *
         * Concrete classes *may* contain a enrich_defaults method to add additional defaults once
         * all post_types and taxonomies have been registered.
         *
         * ```
         * abstract public function enrich_defaults();
         * ```
         */
    /* *********** METHODS INFLUENCING get_option() *********** */
    /**
     * Add filters to make sure that the option default is returned if the option is not set.
     *
     * @return void
     */
    public function add_default_filters()
    {
    }
    /**
     * Adds back the default filters that were removed during validation if the option was changed.
     * Checks if this option was changed to prevent constantly checking if filters are present.
     *
     * @param string $option_name The option name.
     *
     * @return void
     */
    public function add_default_filters_if_same_option($option_name)
    {
    }
    /**
     * Adds back the default filters that were removed during validation if the option was not changed.
     * This is because in that case the latter actions are not called and thus the filters are never
     * added back.
     *
     * @param mixed  $value       The current value.
     * @param string $option_name The option name.
     * @param mixed  $old_value   The old value.
     *
     * @return string The current value.
     */
    public function add_default_filters_if_not_changed($value, $option_name, $old_value)
    {
    }
    /**
     * Validate webmaster tools & Pinterest verification strings.
     *
     * @param string $key   Key to check, by type of service.
     * @param array  $dirty Dirty data with the new values.
     * @param array  $old   Old data.
     * @param array  $clean Clean data by reference, normally the default values.
     */
    public function validate_verification_string($key, $dirty, $old, &$clean)
    {
    }
    /**
     * Validates an option as a valid URL. Prints out a WordPress settings error
     * notice if the URL is invalid.
     *
     * @param string $key   Key to check, by type of URL setting.
     * @param array  $dirty Dirty data with the new values.
     * @param array  $old   Old data.
     * @param array  $clean Clean data by reference, normally the default values.
     */
    public function validate_url($key, $dirty, $old, &$clean)
    {
    }
    /**
     * Remove the default filters.
     * Called from the validate() method to prevent failure to add new options.
     *
     * @return void
     */
    public function remove_default_filters()
    {
    }
    /**
     * Get the enriched default value for an option.
     *
     * Checks if the concrete class contains an enrich_defaults() method and if so, runs it.
     *
     * {@internal The enrich_defaults method is used to set defaults for variable array keys
     *            in an option, such as array keys depending on post_types and/or taxonomies.}}
     *
     * @return array
     */
    public function get_defaults()
    {
    }
    /**
     * Add filters to make sure that the option is merged with its defaults before being returned.
     *
     * @return void
     */
    public function add_option_filters()
    {
    }
    /**
     * Remove the option filters.
     * Called from the clean_up methods to make sure we retrieve the original old option.
     *
     * @return void
     */
    public function remove_option_filters()
    {
    }
    /**
     * Merge an option with its default values.
     *
     * This method should *not* be called directly!!! It is only meant to filter the get_option() results.
     *
     * @param mixed $options Option value.
     *
     * @return mixed Option merged with the defaults for that option.
     */
    public function get_option($options = \null)
    {
    }
    /* *********** METHODS influencing add_uption(), update_option() and saving from admin pages. *********** */
    /**
     * Register (whitelist) the option for the configuration pages.
     * The validation callback is already registered separately on the sanitize_option hook,
     * so no need to double register.
     *
     * @return void
     */
    public function register_setting()
    {
    }
    /**
     * Validate the option
     *
     * @param mixed $option_value The unvalidated new value for the option.
     *
     * @return array Validated new value for the option.
     */
    public function validate($option_value)
    {
    }
    /**
     * Checks whether a specific option key is disabled.
     *
     * This is determined by whether an override option is available with a key that equals the given key prefixed
     * with 'allow_'.
     *
     * @param string $key Option key.
     *
     * @return bool True if option key is disabled, false otherwise.
     */
    public function is_disabled($key)
    {
    }
    /**
     * All concrete classes must contain a validate_option() method which validates all
     * values within the option.
     *
     * @param array $dirty New value for the option.
     * @param array $clean Clean value for the option, normally the defaults.
     * @param array $old   Old value of the option.
     */
    protected abstract function validate_option($dirty, $clean, $old);
    /* *********** METHODS for ADDING/UPDATING/UPGRADING the option. *********** */
    /**
     * Retrieve the real old value (unmerged with defaults).
     *
     * @return array|bool The original option value (which can be false if the option doesn't exist).
     */
    protected function get_original_option()
    {
    }
    /**
     * Add the option if it doesn't exist for some strange reason.
     *
     * @uses WPSEO_Option::get_original_option()
     *
     * @return void
     */
    public function maybe_add_option()
    {
    }
    /**
     * Update a site_option.
     *
     * {@internal This special method is only needed for multisite options, but very needed indeed there.
     *            The order in which certain functions and hooks are run is different between
     *            get_option() and get_site_option() which means in practice that the removing
     *            of the default filters would be done too late and the re-adding of the default
     *            filters might not be done at all.
     *            Aka: use the WPSEO_Options::update_site_option() method (which calls this method)
     *            for safely adding/updating multisite options.}}
     *
     * @param mixed $value The new value for the option.
     *
     * @return bool Whether the update was succesfull.
     */
    public function update_site_option($value)
    {
    }
    /**
     * Retrieve the real old value (unmerged with defaults), clean and re-save the option.
     *
     * @uses WPSEO_Option::get_original_option()
     * @uses WPSEO_Option::import()
     *
     * @param string|null $current_version Optional. Version from which to upgrade, if not set,
     *                                     version specific upgrades will be disregarded.
     *
     * @return void
     */
    public function clean($current_version = \null)
    {
    }
    /**
     * Clean and re-save the option.
     *
     * @uses clean_option() method from concrete class if it exists.
     *
     * @todo [JRF/whomever] Figure out a way to show settings error during/after the upgrade - maybe
     * something along the lines of:
     * -> add them to a property in this class
     * -> if that property isset at the end of the routine and add_settings_error function does not exist,
     *    save as transient (or update the transient if one already exists)
     * -> next time an admin is in the WP back-end, show the errors and delete the transient or only delete it
     *    once the admin has dismissed the message (add ajax function)
     * Important: all validation routines which add_settings_errors would need to be changed for this to work
     *
     * @param array       $option_value          Option value to be imported.
     * @param string|null $current_version       Optional. Version from which to upgrade, if not set,
     *                                           version specific upgrades will be disregarded.
     * @param array|null  $all_old_option_values Optional. Only used when importing old options to
     *                                           have access to the real old values, in contrast to
     *                                           the saved ones.
     *
     * @return void
     */
    public function import($option_value, $current_version = \null, $all_old_option_values = \null)
    {
    }
    /**
     * Returns the variable array key patterns for an options class.
     *
     * @return array
     */
    public function get_patterns()
    {
    }
    /**
     * Retrieves the option name.
     *
     * @return string The set option name.
     */
    public function get_option_name()
    {
    }
    /*
         * Concrete classes *may* contain a clean_option method which will clean out old/renamed
         * values within the option.
         *
         * ```
         * abstract public function clean_option( $option_value, $current_version = null, $all_old_option_values = null );
         * ```
         */
    /* *********** HELPER METHODS for internal use. *********** */
    /**
     * Helper method - Combines a fixed array of default values with an options array
     * while filtering out any keys which are not in the defaults array.
     *
     * @todo [JRF] - shouldn't this be a straight array merge ? at the end of the day, the validation
     * removes any invalid keys on save.
     *
     * @param array|null $options Optional. Current options. If not set, the option defaults
     *                            for the $option_key will be returned.
     *
     * @return array Combined and filtered options array.
     */
    protected function array_filter_merge($options = \null)
    {
    }
    /**
     * Sets updated values for variables that are disabled via the override option back to their previous values.
     *
     * @param array $updated Updated option value.
     * @param array $old     Old option value.
     *
     * @return array Updated option value, with all disabled variables set to their old values.
     */
    protected function prevent_disabled_options_update($updated, $old)
    {
    }
    /**
     * Retrieves the value of the override option, if available.
     *
     * An override option contains values that may determine access to certain sub-variables
     * of this option.
     *
     * Only regular options in multisite can have override options, which in that case
     * would be network options.
     *
     * @return array Override option value, or empty array if unavailable.
     */
    protected function get_override_option()
    {
    }
    /**
     * Make sure that any set option values relating to post_types and/or taxonomies are retained,
     * even when that post_type or taxonomy may not yet have been registered.
     *
     * {@internal The wpseo_titles concrete class overrules this method. Make sure that any
     *            changes applied here, also get ported to that version.}}
     *
     * @param array $dirty Original option as retrieved from the database.
     * @param array $clean Filtered option where any options which shouldn't be in our option
     *                     have already been removed and any options which weren't set
     *                     have been set to their defaults.
     *
     * @return array
     */
    protected function retain_variable_keys($dirty, $clean)
    {
    }
    /**
     * Check whether a given array key conforms to one of the variable array key patterns for this option.
     *
     * @usedby validate_option() methods for options with variable array keys.
     *
     * @param string $key Array key to check.
     *
     * @return string Pattern if it conforms, original array key if it doesn't or if the option
     *                does not have variable array keys.
     */
    protected function get_switch_key($key)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals\Options
   */
  /**
   * Site option for Multisite installs only
   *
   * Overloads a number of methods of the abstract class to ensure the use of the correct site_option
   * WP functions.
   */
  class WPSEO_Option_MS extends \WPSEO_Option
  {
    /**
     * Option name.
     *
     * @var string
     */
    public $option_name = 'wpseo_ms';
    /**
     * Option group name for use in settings forms.
     *
     * @var string
     */
    public $group_name = 'yoast_wpseo_multisite_options';
    /**
     * Whether to include the option in the return for WPSEO_Options::get_all().
     *
     * @var bool
     */
    public $include_in_all = \false;
    /**
     * Whether this option is only for when the install is multisite.
     *
     * @var bool
     */
    public $multisite_only = \true;
    /**
     * Array of defaults for the option.
     *
     * Shouldn't be requested directly, use $this->get_defaults();
     *
     * @var array
     */
    protected $defaults = [];
    /**
     * Available options for the 'access' setting. Used for input validation.
     *
     * {@internal Important: Make sure the options added to the array here are in line
     *            with the keys for the options set for the select box in the
     *            admin/pages/network.php file.}}
     *
     * @var array
     */
    public static $allowed_access_options = ['admin', 'superadmin'];
    /**
     * Get the singleton instance of this class.
     *
     * @return object
     */
    public static function get_instance()
    {
    }
    /**
     * Only run parent constructor in multisite context.
     */
    public function __construct()
    {
    }
    /**
     * Add filters to make sure that the option default is returned if the option is not set
     *
     * @return void
     */
    public function add_default_filters()
    {
    }
    /**
     * Remove the default filters.
     * Called from the validate() method to prevent failure to add new options.
     *
     * @return void
     */
    public function remove_default_filters()
    {
    }
    /**
     * Add filters to make sure that the option is merged with its defaults before being returned.
     *
     * @return void
     */
    public function add_option_filters()
    {
    }
    /**
     * Remove the option filters.
     * Called from the clean_up methods to make sure we retrieve the original old option.
     *
     * @return void
     */
    public function remove_option_filters()
    {
    }
    /* *********** METHODS influencing add_uption(), update_option() and saving from admin pages *********** */
    /**
     * Validate the option.
     *
     * @param array $dirty New value for the option.
     * @param array $clean Clean value for the option, normally the defaults.
     * @param array $old   Old value of the option.
     *
     * @return array Validated clean value for the option to be saved to the database.
     */
    protected function validate_option($dirty, $clean, $old)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals\Options
   */
  /**
   * Option: wpseo_social.
   */
  class WPSEO_Option_Social extends \WPSEO_Option
  {
    /**
     * Option name.
     *
     * @var string
     */
    public $option_name = 'wpseo_social';
    /**
     * Array of defaults for the option.
     *
     * Shouldn't be requested directly, use $this->get_defaults();
     *
     * @var array
     */
    protected $defaults = [
      // Form fields.
      'facebook_site' => '',
      // Text field.
      'instagram_url' => '',
      'linkedin_url' => '',
      'myspace_url' => '',
      'og_default_image' => '',
      // Text field.
      'og_default_image_id' => '',
      'og_frontpage_title' => '',
      // Text field.
      'og_frontpage_desc' => '',
      // Text field.
      'og_frontpage_image' => '',
      // Text field.
      'og_frontpage_image_id' => '',
      'opengraph' => \true,
      'pinterest_url' => '',
      'pinterestverify' => '',
      'twitter' => \true,
      'twitter_site' => '',
      // Text field.
      'twitter_card_type' => 'summary_large_image',
      'youtube_url' => '',
      'wikipedia_url' => '',
      'other_social_urls' => [],
      'mastodon_url' => '',
    ];
    /**
     * Array of sub-options which should not be overloaded with multi-site defaults.
     *
     * @var array
     */
    public $ms_exclude = [
      /* Privacy. */
      'pinterestverify',
    ];
    /**
     * Array of allowed twitter card types.
     *
     * While we only have the options summary and summary_large_image in the
     * interface now, we might change that at some point.
     *
     * {@internal Uncomment any of these to allow them in validation *and* automatically
     *            add them as a choice in the options page.}}
     *
     * @var array
     */
    public static $twitter_card_types = ['summary_large_image' => ''];
    /**
     * Add the actions and filters for the option.
     */
    protected function __construct()
    {
    }
    /**
     * Get the singleton instance of this class.
     *
     * @return object
     */
    public static function get_instance()
    {
    }
    /**
     * Translate/set strings used in the option defaults.
     *
     * @return void
     */
    public function translate_defaults()
    {
    }
    /**
     * Validate the option.
     *
     * @param array $dirty New value for the option.
     * @param array $clean Clean value for the option, normally the defaults.
     * @param array $old   Old value of the option.
     *
     * @return array Validated clean value for the option to be saved to the database.
     */
    protected function validate_option($dirty, $clean, $old)
    {
    }
    /**
     * Validates a social URL.
     *
     * @param string $url The url to be validated.
     *
     * @return string|false The validated URL or false if the URL is not valid.
     */
    public function validate_social_url($url)
    {
    }
    /**
     * Validates a twitter id.
     *
     * @param string $twitter_id    The twitter id to be validated.
     * @param bool   $strip_at_sign Whether or not to strip the `@` sign.
     *
     * @return string|false The validated twitter id or false if it is not valid.
     */
    public function validate_twitter_id($twitter_id, $strip_at_sign = \true)
    {
    }
    /**
     * Clean a given option value.
     *
     * @param array       $option_value          Old (not merged with defaults or filtered) option value to
     *                                           clean according to the rules for this option.
     * @param string|null $current_version       Optional. Version from which to upgrade, if not set,
     *                                           version specific upgrades will be disregarded.
     * @param array|null  $all_old_option_values Optional. Only used when importing old options to have
     *                                           access to the real old values, in contrast to the saved ones.
     *
     * @return array Cleaned option.
     */
    protected function clean_option($option_value, $current_version = \null, $all_old_option_values = \null)
    {
    }
  }
  /**
   * Option: wpseo_titles.
   */
  class WPSEO_Option_Titles extends \WPSEO_Option
  {
    /**
     * Option name.
     *
     * @var string
     */
    public $option_name = 'wpseo_titles';
    /**
     * Array of defaults for the option.
     *
     * Shouldn't be requested directly, use $this->get_defaults();
     *
     * {@internal Note: Some of the default values are added via the translate_defaults() method.}}
     *
     * @var array
     */
    protected $defaults = [
      // Form fields.
      'forcerewritetitle' => \false,
      'separator' => 'sc-dash',
      'title-home-wpseo' => '%%sitename%% %%page%% %%sep%% %%sitedesc%%',
      // Text field.
      'title-author-wpseo' => '',
      // Text field.
      'title-archive-wpseo' => '%%date%% %%page%% %%sep%% %%sitename%%',
      // Text field.
      'title-search-wpseo' => '',
      // Text field.
      'title-404-wpseo' => '',
      // Text field.
      'social-title-author-wpseo' => '%%name%%',
      // Text field.
      'social-title-archive-wpseo' => '%%date%%',
      // Text field.
      'social-description-author-wpseo' => '',
      // Text area.
      'social-description-archive-wpseo' => '',
      // Text area.
      'social-image-url-author-wpseo' => '',
      // Hidden input field.
      'social-image-url-archive-wpseo' => '',
      // Hidden input field.
      'social-image-id-author-wpseo' => 0,
      // Hidden input field.
      'social-image-id-archive-wpseo' => 0,
      // Hidden input field.
      'metadesc-home-wpseo' => '',
      // Text area.
      'metadesc-author-wpseo' => '',
      // Text area.
      'metadesc-archive-wpseo' => '',
      // Text area.
      'rssbefore' => '',
      // Text area.
      'rssafter' => '',
      // Text area.
      'noindex-author-wpseo' => \false,
      'noindex-author-noposts-wpseo' => \true,
      'noindex-archive-wpseo' => \true,
      'disable-author' => \false,
      'disable-date' => \false,
      'disable-post_format' => \false,
      'disable-attachment' => \true,
      'breadcrumbs-404crumb' => '',
      // Text field.
      'breadcrumbs-display-blog-page' => \true,
      'breadcrumbs-boldlast' => \false,
      'breadcrumbs-archiveprefix' => '',
      // Text field.
      'breadcrumbs-enable' => \true,
      'breadcrumbs-home' => '',
      // Text field.
      'breadcrumbs-prefix' => '',
      // Text field.
      'breadcrumbs-searchprefix' => '',
      // Text field.
      'breadcrumbs-sep' => '»',
      // Text field.
      'website_name' => '',
      'person_name' => '',
      'person_logo' => '',
      'person_logo_id' => 0,
      'alternate_website_name' => '',
      'company_logo' => '',
      'company_logo_id' => 0,
      'company_logo_meta' => \false,
      'person_logo_meta' => \false,
      'company_name' => '',
      'company_alternate_name' => '',
      'company_or_person' => 'company',
      'company_or_person_user_id' => \false,
      'stripcategorybase' => \false,
      'open_graph_frontpage_title' => '%%sitename%%',
      // Text field.
      'open_graph_frontpage_desc' => '',
      // Text field.
      'open_graph_frontpage_image' => '',
      // Text field.
      'open_graph_frontpage_image_id' => 0,
    ];
    /**
     * Used for "caching" during pageload.
     *
     * @var array
     */
    protected $enriched_defaults = \null;
    /**
     * Array of variable option name patterns for the option.
     *
     * @var array
     */
    protected $variable_array_key_patterns = ['title-', 'metadesc-', 'noindex-', 'display-metabox-pt-', 'bctitle-ptarchive-', 'post_types-', 'taxonomy-', 'schema-page-type-', 'schema-article-type-', 'social-title-', 'social-description-', 'social-image-url-', 'social-image-id-'];
    /**
     * Array of sub-options which should not be overloaded with multi-site defaults.
     *
     * @var array
     */
    public $ms_exclude = ['forcerewritetitle'];
    /**
     * Add the actions and filters for the option.
     *
     * @todo [JRF => testers] Check if the extra actions below would run into problems if an option
     * is updated early on and if so, change the call to schedule these for a later action on add/update
     * instead of running them straight away.
     */
    protected function __construct()
    {
    }
    /**
     * Make sure we can recognize the right action for the double cleaning.
     */
    public function end_of_init()
    {
    }
    /**
     * Get the singleton instance of this class.
     *
     * @return self
     */
    public static function get_instance()
    {
    }
    /**
     * Get the available separator options.
     *
     * @return array
     */
    public function get_separator_options()
    {
    }
    /**
     * Get the available separator options aria-labels.
     *
     * @return array Array with the separator options aria-labels.
     */
    public function get_separator_options_for_display()
    {
    }
    /**
     * Translate strings used in the option defaults.
     *
     * @return void
     */
    public function translate_defaults()
    {
    }
    /**
     * Add dynamically created default options based on available post types and taxonomies.
     *
     * @return  void
     */
    public function enrich_defaults()
    {
    }
    /**
     * Invalidates enrich_defaults() cache.
     *
     * Called from actions:
     * - (un)registered_post_type
     * - (un)registered_taxonomy
     *
     * @return void
     */
    public function invalidate_enrich_defaults_cache()
    {
    }
    /**
     * Validate the option.
     *
     * @param array $dirty New value for the option.
     * @param array $clean Clean value for the option, normally the defaults.
     * @param array $old   Old value of the option.
     *
     * @return array Validated clean value for the option to be saved to the database.
     */
    protected function validate_option($dirty, $clean, $old)
    {
    }
    /**
     * Retrieve a list of the allowed post types as breadcrumb parent for a taxonomy.
     * Helper method for validation.
     *
     * {@internal Don't make static as new types may still be registered.}}
     *
     * @return array
     */
    protected function get_allowed_post_types()
    {
    }
    /**
     * Clean a given option value.
     *
     * @param array       $option_value          Old (not merged with defaults or filtered) option value to
     *                                           clean according to the rules for this option.
     * @param string|null $current_version       Optional. Version from which to upgrade, if not set,
     *                                           version specific upgrades will be disregarded.
     * @param array|null  $all_old_option_values Optional. Only used when importing old options to have
     *                                           access to the real old values, in contrast to the saved ones.
     *
     * @return array Cleaned option.
     */
    protected function clean_option($option_value, $current_version = \null, $all_old_option_values = \null)
    {
    }
    /**
     * Make sure that any set option values relating to post_types and/or taxonomies are retained,
     * even when that post_type or taxonomy may not yet have been registered.
     *
     * {@internal Overrule the abstract class version of this to make sure one extra renamed
     *            variable key does not get removed. IMPORTANT: keep this method in line with
     *            the parent on which it is based!}}
     *
     * @param array $dirty Original option as retrieved from the database.
     * @param array $clean Filtered option where any options which shouldn't be in our option
     *                     have already been removed and any options which weren't set
     *                     have been set to their defaults.
     *
     * @return array
     */
    protected function retain_variable_keys($dirty, $clean)
    {
    }
    /**
     * Retrieves a list of separator options.
     *
     * @return array An array of the separator options.
     */
    protected static function get_separator_option_list()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals\Options
   */
  /**
   * Option: wpseo.
   */
  class WPSEO_Option_Wpseo extends \WPSEO_Option
  {
    /**
     * Option name.
     *
     * @var string
     */
    public $option_name = 'wpseo';
    /**
     * Array of defaults for the option.
     *
     * {@internal Shouldn't be requested directly, use $this->get_defaults();}}
     *
     * @var array
     */
    protected $defaults = [
      // Non-form fields, set via (ajax) function.
      'tracking' => \null,
      'toggled_tracking' => \false,
      'license_server_version' => \false,
      'ms_defaults_set' => \false,
      'ignore_search_engines_discouraged_notice' => \false,
      'indexing_first_time' => \true,
      'indexing_started' => \null,
      'indexing_reason' => '',
      'indexables_indexing_completed' => \false,
      'index_now_key' => '',
      // Non-form field, should only be set via validation routine.
      'version' => '',
      // Leave default as empty to ensure activation/upgrade works.
      'previous_version' => '',
      // Form fields.
      'disableadvanced_meta' => \true,
      'enable_headless_rest_endpoints' => \true,
      'ryte_indexability' => \false,
      'baiduverify' => '',
      // Text field.
      'googleverify' => '',
      // Text field.
      'msverify' => '',
      // Text field.
      'yandexverify' => '',
      'site_type' => '',
      // List of options.
      'has_multiple_authors' => '',
      'environment_type' => '',
      'content_analysis_active' => \true,
      'keyword_analysis_active' => \true,
      'inclusive_language_analysis_active' => \false,
      'enable_admin_bar_menu' => \true,
      'enable_cornerstone_content' => \true,
      'enable_xml_sitemap' => \true,
      'enable_text_link_counter' => \true,
      'enable_index_now' => \true,
      'show_onboarding_notice' => \false,
      'first_activated_on' => \false,
      'myyoast-oauth' => ['config' => ['clientId' => \null, 'secret' => \null], 'access_tokens' => []],
      'semrush_integration_active' => \true,
      'semrush_tokens' => [],
      'semrush_country_code' => 'us',
      'permalink_structure' => '',
      'home_url' => '',
      'dynamic_permalinks' => \false,
      'category_base_url' => '',
      'tag_base_url' => '',
      'custom_taxonomy_slugs' => [],
      'enable_enhanced_slack_sharing' => \true,
      'zapier_integration_active' => \false,
      'zapier_subscription' => [],
      'zapier_api_key' => '',
      'enable_metabox_insights' => \true,
      'enable_link_suggestions' => \true,
      'algolia_integration_active' => \false,
      'import_cursors' => [],
      'workouts_data' => ['configuration' => ['finishedSteps' => []]],
      'configuration_finished_steps' => [],
      'dismiss_configuration_workout_notice' => \false,
      'dismiss_premium_deactivated_notice' => \false,
      'dismiss_old_premium_version_notice' => '',
      'importing_completed' => [],
      'wincher_integration_active' => \true,
      'wincher_tokens' => [],
      'wincher_automatically_add_keyphrases' => \false,
      'wincher_website_id' => '',
      'wordproof_integration_active' => \false,
      'wordproof_integration_changed' => \false,
      'first_time_install' => \false,
      'should_redirect_after_install_free' => \false,
      'activation_redirect_timestamp_free' => 0,
      'remove_feed_global' => \false,
      'remove_feed_global_comments' => \false,
      'remove_feed_post_comments' => \false,
      'remove_feed_authors' => \false,
      'remove_feed_categories' => \false,
      'remove_feed_tags' => \false,
      'remove_feed_custom_taxonomies' => \false,
      'remove_feed_post_types' => \false,
      'remove_feed_search' => \false,
      'remove_atom_rdf_feeds' => \false,
      'remove_shortlinks' => \false,
      'remove_rest_api_links' => \false,
      'remove_rsd_wlw_links' => \false,
      'remove_oembed_links' => \false,
      'remove_generator' => \false,
      'remove_emoji_scripts' => \false,
      'remove_powered_by_header' => \false,
      'remove_pingback_header' => \false,
      'clean_campaign_tracking_urls' => \false,
      'clean_permalinks' => \false,
      'clean_permalinks_extra_variables' => '',
      'search_cleanup' => \false,
      'search_cleanup_emoji' => \false,
      'search_cleanup_patterns' => \false,
      'search_character_limit' => 50,
      'deny_search_crawling' => \false,
      'deny_wp_json_crawling' => \false,
      'redirect_search_pretty_urls' => \false,
      'least_readability_ignore_list' => [],
      'least_seo_score_ignore_list' => [],
      'most_linked_ignore_list' => [],
      'least_linked_ignore_list' => [],
      'indexables_page_reading_list' => [\false, \false, \false, \false, \false],
      'indexables_overview_state' => 'dashboard-not-visited',
      'last_known_public_post_types' => [],
      'last_known_public_taxonomies' => [],
    ];
    /**
     * Sub-options which should not be overloaded with multi-site defaults.
     *
     * @var array
     */
    public $ms_exclude = [
      'ignore_search_engines_discouraged_notice',
      /* Privacy. */
      'baiduverify',
      'googleverify',
      'msverify',
      'yandexverify',
    ];
    /**
     * Possible values for the site_type option.
     *
     * @var array
     */
    protected $site_types = ['', 'blog', 'shop', 'news', 'smallBusiness', 'corporateOther', 'personalOther'];
    /**
     * Possible environment types.
     *
     * @var array
     */
    protected $environment_types = ['', 'local', 'production', 'staging', 'development'];
    /**
     * Possible has_multiple_authors options.
     *
     * @var array
     */
    protected $has_multiple_authors_options = ['', \true, \false];
    /**
     * Name for an option higher in the hierarchy to override setting access.
     *
     * @var string
     */
    protected $override_option_name = 'wpseo_ms';
    /**
     * Add the actions and filters for the option.
     *
     * @todo [JRF => testers] Check if the extra actions below would run into problems if an option
     *       is updated early on and if so, change the call to schedule these for a later action on add/update
     *       instead of running them straight away.
     */
    protected function __construct()
    {
    }
    /**
     * Get the singleton instance of this class.
     *
     * @return object
     */
    public static function get_instance()
    {
    }
    /**
     * Add filters to make sure that the option is merged with its defaults before being returned.
     *
     * @return void
     */
    public function add_option_filters()
    {
    }
    /**
     * Remove the option filters.
     * Called from the clean_up methods to make sure we retrieve the original old option.
     *
     * @return void
     */
    public function remove_option_filters()
    {
    }
    /**
     * Add filters to make sure that the option default is returned if the option is not set.
     *
     * @return void
     */
    public function add_default_filters()
    {
    }
    /**
     * Remove the default filters.
     * Called from the validate() method to prevent failure to add new options.
     *
     * @return void
     */
    public function remove_default_filters()
    {
    }
    /**
     * Validate the option.
     *
     * @param array $dirty New value for the option.
     * @param array $clean Clean value for the option, normally the defaults.
     * @param array $old   Old value of the option.
     *
     * @return array Validated clean value for the option to be saved to the database.
     */
    protected function validate_option($dirty, $clean, $old)
    {
    }
    /**
     * Verifies that the feature variables are turned off if the network is configured so.
     *
     * @param mixed $options Value of the option to be returned. Typically an array.
     *
     * @return mixed Filtered $options value.
     */
    public function verify_features_against_network($options = [])
    {
    }
    /**
     * Gets the filter hook name and callback for adjusting the retrieved option value
     * against the network-allowed features.
     *
     * @return array Array where the first item is the hook name, the second is the hook callback,
     *               and the third is the hook priority.
     */
    protected function get_verify_features_option_filter_hook()
    {
    }
    /**
     * Gets the filter hook name and callback for adjusting the default option value against the network-allowed features.
     *
     * @return array Array where the first item is the hook name, the second is the hook callback,
     *               and the third is the hook priority.
     */
    protected function get_verify_features_default_option_filter_hook()
    {
    }
    /**
     * Clean a given option value.
     *
     * @param array       $option_value          Old (not merged with defaults or filtered) option value to
     *                                           clean according to the rules for this option.
     * @param string|null $current_version       Optional. Version from which to upgrade, if not set,
     *                                           version specific upgrades will be disregarded.
     * @param array|null  $all_old_option_values Optional. Only used when importing old options to have
     *                                           access to the real old values, in contrast to the saved ones.
     *
     * @return array Cleaned option.
     */
    protected function clean_option($option_value, $current_version = \null, $all_old_option_values = \null)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals\Options
   */
  /**
   * Overall Option Management class.
   *
   * Instantiates all the options and offers a number of utility methods to work with the options.
   */
  class WPSEO_Options
  {
    /**
     * The option values.
     *
     * @var array|null
     */
    protected static $option_values = \null;
    /**
     * Options this class uses.
     *
     * @var array Array format: (string) option_name  => (string) name of concrete class for the option.
     */
    public static $options = ['wpseo' => 'WPSEO_Option_Wpseo', 'wpseo_titles' => 'WPSEO_Option_Titles', 'wpseo_social' => 'WPSEO_Option_Social', 'wpseo_ms' => 'WPSEO_Option_MS', 'wpseo_taxonomy_meta' => 'WPSEO_Taxonomy_Meta'];
    /**
     * Array of instantiated option objects.
     *
     * @var array
     */
    protected static $option_instances = [];
    /**
     * Array with the option names.
     *
     * @var array
     */
    protected static $option_names = [];
    /**
     * Instance of this class.
     *
     * @var WPSEO_Options
     */
    protected static $instance;
    /**
     * Instantiate all the WPSEO option management classes.
     */
    protected function __construct()
    {
    }
    /**
     * Register our hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Get the singleton instance of this class.
     *
     * @return object
     */
    public static function get_instance()
    {
    }
    /**
     * Registers an option to the options list.
     *
     * @param WPSEO_Option $option_instance Instance of the option.
     */
    public static function register_option(\WPSEO_Option $option_instance)
    {
    }
    /**
     * Get the group name of an option for use in the settings form.
     *
     * @param string $option_name The option for which you want to retrieve the option group name.
     *
     * @return string|bool
     */
    public static function get_group_name($option_name)
    {
    }
    /**
     * Get a specific default value for an option.
     *
     * @param string $option_name The option for which you want to retrieve a default.
     * @param string $key         The key within the option who's default you want.
     *
     * @return mixed
     */
    public static function get_default($option_name, $key)
    {
    }
    /**
     * Update a site_option.
     *
     * @param string $option_name The option name of the option to save.
     * @param mixed  $value       The new value for the option.
     *
     * @return bool
     */
    public static function update_site_option($option_name, $value)
    {
    }
    /**
     * Get the instantiated option instance.
     *
     * @param string $option_name The option for which you want to retrieve the instance.
     *
     * @return object|bool
     */
    public static function get_option_instance($option_name)
    {
    }
    /**
     * Retrieve an array of the options which should be included in get_all() and reset().
     *
     * @return array Array of option names.
     */
    public static function get_option_names()
    {
    }
    /**
     * Retrieve all the options for the SEO plugin in one go.
     *
     * @return array Array combining the values of all the options.
     */
    public static function get_all()
    {
    }
    /**
     * Retrieve one or more options for the SEO plugin.
     *
     * @param array $option_names An array of option names of the options you want to get.
     *
     * @return array Array combining the values of the requested options.
     */
    public static function get_options(array $option_names)
    {
    }
    /**
     * Retrieve a single option for the SEO plugin.
     *
     * @param string $option_name The name of the option you want to get.
     *
     * @return array Array containing the requested option.
     */
    public static function get_option($option_name)
    {
    }
    /**
     * Retrieve a single field from any option for the SEO plugin. Keys are always unique.
     *
     * @param string $key           The key it should return.
     * @param mixed  $default_value The default value that should be returned if the key isn't set.
     *
     * @return mixed Returns value if found, $default_value if not.
     */
    public static function get($key, $default_value = \null)
    {
    }
    /**
     * Resets the cache to null.
     */
    public static function clear_cache()
    {
    }
    /**
     * Primes our cache.
     */
    private static function prime_cache()
    {
    }
    /**
     * Retrieve a single field from an option for the SEO plugin.
     *
     * @param string $key   The key to set.
     * @param mixed  $value The value to set.
     *
     * @return mixed|null Returns value if found, $default if not.
     */
    public static function set($key, $value)
    {
    }
    /**
     * Get an option only if it's been auto-loaded.
     *
     * @param string $option        The option to retrieve.
     * @param mixed  $default_value A default value to return.
     *
     * @return mixed
     */
    public static function get_autoloaded_option($option, $default_value = \false)
    {
    }
    /**
     * Run the clean up routine for one or all options.
     *
     * @param array|string|null $option_name     Optional. the option you want to clean or an array of
     *                                           option names for the options you want to clean.
     *                                           If not set, all options will be cleaned.
     * @param string|null       $current_version Optional. Version from which to upgrade, if not set,
     *                                           version specific upgrades will be disregarded.
     *
     * @return void
     */
    public static function clean_up($option_name = \null, $current_version = \null)
    {
    }
    /**
     * Check that all options exist in the database and add any which don't.
     *
     * @return void
     */
    public static function ensure_options_exist()
    {
    }
    /**
     * Initialize some options on first install/activate/reset.
     *
     * @return void
     */
    public static function initialize()
    {
    }
    /**
     * Reset all options to their default values and rerun some tests.
     *
     * @return void
     */
    public static function reset()
    {
    }
    /**
     * Initialize default values for a new multisite blog.
     *
     * @param bool $force_init Whether to always do the initialization routine (title/desc test).
     *
     * @return void
     */
    public static function maybe_set_multisite_defaults($force_init = \false)
    {
    }
    /**
     * Reset all options for a specific multisite blog to their default values based upon a
     * specified default blog if one was chosen on the network page or the plugin defaults if it was not.
     *
     * @param int|string $blog_id Blog id of the blog for which to reset the options.
     *
     * @return void
     */
    public static function reset_ms_blog($blog_id)
    {
    }
    /**
     * Saves the option to the database.
     *
     * @param string $wpseo_options_group_name The name for the wpseo option group in the database.
     * @param string $option_name              The name for the option to set.
     * @param mixed  $option_value             The value for the option.
     *
     * @return bool Returns true if the option is successfully saved in the database.
     */
    public static function save_option($wpseo_options_group_name, $option_name, $option_value)
    {
    }
    /**
     * Adds the multisite options to the option stack if relevant.
     *
     * @param array $option The currently present options settings.
     *
     * @return array Options possibly including multisite.
     */
    protected static function add_ms_option($option)
    {
    }
    /**
     * Checks if installation is multisite.
     *
     * @return bool True when is multisite.
     */
    protected static function is_multisite()
    {
    }
    /**
     * Retrieves a lookup table to find in which option_group a key is stored.
     *
     * @return array The lookup table.
     */
    private static function get_lookup_table()
    {
    }
    /**
     * Retrieves a lookup table to find in which option_group a key is stored.
     *
     * @return array The lookup table.
     */
    private static function get_pattern_table()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Internals\Options
   */
  /**
   * Option: wpseo_taxonomy_meta.
   */
  class WPSEO_Taxonomy_Meta extends \WPSEO_Option
  {
    /**
     * Option name.
     *
     * @var string
     */
    public $option_name = 'wpseo_taxonomy_meta';
    /**
     * Whether to include the option in the return for WPSEO_Options::get_all().
     *
     * @var bool
     */
    public $include_in_all = \false;
    /**
     * Array of defaults for the option.
     *
     * Shouldn't be requested directly, use $this->get_defaults();
     *
     * {@internal Important: in contrast to most defaults, the below array format is
     *            very bare. The real option is in the format [taxonomy_name][term_id][...]
     *            where [...] is any of the $defaults_per_term options shown below.
     *            This is of course taken into account in the below methods.}}
     *
     * @var array
     */
    protected $defaults = [];
    /**
     * Option name - same as $option_name property, but now also available to static methods.
     *
     * @var string
     */
    public static $name;
    /**
     * Array of defaults for individual taxonomy meta entries.
     *
     * @var array
     */
    public static $defaults_per_term = [
      'wpseo_title' => '',
      'wpseo_desc' => '',
      'wpseo_canonical' => '',
      'wpseo_bctitle' => '',
      'wpseo_noindex' => 'default',
      'wpseo_focuskw' => '',
      'wpseo_linkdex' => '',
      'wpseo_content_score' => '',
      'wpseo_inclusive_language_score' => '',
      'wpseo_focuskeywords' => '[]',
      'wpseo_keywordsynonyms' => '[]',
      'wpseo_is_cornerstone' => '0',
      // Social fields.
      'wpseo_opengraph-title' => '',
      'wpseo_opengraph-description' => '',
      'wpseo_opengraph-image' => '',
      'wpseo_opengraph-image-id' => '',
      'wpseo_twitter-title' => '',
      'wpseo_twitter-description' => '',
      'wpseo_twitter-image' => '',
      'wpseo_twitter-image-id' => '',
    ];
    /**
     * Available index options.
     *
     * Used for form generation and input validation.
     *
     * {@internal Labels (translation) added on admin_init via WPSEO_Taxonomy::translate_meta_options().}}
     *
     * @var array
     */
    public static $no_index_options = ['default' => '', 'index' => '', 'noindex' => ''];
    /**
     * Add the actions and filters for the option.
     *
     * @todo [JRF => testers] Check if the extra actions below would run into problems if an option
     * is updated early on and if so, change the call to schedule these for a later action on add/update
     * instead of running them straight away.
     */
    protected function __construct()
    {
    }
    /**
     * Get the singleton instance of this class.
     *
     * @return object
     */
    public static function get_instance()
    {
    }
    /**
     * Add extra default options received from a filter.
     */
    public function enrich_defaults()
    {
    }
    /**
     * Validate the option.
     *
     * @param array $dirty New value for the option.
     * @param array $clean Clean value for the option, normally the defaults.
     * @param array $old   Old value of the option.
     *
     * @return array Validated clean value for the option to be saved to the database.
     */
    protected function validate_option($dirty, $clean, $old)
    {
    }
    /**
     * Validate the meta data for one individual term and removes default values (no need to save those).
     *
     * @param array $meta_data New values.
     * @param array $old_meta  The original values.
     *
     * @return array Validated and filtered value.
     */
    public static function validate_term_meta_data($meta_data, $old_meta)
    {
    }
    /**
     * Clean a given option value.
     * - Convert old option values to new
     * - Fixes strings which were escaped (should have been sanitized - escaping is for output)
     *
     * @param array       $option_value          Old (not merged with defaults or filtered) option value to
     *                                           clean according to the rules for this option.
     * @param string|null $current_version       Optional. Version from which to upgrade, if not set,
     *                                           version specific upgrades will be disregarded.
     * @param array|null  $all_old_option_values Optional. Only used when importing old options to have
     *                                           access to the real old values, in contrast to the saved ones.
     *
     * @return array Cleaned option.
     */
    protected function clean_option($option_value, $current_version = \null, $all_old_option_values = \null)
    {
    }
    /**
     * Retrieve a taxonomy term's meta value(s).
     *
     * @param mixed       $term     Term to get the meta value for
     *                              either (string) term name, (int) term id or (object) term.
     * @param string      $taxonomy Name of the taxonomy to which the term is attached.
     * @param string|null $meta     Optional. Meta value to get (without prefix).
     *
     * @return mixed Value for the $meta if one is given, might be the default.
     *               If no meta is given, an array of all the meta data for the term.
     *               False if the term does not exist or the $meta provided is invalid.
     */
    public static function get_term_meta($term, $taxonomy, $meta = \null)
    {
    }
    /**
     * Get the current queried object and return the meta value.
     *
     * @param string $meta The meta field that is needed.
     *
     * @return mixed
     */
    public static function get_meta_without_term($meta)
    {
    }
    /**
     * Saving the values for the given term_id.
     *
     * @param int    $term_id     ID of the term to save data for.
     * @param string $taxonomy    The taxonomy the term belongs to.
     * @param array  $meta_values The values that will be saved.
     */
    public static function set_values($term_id, $taxonomy, array $meta_values)
    {
    }
    /**
     * Setting a single value to the term meta.
     *
     * @param int    $term_id    ID of the term to save data for.
     * @param string $taxonomy   The taxonomy the term belongs to.
     * @param string $meta_key   The target meta key to store the value in.
     * @param string $meta_value The value of the target meta key.
     */
    public static function set_value($term_id, $taxonomy, $meta_key, $meta_value)
    {
    }
    /**
     * Find the keyword usages in the metas for the taxonomies/terms.
     *
     * @param string $keyword          The keyword to look for.
     * @param string $current_term_id  The current term id.
     * @param string $current_taxonomy The current taxonomy name.
     *
     * @return array
     */
    public static function get_keyword_usage($keyword, $current_term_id, $current_taxonomy)
    {
    }
    /**
     * Saving the values for the given term_id.
     *
     * @param int    $term_id  ID of the term to save data for.
     * @param string $taxonomy The taxonomy the term belongs to.
     * @param array  $clean    Array with clean values.
     */
    private static function save_clean_values($term_id, $taxonomy, array $clean)
    {
    }
    /**
     * Getting the meta from the options.
     *
     * @return void|array
     */
    private static function get_tax_meta()
    {
    }
    /**
     * Saving the tax meta values to the database.
     *
     * @param array $tax_meta Array with the meta values for taxonomy.
     */
    private static function save_tax_meta($tax_meta)
    {
    }
    /**
     * Getting the taxonomy meta for the given term_id and taxonomy.
     *
     * @param int    $term_id  The id of the term.
     * @param string $taxonomy Name of the taxonomy to which the term is attached.
     *
     * @return array
     */
    private static function get_term_tax_meta($term_id, $taxonomy)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Sitemap Provider interface.
   */
  interface WPSEO_Sitemap_Provider
  {
    /**
     * Check if provider supports given item type.
     *
     * @param string $type Type string to check for.
     *
     * @return bool
     */
    public function handles_type($type);
    /**
     * Get set of sitemaps index link data.
     *
     * @param int $max_entries Entries per sitemap.
     *
     * @return array
     */
    public function get_index_links($max_entries);
    /**
     * Get set of sitemap link data.
     *
     * @param string $type         Sitemap type.
     * @param int    $max_entries  Entries per sitemap.
     * @param int    $current_page Current page of the sitemap.
     *
     * @return array
     */
    public function get_sitemap_links($type, $max_entries, $current_page);
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Sitemap provider for author archives.
   */
  class WPSEO_Author_Sitemap_Provider implements \WPSEO_Sitemap_Provider
  {
    /**
     * Check if provider supports given item type.
     *
     * @param string $type Type string to check for.
     *
     * @return bool
     */
    public function handles_type($type)
    {
    }
    /**
     * Get the links for the sitemap index.
     *
     * @param int $max_entries Entries per sitemap.
     *
     * @return array
     */
    public function get_index_links($max_entries)
    {
    }
    /**
     * Retrieve users, taking account of all necessary exclusions.
     *
     * @param array $arguments Arguments to add.
     *
     * @return array
     */
    protected function get_users($arguments = [])
    {
    }
    /**
     * Get set of sitemap link data.
     *
     * @param string $type         Sitemap type.
     * @param int    $max_entries  Entries per sitemap.
     * @param int    $current_page Current page of the sitemap.
     *
     * @return array
     *
     * @throws OutOfBoundsException When an invalid page is requested.
     */
    public function get_sitemap_links($type, $max_entries, $current_page)
    {
    }
    /**
     * Update any users that don't have last profile update timestamp.
     *
     * @return int Count of users updated.
     */
    protected function update_user_meta()
    {
    }
    /**
     * Wrap legacy filter to deduplicate calls.
     *
     * @param array $users Array of user objects to filter.
     *
     * @return array
     */
    protected function exclude_users($users)
    {
    }
  }
  /**
   * Sitemap provider for author archives.
   */
  class WPSEO_Post_Type_Sitemap_Provider implements \WPSEO_Sitemap_Provider
  {
    /**
     * Holds image parser instance.
     *
     * @var WPSEO_Sitemap_Image_Parser
     */
    protected static $image_parser;
    /**
     * Holds the parsed home url.
     *
     * @var array
     */
    protected static $parsed_home_url;
    /**
     * Determines whether images should be included in the XML sitemap.
     *
     * @var bool
     */
    private $include_images;
    /**
     * Set up object properties for data reuse.
     */
    public function __construct()
    {
    }
    /**
     * Get the Image Parser.
     *
     * @return WPSEO_Sitemap_Image_Parser
     */
    protected function get_image_parser()
    {
    }
    /**
     * Gets the parsed home url.
     *
     * @return array The home url, as parsed by wp_parse_url.
     */
    protected function get_parsed_home_url()
    {
    }
    /**
     * Check if provider supports given item type.
     *
     * @param string $type Type string to check for.
     *
     * @return bool
     */
    public function handles_type($type)
    {
    }
    /**
     * Retrieves the sitemap links.
     *
     * @param int $max_entries Entries per sitemap.
     *
     * @return array
     */
    public function get_index_links($max_entries)
    {
    }
    /**
     * Get set of sitemap link data.
     *
     * @param string $type         Sitemap type.
     * @param int    $max_entries  Entries per sitemap.
     * @param int    $current_page Current page of the sitemap.
     *
     * @return array
     *
     * @throws OutOfBoundsException When an invalid page is requested.
     */
    public function get_sitemap_links($type, $max_entries, $current_page)
    {
    }
    /**
     * Check for relevant post type before invalidation.
     *
     * @param int $post_id Post ID to possibly invalidate for.
     */
    public function save_post($post_id)
    {
    }
    /**
     * Check if post type should be present in sitemaps.
     *
     * @param string $post_type Post type string to check for.
     *
     * @return bool
     */
    public function is_valid_post_type($post_type)
    {
    }
    /**
     * Retrieves a list with the excluded post ids.
     *
     * @param string $post_type Post type.
     *
     * @return array Array with post ids to exclude.
     */
    protected function get_excluded_posts($post_type)
    {
    }
    /**
     * Get count of posts for post type.
     *
     * @param string $post_type Post type to retrieve count for.
     *
     * @return int
     */
    protected function get_post_type_count($post_type)
    {
    }
    /**
     * Produces set of links to prepend at start of first sitemap page.
     *
     * @param string $post_type Post type to produce links for.
     *
     * @return array
     */
    protected function get_first_links($post_type)
    {
    }
    /**
     * Get URL for a post type archive.
     *
     * @since 5.3
     *
     * @param string $post_type Post type.
     *
     * @return string|bool URL or false if it should be excluded.
     */
    protected function get_post_type_archive_link($post_type)
    {
    }
    /**
     * Determines whether a post type archive is indexable.
     *
     * @since 11.5
     *
     * @param string $post_type       Post type.
     * @param int    $archive_page_id The page id.
     *
     * @return bool True when post type archive is indexable.
     */
    protected function is_post_type_archive_indexable($post_type, $archive_page_id = -1)
    {
    }
    /**
     * Retrieve set of posts with optimized query routine.
     *
     * @param string $post_type Post type to retrieve.
     * @param int    $count     Count of posts to retrieve.
     * @param int    $offset    Starting offset.
     *
     * @return object[]
     */
    protected function get_posts($post_type, $count, $offset)
    {
    }
    /**
     * Constructs an SQL where clause for a given post type.
     *
     * @param string $post_type Post type slug.
     *
     * @return string
     */
    protected function get_sql_where_clause($post_type)
    {
    }
    /**
     * Produce array of URL parts for given post object.
     *
     * @param object $post Post object to get URL parts for.
     *
     * @return array|bool
     */
    protected function get_url($post)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Cache Data interface.
   */
  interface WPSEO_Sitemap_Cache_Data_Interface
  {
    /**
     * Status for normal, usable sitemap.
     *
     * @var string
     */
    const OK = 'ok';
    /**
     * Status for unusable sitemap.
     *
     * @var string
     */
    const ERROR = 'error';
    /**
     * Status for unusable sitemap because it cannot be identified.
     *
     * @var string
     */
    const UNKNOWN = 'unknown';
    /**
     * Set the content of the sitemap.
     *
     * @param string $sitemap The XML content of the sitemap.
     *
     * @return void
     */
    public function set_sitemap($sitemap);
    /**
     * Set the status of the sitemap.
     *
     * @param bool|string $usable True/False or 'ok'/'error' for status.
     *
     * @return void
     */
    public function set_status($usable);
    /**
     * Builds the sitemap.
     *
     * @return string The XML content of the sitemap.
     */
    public function get_sitemap();
    /**
     * Get the status of this sitemap.
     *
     * @return string Status 'ok', 'error' or 'unknown'.
     */
    public function get_status();
    /**
     * Is the sitemap content usable ?
     *
     * @return bool True if the sitemap is usable, False if not.
     */
    public function is_usable();
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Sitemap Cache Data object, manages sitemap data stored in cache.
   */
  class WPSEO_Sitemap_Cache_Data implements \Serializable, \WPSEO_Sitemap_Cache_Data_Interface
  {
    /**
     * Sitemap XML data.
     *
     * @var string
     */
    private $sitemap = '';
    /**
     * Status of the sitemap, usable or not.
     *
     * @var string
     */
    private $status = self::UNKNOWN;
    /**
     * Set the sitemap XML data
     *
     * @param string $sitemap XML Content of the sitemap.
     */
    public function set_sitemap($sitemap)
    {
    }
    /**
     * Set the status of the sitemap, is it usable.
     *
     * @param bool|string $usable Is the sitemap usable or not.
     *
     * @return void
     */
    public function set_status($usable)
    {
    }
    /**
     * Is the sitemap usable.
     *
     * @return bool True if usable, False if bad or unknown.
     */
    public function is_usable()
    {
    }
    /**
     * Get the XML content of the sitemap.
     *
     * @return string The content of the sitemap.
     */
    public function get_sitemap()
    {
    }
    /**
     * Get the status of the sitemap.
     *
     * @return string Status of the sitemap, 'ok'/'error'/'unknown'.
     */
    public function get_status()
    {
    }
    /**
     * String representation of object.
     *
     * {@internal This magic method is only "magic" as of PHP 7.4 in which the magic method was introduced.}
     *
     * @link https://www.php.net/language.oop5.magic#object.serialize
     * @link https://wiki.php.net/rfc/custom_object_serialization
     *
     * @since 17.8.0
     *
     * @return array The data to be serialized.
     */
    public function __serialize()
    {
    }
    /**
     * Constructs the object.
     *
     * {@internal This magic method is only "magic" as of PHP 7.4 in which the magic method was introduced.}
     *
     * @link https://www.php.net/language.oop5.magic#object.serialize
     * @link https://wiki.php.net/rfc/custom_object_serialization
     *
     * @since 17.8.0
     *
     * @param array $data The unserialized data to use to (re)construct the object.
     *
     * @return void
     */
    public function __unserialize($data)
    {
    }
    /**
     * String representation of object.
     *
     * {@internal The magic methods take precedence over the Serializable interface.
     * This means that in practice, this method will now only be called on PHP < 7.4.
     * For PHP 7.4 and higher, the magic methods will be used instead.}
     *
     * {@internal The Serializable interface is being phased out, in favour of the magic methods.
     * This method should be deprecated and removed and the class should no longer
     * implement the `Serializable` interface.
     * This change, however, can't be made until the minimum PHP version goes up to PHP 7.4 or higher.}
     *
     * @link http://php.net/manual/en/serializable.serialize.php
     * @link https://wiki.php.net/rfc/phase_out_serializable
     *
     * @since 5.1.0
     *
     * @return string The string representation of the object or null in C-format.
     */
    public function serialize()
    {
    }
    /**
     * Constructs the object.
     *
     * {@internal The magic methods take precedence over the Serializable interface.
     * This means that in practice, this method will now only be called on PHP < 7.4.
     * For PHP 7.4 and higher, the magic methods will be used instead.}
     *
     * {@internal The Serializable interface is being phased out, in favour of the magic methods.
     * This method should be deprecated and removed and the class should no longer
     * implement the `Serializable` interface.
     * This change, however, can't be made until the minimum PHP version goes up to PHP 7.4 or higher.}
     *
     * @link http://php.net/manual/en/serializable.unserialize.php
     * @link https://wiki.php.net/rfc/phase_out_serializable
     *
     * @since 5.1.0
     *
     * @param string $data The string representation of the object in C or O-format.
     *
     * @return void
     */
    public function unserialize($data)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Parses images from the given post.
   */
  class WPSEO_Sitemap_Image_Parser
  {
    /**
     * Holds the home_url() value to speed up loops.
     *
     * @var string
     */
    protected $home_url = '';
    /**
     * Holds site URL hostname.
     *
     * @var string
     */
    protected $host = '';
    /**
     * Holds site URL protocol.
     *
     * @var string
     */
    protected $scheme = 'http';
    /**
     * Cached set of attachments for multiple posts.
     *
     * @var array
     */
    protected $attachments = [];
    /**
     * Holds blog charset value for use in DOM parsing.
     *
     * @var string
     */
    protected $charset = 'UTF-8';
    /**
     * Set up URL properties for reuse.
     */
    public function __construct()
    {
    }
    /**
     * Get set of image data sets for the given post.
     *
     * @param object $post Post object to get images for.
     *
     * @return array
     */
    public function get_images($post)
    {
    }
    /**
     * Get the images in the term description.
     *
     * @param object $term Term to get images from description for.
     *
     * @return array
     */
    public function get_term_images($term)
    {
    }
    /**
     * Parse `<img />` tags in content.
     *
     * @param string $content Content string to parse.
     *
     * @return array
     */
    private function parse_html_images($content)
    {
    }
    /**
     * Parse gallery shortcodes in a given content.
     *
     * @param string $content Content string.
     * @param int    $post_id Optional. ID of post being parsed.
     *
     * @return array Set of attachment objects.
     */
    protected function parse_galleries($content, $post_id = 0)
    {
    }
    /**
     * Retrieves galleries from the passed content.
     *
     * Forked from core to skip executing shortcodes for performance.
     *
     * @param string $content Content to parse for shortcodes.
     *
     * @return array A list of arrays, each containing gallery data.
     */
    protected function get_content_galleries($content)
    {
    }
    /**
     * Get image item array with filters applied.
     *
     * @param WP_Post $post Post object for the context.
     * @param string  $src  Image URL.
     *
     * @return array
     */
    protected function get_image_item($post, $src)
    {
    }
    /**
     * Get attached image URL with filters applied. Adapted from core for speed.
     *
     * @param int $post_id ID of the post.
     *
     * @return string
     */
    private function image_url($post_id)
    {
    }
    /**
     * Make absolute URL for domain or protocol-relative one.
     *
     * @param string $src URL to process.
     *
     * @return string
     */
    protected function get_absolute_url($src)
    {
    }
    /**
     * Returns the attachments for a gallery.
     *
     * @param int   $id      The post ID.
     * @param array $gallery The gallery config.
     *
     * @return array The selected attachments.
     */
    protected function get_gallery_attachments($id, $gallery)
    {
    }
    /**
     * Returns the attachments for the given ID.
     *
     * @param int   $id      The post ID.
     * @param array $gallery The gallery config.
     *
     * @return array The selected attachments.
     */
    protected function get_gallery_attachments_for_parent($id, $gallery)
    {
    }
    /**
     * Returns an array with attachments for the post IDs that will be included.
     *
     * @param array $included_ids Array with IDs to include.
     *
     * @return array The found attachments.
     */
    protected function get_gallery_attachments_for_included($included_ids)
    {
    }
    /**
     * Returns the attachments.
     *
     * @param array $args Array with query args.
     *
     * @return array The found attachments.
     */
    protected function get_attachments($args)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\Admin\XML Sitemaps
   */
  /**
   * Class that handles the Admin side of XML sitemaps.
   */
  class WPSEO_Sitemaps_Admin
  {
    /**
     * Post_types that are being imported.
     *
     * @var array
     */
    private $importing_post_types = [];
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Hooked into transition_post_status. Will initiate search engine pings
     * if the post is being published, is a post type that a sitemap is built for
     * and is a post that is included in sitemaps.
     *
     * @param string   $new_status New post status.
     * @param string   $old_status Old post status.
     * @param \WP_Post $post       Post object.
     */
    public function status_transition($new_status, $old_status, $post)
    {
    }
    /**
     * Notify Google of the updated sitemap.
     */
    public function ping_search_engines()
    {
    }
    /**
     * While bulk importing, just save unique post_types.
     *
     * When importing is done, if we have a post_type that is saved in the sitemap
     * try to ping the search engines.
     *
     * @param string   $new_status New post status.
     * @param string   $old_status Old post status.
     * @param \WP_Post $post       Post object.
     */
    private function status_transition_bulk($new_status, $old_status, $post)
    {
    }
    /**
     * After import finished, walk through imported post_types and update info.
     */
    public function status_transition_bulk_finished()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Handles storage keys for sitemaps caching and invalidation.
   *
   * @since 3.2
   */
  class WPSEO_Sitemaps_Cache_Validator
  {
    /**
     * Prefix of the transient key for sitemap caches.
     *
     * @var string
     */
    const STORAGE_KEY_PREFIX = 'yst_sm_';
    /**
     * Name of the option that holds the global validation value.
     *
     * @var string
     */
    const VALIDATION_GLOBAL_KEY = 'wpseo_sitemap_cache_validator_global';
    /**
     * The format which creates the key of the option that holds the type validation value.
     *
     * @var string
     */
    const VALIDATION_TYPE_KEY_FORMAT = 'wpseo_sitemap_%s_cache_validator';
    /**
     * Get the cache key for a certain type and page.
     *
     * A type of cache would be something like 'page', 'post' or 'video'.
     *
     * Example key format for sitemap type "post", page 1: wpseo_sitemap_post_1:akfw3e_23azBa .
     *
     * @since 3.2
     *
     * @param string|null $type The type to get the key for. Null or self::SITEMAP_INDEX_TYPE for index cache.
     * @param int         $page The page of cache to get the key for.
     *
     * @return bool|string The key where the cache is stored on. False if the key could not be generated.
     */
    public static function get_storage_key($type = \null, $page = 1)
    {
    }
    /**
     * If the type is over length make sure we compact it so we don't have any database problems.
     *
     * When there are more 'extremely long' post types, changes are they have variations in either the start or ending.
     * Because of this, we cut out the excess in the middle which should result in less chance of collision.
     *
     * @since 3.2
     *
     * @param string $type    The type of sitemap to be used.
     * @param string $prefix  The part before the type in the cache key. Only the length is used.
     * @param string $postfix The part after the type in the cache key. Only the length is used.
     *
     * @return string The type with a safe length to use
     *
     * @throws OutOfRangeException When there is less than 15 characters of space for a key that is originally longer.
     */
    public static function truncate_type($type, $prefix = '', $postfix = '')
    {
    }
    /**
     * Invalidate sitemap cache.
     *
     * @since 3.2
     *
     * @param string|null $type The type to get the key for. Null for all caches.
     *
     * @return void
     */
    public static function invalidate_storage($type = \null)
    {
    }
    /**
     * Cleanup invalidated database cache.
     *
     * @since 3.2
     *
     * @param string|null $type      The type of sitemap to clear cache for.
     * @param string|null $validator The validator to clear cache of.
     *
     * @return void
     */
    public static function cleanup_database($type = \null, $validator = \null)
    {
    }
    /**
     * Get the current cache validator.
     *
     * Without the type the global validator is returned.
     * This can invalidate -all- keys in cache at once.
     *
     * With the type parameter the validator for that specific type can be invalidated.
     *
     * @since 3.2
     *
     * @param string $type Provide a type for a specific type validator, empty for global validator.
     *
     * @return string|null The validator for the supplied type.
     */
    public static function get_validator($type = '')
    {
    }
    /**
     * Get the cache validator option key for the specified type.
     *
     * @since 3.2
     *
     * @param string $type Provide a type for a specific type validator, empty for global validator.
     *
     * @return string Validator to be used to generate the cache key.
     */
    public static function get_validator_key($type = '')
    {
    }
    /**
     * Refresh the cache validator value.
     *
     * @since 3.2
     *
     * @param string $type Provide a type for a specific type validator, empty for global validator.
     *
     * @return bool True if validator key has been saved as option.
     */
    public static function create_validator($type = '')
    {
    }
    /**
     * Encode to base61 format.
     *
     * This is base64 (numeric + alpha + alpha upper case) without the 0.
     *
     * @since 3.2
     *
     * @param int $base10 The number that has to be converted to base 61.
     *
     * @return string Base 61 converted string.
     *
     * @throws InvalidArgumentException When the input is not an integer.
     */
    public static function convert_base10_to_base61($base10)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Handles sitemaps caching and invalidation.
   *
   * @since 3.2
   */
  class WPSEO_Sitemaps_Cache
  {
    /**
     * Holds the options that, when updated, should cause the cache to clear.
     *
     * @var array
     */
    protected static $cache_clear = [];
    /**
     * Mirror of enabled status for static calls.
     *
     * @var bool
     */
    protected static $is_enabled = \false;
    /**
     * Holds the flag to clear all cache.
     *
     * @var bool
     */
    protected static $clear_all = \false;
    /**
     * Holds the array of types to clear.
     *
     * @var array
     */
    protected static $clear_types = [];
    /**
     * Hook methods for invalidation on necessary events.
     */
    public function __construct()
    {
    }
    /**
     * Setup context for static calls.
     */
    public function init()
    {
    }
    /**
     * If cache is enabled.
     *
     * @since 3.2
     *
     * @return bool
     */
    public function is_enabled()
    {
    }
    /**
     * Retrieve the sitemap page from cache.
     *
     * @since 3.2
     *
     * @param string $type Sitemap type.
     * @param int    $page Page number to retrieve.
     *
     * @return string|bool
     */
    public function get_sitemap($type, $page)
    {
    }
    /**
     * Get the sitemap that is cached.
     *
     * @param string $type Sitemap type.
     * @param int    $page Page number to retrieve.
     *
     * @return WPSEO_Sitemap_Cache_Data|null Null on no cache found otherwise object containing sitemap and meta data.
     */
    public function get_sitemap_data($type, $page)
    {
    }
    /**
     * Store the sitemap page from cache.
     *
     * @since 3.2
     *
     * @param string $type    Sitemap type.
     * @param int    $page    Page number to store.
     * @param string $sitemap Sitemap body to store.
     * @param bool   $usable  Is this a valid sitemap or a cache of an invalid sitemap.
     *
     * @return bool
     */
    public function store_sitemap($type, $page, $sitemap, $usable = \true)
    {
    }
    /**
     * Delete cache transients for index and specific type.
     *
     * Always deletes the main index sitemaps cache, as that's always invalidated by any other change.
     *
     * @since 1.5.4
     * @since 3.2   Changed from function wpseo_invalidate_sitemap_cache() to method in this class.
     *
     * @param string $type Sitemap type to invalidate.
     *
     * @return void
     */
    public static function invalidate($type)
    {
    }
    /**
     * Helper to invalidate in hooks where type is passed as second argument.
     *
     * @since 3.2
     *
     * @param int    $unused Unused term ID value.
     * @param string $type   Taxonomy to invalidate.
     *
     * @return void
     */
    public static function invalidate_helper($unused, $type)
    {
    }
    /**
     * Invalidate sitemap cache for authors.
     *
     * @param int $user_id User ID.
     *
     * @return bool True if the sitemap was properly invalidated. False otherwise.
     */
    public static function invalidate_author($user_id)
    {
    }
    /**
     * Invalidate sitemap cache for the post type of a post.
     *
     * Don't invalidate for revisions.
     *
     * @since 1.5.4
     * @since 3.2   Changed from function wpseo_invalidate_sitemap_cache_on_save_post() to method in this class.
     *
     * @param int $post_id Post ID to invalidate type for.
     *
     * @return void
     */
    public static function invalidate_post($post_id)
    {
    }
    /**
     * Delete cache transients for given sitemaps types or all by default.
     *
     * @since 1.8.0
     * @since 3.2   Moved from WPSEO_Utils to this class.
     *
     * @param array $types Set of sitemap types to delete cache transients for.
     *
     * @return void
     */
    public static function clear($types = [])
    {
    }
    /**
     * Invalidate storage for cache types queued to clear.
     */
    public static function clear_queued()
    {
    }
    /**
     * Adds a hook that when given option is updated, the cache is cleared.
     *
     * @since 3.2
     *
     * @param string $option Option name.
     * @param string $type   Sitemap type.
     */
    public static function register_clear_on_option_update($option, $type = '')
    {
    }
    /**
     * Clears the transient cache when a given option is updated, if that option has been registered before.
     *
     * @since 3.2
     *
     * @param string $option The option name that's being updated.
     *
     * @return void
     */
    public static function clear_on_option_update($option)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Renders XML output for sitemaps.
   */
  class WPSEO_Sitemaps_Renderer
  {
    /**
     * XSL stylesheet for styling a sitemap for web browsers.
     *
     * @var string
     */
    protected $stylesheet = '';
    /**
     * Holds the get_bloginfo( 'charset' ) value to reuse for performance.
     *
     * @var string
     */
    protected $charset = 'UTF-8';
    /**
     * Holds charset of output, might be converted.
     *
     * @var string
     */
    protected $output_charset = 'UTF-8';
    /**
     * If data encoding needs to be converted for output.
     *
     * @var bool
     */
    protected $needs_conversion = \false;
    /**
     * Set up object properties.
     */
    public function __construct()
    {
    }
    /**
     * Builds the sitemap index.
     *
     * @param array $links Set of sitemaps index links.
     *
     * @return string
     */
    public function get_index($links)
    {
    }
    /**
     * Builds the sitemap.
     *
     * @param array  $links        Set of sitemap links.
     * @param string $type         Sitemap type.
     * @param int    $current_page Current sitemap page number.
     *
     * @return string
     */
    public function get_sitemap($links, $type, $current_page)
    {
    }
    /**
     * Produce final XML output with debug information.
     *
     * @param string $sitemap Sitemap XML.
     *
     * @return string
     */
    public function get_output($sitemap)
    {
    }
    /**
     * Get charset for the output.
     *
     * @return string
     */
    public function get_output_charset()
    {
    }
    /**
     * Set a custom stylesheet for this sitemap. Set to empty to just remove the default stylesheet.
     *
     * @param string $stylesheet Full XML-stylesheet declaration.
     */
    public function set_stylesheet($stylesheet)
    {
    }
    /**
     * Build the `<sitemap>` tag for a given URL.
     *
     * @param array $url Array of parts that make up this entry.
     *
     * @return string
     */
    protected function sitemap_index_url($url)
    {
    }
    /**
     * Build the `<url>` tag for a given URL.
     *
     * Public access for backwards compatibility reasons.
     *
     * @param array $url Array of parts that make up this entry.
     *
     * @return string
     */
    public function sitemap_url($url)
    {
    }
    /**
     * Ensure the URL is encoded per RFC3986 and correctly escaped for use in an XML sitemap.
     *
     * This method works around a two quirks in esc_url():
     * 1. `esc_url()` leaves schema-relative URLs alone, while according to the sitemap specs,
     *    the URL must always begin with a protocol.
     * 2. `esc_url()` escapes ampersands as `&#038;` instead of the more common `&amp;`.
     *    According to the specs, `&amp;` should be used, and even though this shouldn't
     *    really make a difference in practice, to quote Jono: "I'd be nervous about &#038;
     *    given how many weird and wonderful things eat sitemaps", so better safe than sorry.
     *
     * @link https://www.sitemaps.org/protocol.html#xmlTagDefinitions
     * @link https://www.sitemaps.org/protocol.html#escaping
     * @link https://developer.wordpress.org/reference/functions/esc_url/
     *
     * @param string $url URL to encode and escape.
     *
     * @return string
     */
    protected function encode_and_escape($url)
    {
    }
    /**
     * Apply some best effort conversion to comply with RFC3986.
     *
     * @param string $url URL to encode.
     *
     * @return string
     */
    protected function encode_url_rfc3986($url)
    {
    }
    /**
     * Retrieves the XSL URL that should be used in the current environment
     *
     * When home_url and site_url are not the same, the home_url should be used.
     * This is because the XSL needs to be served from the same domain, protocol and port
     * as the XML file that is loading it.
     *
     * @return string The XSL URL that needs to be used.
     */
    protected function get_xsl_url()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Rewrite setup and handling for sitemaps functionality.
   */
  class WPSEO_Sitemaps_Router
  {
    /**
     * Sets up init logic.
     */
    public function __construct()
    {
    }
    /**
     * Sets up rewrite rules.
     */
    public function init()
    {
    }
    /**
     * Stop trailing slashes on sitemap.xml URLs.
     *
     * @param string $redirect The redirect URL currently determined.
     *
     * @return bool|string
     */
    public function redirect_canonical($redirect)
    {
    }
    /**
     * Redirects sitemap.xml to sitemap_index.xml.
     */
    public function template_redirect()
    {
    }
    /**
     * Checks whether the current request needs to be redirected to sitemap_index.xml.
     *
     * @global WP_Query $wp_query Current query.
     *
     * @return bool True if redirect is needed, false otherwise.
     */
    public function needs_sitemap_index_redirect()
    {
    }
    /**
     * Create base URL for the sitemap.
     *
     * @param string $page Page to append to the base URL.
     *
     * @return string base URL (incl page)
     */
    public static function get_base_url($page)
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Class WPSEO_Sitemaps.
   *
   * @todo This class could use a general description with some explanation on sitemaps. OR.
   */
  class WPSEO_Sitemaps
  {
    /**
     * Sitemap index identifier.
     *
     * @var string
     */
    const SITEMAP_INDEX_TYPE = '1';
    /**
     * Content of the sitemap to output.
     *
     * @var string
     */
    protected $sitemap = '';
    /**
     * Flag to indicate if this is an invalid or empty sitemap.
     *
     * @var bool
     */
    public $bad_sitemap = \false;
    /**
     * Whether or not the XML sitemap was served from a transient or not.
     *
     * @var bool
     */
    private $transient = \false;
    /**
     * HTTP protocol to use in headers.
     *
     * @since 3.2
     *
     * @var string
     */
    protected $http_protocol = 'HTTP/1.1';
    /**
     * Holds the n variable.
     *
     * @var int
     */
    private $current_page = 1;
    /**
     * The sitemaps router.
     *
     * @since 3.2
     *
     * @var WPSEO_Sitemaps_Router
     */
    public $router;
    /**
     * The sitemap renderer.
     *
     * @since 3.2
     *
     * @var WPSEO_Sitemaps_Renderer
     */
    public $renderer;
    /**
     * The sitemap cache.
     *
     * @since 3.2
     *
     * @var WPSEO_Sitemaps_Cache
     */
    public $cache;
    /**
     * The sitemap providers.
     *
     * @since 3.2
     *
     * @var WPSEO_Sitemap_Provider[]
     */
    public $providers;
    /**
     * Class constructor.
     */
    public function __construct()
    {
    }
    /**
     * Initialize sitemap providers classes.
     *
     * @since 5.3
     */
    public function init_sitemaps_providers()
    {
    }
    /**
     * Check the current request URI, if we can determine it's probably an XML sitemap, kill loading the widgets.
     */
    public function reduce_query_load()
    {
    }
    /**
     * Register your own sitemap. Call this during 'init'.
     *
     * @param string   $name              The name of the sitemap.
     * @param callback $building_function Function to build your sitemap.
     * @param string   $rewrite           Optional. Regular expression to match your sitemap with.
     */
    public function register_sitemap($name, $building_function, $rewrite = '')
    {
    }
    /**
     * Register your own XSL file. Call this during 'init'.
     *
     * @since 1.4.23
     *
     * @param string   $name              The name of the XSL file.
     * @param callback $building_function Function to build your XSL file.
     * @param string   $rewrite           Optional. Regular expression to match your sitemap with.
     */
    public function register_xsl($name, $building_function, $rewrite = '')
    {
    }
    /**
     * Set the sitemap current page to allow creating partial sitemaps with WP-CLI
     * in a one-off process.
     *
     * @param int $current_page The part that should be generated.
     */
    public function set_n($current_page)
    {
    }
    /**
     * Set the sitemap content to display after you have generated it.
     *
     * @param string $sitemap The generated sitemap to output.
     */
    public function set_sitemap($sitemap)
    {
    }
    /**
     * Set as true to make the request 404. Used stop the display of empty sitemaps or invalid requests.
     *
     * @param bool $is_bad Is this a bad request. True or false.
     */
    public function set_bad_sitemap($is_bad)
    {
    }
    /**
     * Prevent stupid plugins from running shutdown scripts when we're obviously not outputting HTML.
     *
     * @since 1.4.16
     */
    public function sitemap_close()
    {
    }
    /**
     * Hijack requests for potential sitemaps and XSL files.
     *
     * @param \WP_Query $query Main query instance.
     */
    public function redirect($query)
    {
    }
    /**
     * Try to get the sitemap from cache.
     *
     * @param string $type        Sitemap type.
     * @param int    $page_number The page number to retrieve.
     *
     * @return bool If the sitemap has been retrieved from cache.
     */
    private function get_sitemap_from_cache($type, $page_number)
    {
    }
    /**
     * Build and save sitemap to cache.
     *
     * @param string $type        Sitemap type.
     * @param int    $page_number The page number to save to.
     *
     * @return bool
     */
    private function refresh_sitemap_cache($type, $page_number)
    {
    }
    /**
     * Attempts to build the requested sitemap.
     *
     * Sets $bad_sitemap if this isn't for the root sitemap, a post type or taxonomy.
     *
     * @param string $type The requested sitemap's identifier.
     */
    public function build_sitemap($type)
    {
    }
    /**
     * Build the root sitemap (example.com/sitemap_index.xml) which lists sub-sitemaps for other content types.
     */
    public function build_root_map()
    {
    }
    /**
     * Spits out the XSL for the XML sitemap.
     *
     * @since 1.4.13
     *
     * @param string $type Type to output.
     */
    public function xsl_output($type)
    {
    }
    /**
     * Spit out the generated sitemap.
     */
    public function output()
    {
    }
    /**
     * Makes a request to the sitemap index to cache it before the arrival of the search engines.
     *
     * @return void
     */
    public function hit_sitemap_index()
    {
    }
    /**
     * Get the GMT modification date for the last modified post in the post type.
     *
     * @since 3.2
     *
     * @param string|array $post_types Post type or array of types.
     * @param bool         $return_all Flag to return array of values.
     *
     * @return string|array|false
     */
    public static function get_last_modified_gmt($post_types, $return_all = \false)
    {
    }
    /**
     * Get the modification date for the last modified post in the post type.
     *
     * @param array $post_types Post types to get the last modification date for.
     *
     * @return string
     */
    public function get_last_modified($post_types)
    {
    }
    // phpcs:disable Generic.CodeAnalysis.UnusedFunctionParameter.Found -- Argument is kept for documentation purposes.
    /**
     * Notify search engines of the updated sitemap.
     *
     * @deprecated 19.2
     *
     * @codeCoverageIgnore
     *
     * @param string|null $url Optional URL to make the ping for.
     */
    public static function ping_search_engines($url = \null)
    {
    }
    // phpcs:enable
    /**
     * Get the maximum number of entries per XML sitemap.
     *
     * @return int The maximum number of entries.
     */
    protected function get_entries_per_page()
    {
    }
    /**
     * Get post statuses for post_type or the root sitemap.
     *
     * @since 10.2
     *
     * @param string $type Provide a type for a post_type sitemap, SITEMAP_INDEX_TYPE for the root sitemap.
     *
     * @return array List of post statuses.
     */
    public static function get_post_statuses($type = self::SITEMAP_INDEX_TYPE)
    {
    }
    /**
     * Sends all the required HTTP Headers.
     */
    private function send_headers()
    {
    }
  }
  /**
   * WPSEO plugin file.
   *
   * @package WPSEO\XML_Sitemaps
   */
  /**
   * Sitemap provider for author archives.
   */
  class WPSEO_Taxonomy_Sitemap_Provider implements \WPSEO_Sitemap_Provider
  {
    /**
     * Holds image parser instance.
     *
     * @var WPSEO_Sitemap_Image_Parser
     */
    protected static $image_parser;
    /**
     * Determines whether images should be included in the XML sitemap.
     *
     * @var bool
     */
    private $include_images;
    /**
     * Set up object properties for data reuse.
     */
    public function __construct()
    {
    }
    /**
     * Check if provider supports given item type.
     *
     * @param string $type Type string to check for.
     *
     * @return bool
     */
    public function handles_type($type)
    {
    }
    /**
     * Retrieves the links for the sitemap.
     *
     * @param int $max_entries Entries per sitemap.
     *
     * @return array
     */
    public function get_index_links($max_entries)
    {
    }
    /**
     * Get set of sitemap link data.
     *
     * @param string $type         Sitemap type.
     * @param int    $max_entries  Entries per sitemap.
     * @param int    $current_page Current page of the sitemap.
     *
     * @return array
     *
     * @throws OutOfBoundsException When an invalid page is requested.
     */
    public function get_sitemap_links($type, $max_entries, $current_page)
    {
    }
    /**
     * Check if taxonomy by name is valid to appear in sitemaps.
     *
     * @param string $taxonomy_name Taxonomy name to check.
     *
     * @return bool
     */
    public function is_valid_taxonomy($taxonomy_name)
    {
    }
    /**
     * Get the Image Parser.
     *
     * @return WPSEO_Sitemap_Image_Parser
     */
    protected function get_image_parser()
    {
    }
  }
}

namespace Yoast\WP\Lib {
  /**
   * Abstract class to extend for the main class in a plugin.
   */
  abstract class Abstract_Main
  {
    /**
     * The DI container.
     *
     * @var ContainerInterface|null
     */
    protected $container;
    /**
     * A cache for previously requested and constructed surfaces.
     *
     * @var mixed[]
     */
    private $cached_surfaces = [];
    /**
     * Loads the plugin.
     *
     * @throws Exception If loading fails and YOAST_ENVIRONMENT is development.
     */
    public function load()
    {
    }
    /**
     * Magic getter for retrieving a property from a surface.
     *
     * @param string $property The property to retrieve.
     *
     * @return mixed The value of the property.
     *
     * @throws Exception When the property doesn't exist.
     */
    public function __get($property)
    {
    }
    /**
     * Checks if the given property exists as a surface.
     *
     * @param string $property The property to retrieve.
     *
     * @return bool True when property is set.
     */
    public function __isset($property)
    {
    }
    /**
     * Prevents setting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name  The property name.
     * @param mixed  $value The property value.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Set is never meant to be called.
     */
    public function __set($name, $value)
    {
    }
    /**
     * Prevents unsetting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name The property name.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Unset is never meant to be called.
     */
    public function __unset($name)
    {
    }
    /**
     * Loads the DI container.
     *
     * @return ContainerInterface|null The DI container.
     *
     * @throws Exception If something goes wrong generating the DI container.
     */
    protected abstract function get_container();
    /**
     * Gets the name of the plugin.
     *
     * @return string The name.
     */
    protected abstract function get_name();
    /**
     * Gets the surfaces of this plugin.
     *
     * @return array A mapping of surface name to the responsible class.
     */
    protected abstract function get_surfaces();
    /**
     * Returns whether or not we're in an environment for Yoast development.
     *
     * @return bool Whether or not to load in development mode.
     */
    protected function is_development()
    {
    }
  }
}

namespace Yoast\WP\Lib\Dependency_Injection {
  /**
   * Container_Registry class.
   */
  class Container_Registry
  {
    /**
     * The registered containers.
     *
     * @var ContainerInterface[]
     */
    private static $containers = [];
    /**
     * Register a container.
     *
     * @param string             $name      The name of the container.
     * @param ContainerInterface $container The container.
     *
     * @return void
     */
    public static function register($name, \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container)
    {
    }
    // phpcs:disable Squiz.Commenting.FunctionCommentThrowTag.WrongNumber -- PHPCS doesn't take into account exceptions thrown in called methods.
    /**
     * Get an instance from a specific container.
     *
     * @param string $name              The name of the container.
     * @param string $id                The ID of the service.
     * @param int    $invalid_behaviour The behaviour when the service could not be found.
     *
     * @return object|null The service.
     *
     * @throws ServiceCircularReferenceException When a circular reference is detected.
     * @throws ServiceNotFoundException          When the service is not defined.
     */
    public static function get($name, $id, $invalid_behaviour = 1)
    {
    }
    // phpcs:enable Squiz.Commenting.FunctionCommentThrowTag.WrongNumber
    /**
     * Attempts to find a given service ID in all registered containers.
     *
     * @param string $id The service ID.
     *
     * @return string|null The name of the container if the service was found.
     */
    public static function find($id)
    {
    }
  }
}

namespace Yoast\WP\Lib {
  /**
   * Make Model compatible with WordPress.
   *
   * Model base class. Your model objects should extend
   * this class. A minimal subclass would look like:
   *
   * class Widget extends Model {
   * }
   */
  class Model implements \JsonSerializable
  {
    /**
     * Default ID column for all models. Can be overridden by adding
     * a public static $id_column property to your model classes.
     *
     * @var string
     */
    const DEFAULT_ID_COLUMN = 'id';
    /**
     * Default foreign key suffix used by relationship methods.
     *
     * @var string
     */
    const DEFAULT_FOREIGN_KEY_SUFFIX = '_id';
    /**
     * Set a prefix for model names. This can be a namespace or any other
     * abitrary prefix such as the PEAR naming convention.
     *
     * @example Model::$auto_prefix_models = 'MyProject_MyModels_'; //PEAR
     * @example Model::$auto_prefix_models = '\MyProject\MyModels\'; //Namespaces
     *
     * @var string
     */
    public static $auto_prefix_models = '\\Yoast\\WP\\SEO\\Models\\';
    /**
     * Set true to to ignore namespace information when computing table names
     * from class names.
     *
     * @example Model::$short_table_names = true;
     * @example Model::$short_table_names = false; // default
     *
     * @var bool
     */
    public static $short_table_names = false;
    /**
     * The ORM instance used by this model instance to communicate with the database.
     *
     * @var ORM
     */
    public $orm;
    /**
     * The table name for the implemented Model.
     *
     * @var string
     */
    public static $table;
    /**
     * Whether or not this model uses timestamps.
     *
     * @var bool
     */
    protected $uses_timestamps = false;
    /**
     * Which columns contain boolean values.
     *
     * @var array
     */
    protected $boolean_columns = [];
    /**
     * Which columns contain int values.
     *
     * @var array
     */
    protected $int_columns = [];
    /**
     * Which columns contain float values.
     *
     * @var array
     */
    protected $float_columns = [];
    /**
     * Hacks around the Model to provide WordPress prefix to tables.
     *
     * @param string $class_name   Type of Model to load.
     * @param bool   $yoast_prefix Optional. True to prefix the table name with the Yoast prefix.
     *
     * @return ORM Wrapper to use.
     */
    public static function of_type($class_name, $yoast_prefix = true)
    {
    }
    /**
     * Creates a model without the Yoast prefix.
     *
     * @param string $class_name Type of Model to load.
     *
     * @return ORM
     */
    public static function of_wp_type($class_name)
    {
    }
    /**
     * Exposes method to get the table name to use.
     *
     * @param string $table_name   Simple table name.
     * @param bool   $yoast_prefix Optional. True to prefix the table name with the Yoast prefix.
     *
     * @return string Prepared full table name.
     */
    public static function get_table_name($table_name, $yoast_prefix = true)
    {
    }
    /**
     * Sets the table name for the given class name.
     *
     * @param string $class_name The class to set the table name for.
     *
     * @return void
     */
    protected function set_table_name($class_name)
    {
    }
    /**
     * Retrieve the value of a static property on a class. If the
     * class or the property does not exist, returns the default
     * value supplied as the third argument (which defaults to null).
     *
     * @param string     $class_name    The target class name.
     * @param string     $property      The property to get the value for.
     * @param mixed|null $default_value Default value when property does not exist.
     *
     * @return mixed|null The value of the property.
     */
    protected static function get_static_property($class_name, $property, $default_value = null)
    {
    }
    /**
     * Static method to get a table name given a class name.
     * If the supplied class has a public static property
     * named $table, the value of this property will be
     * returned.
     *
     * If not, the class name will be converted using
     * the class_name_to_table_name() method.
     *
     * If Model::$short_table_names == true or public static
     * property $table_use_short_name == true then $class_name passed
     * to class_name_to_table_name() is stripped of namespace information.
     *
     * @param string $class_name The class name to get the table name for.
     *
     * @return string The table name.
     */
    protected static function get_table_name_for_class($class_name)
    {
    }
    /**
     * Should short table names, disregarding class namespaces, be computed?
     *
     * $class_property overrides $global_option, unless $class_property is null.
     *
     * @param string $class_name The class name to get short name for.
     *
     * @return bool True when short table name should be used.
     */
    protected static function use_short_table_name($class_name)
    {
    }
    /**
     * Convert a namespace to the standard PEAR underscore format.
     *
     * Then convert a class name in CapWords to a table name in
     * lowercase_with_underscores.
     *
     * Finally strip doubled up underscores.
     *
     * For example, CarTyre would be converted to car_tyre. And
     * Project\Models\CarTyre would be project_models_car_tyre.
     *
     * @param string $class_name The class name to get the table name for.
     *
     * @return string The table name.
     */
    protected static function class_name_to_table_name($class_name)
    {
    }
    /**
     * Return the ID column name to use for this class. If it is
     * not set on the class, returns null.
     *
     * @param string $class_name The class name to get the ID column for.
     *
     * @return string|null The ID column name.
     */
    protected static function get_id_column_name($class_name)
    {
    }
    /**
     * Build a foreign key based on a table name. If the first argument
     * (the specified foreign key column name) is null, returns the second
     * argument (the name of the table) with the default foreign key column
     * suffix appended.
     *
     * @param string $specified_foreign_key_name The keyname to build.
     * @param string $table_name                 The table name to build the key name for.
     *
     * @return string The built foreign key name.
     */
    protected static function build_foreign_key_name($specified_foreign_key_name, $table_name)
    {
    }
    /**
     * Factory method used to acquire instances of the given class.
     * The class name should be supplied as a string, and the class
     * should already have been loaded by PHP (or a suitable autoloader
     * should exist). This method actually returns a wrapped ORM object
     * which allows a database query to be built. The wrapped ORM object is
     * responsible for returning instances of the correct class when
     * its find_one or find_many methods are called.
     *
     * @param string $class_name The target class name.
     *
     * @return ORM Instance of the ORM wrapper.
     */
    public static function factory($class_name)
    {
    }
    /**
     * Internal method to construct the queries for both the has_one and
     * has_many methods. These two types of association are identical; the
     * only difference is whether find_one or find_many is used to complete
     * the method chain.
     *
     * @param string      $associated_class_name                    The associated class name.
     * @param string|null $foreign_key_name                         The foreign key name in the associated table.
     * @param string|null $foreign_key_name_in_current_models_table The foreign key in the current models table.
     *
     * @return ORM Instance of the ORM.
     *
     * @throws \Exception When ID of current model has a null value.
     */
    protected function has_one_or_many($associated_class_name, $foreign_key_name = null, $foreign_key_name_in_current_models_table = null)
    {
    }
    /**
     * Helper method to manage one-to-one relations where the foreign
     * key is on the associated table.
     *
     * @param string      $associated_class_name                    The associated class name.
     * @param string|null $foreign_key_name                         The foreign key name in the associated table.
     * @param string|null $foreign_key_name_in_current_models_table The foreign key in the current models table.
     *
     * @return ORM Instance of the ORM.
     *
     * @throws \Exception  When ID of current model has a null value.
     */
    protected function has_one($associated_class_name, $foreign_key_name = null, $foreign_key_name_in_current_models_table = null)
    {
    }
    /**
     * Helper method to manage one-to-many relations where the foreign
     * key is on the associated table.
     *
     * @param string      $associated_class_name                    The associated class name.
     * @param string|null $foreign_key_name                         The foreign key name in the associated table.
     * @param string|null $foreign_key_name_in_current_models_table The foreign key in the current models table.
     *
     * @return ORM Instance of the ORM.
     *
     * @throws \Exception When ID has a null value.
     */
    protected function has_many($associated_class_name, $foreign_key_name = null, $foreign_key_name_in_current_models_table = null)
    {
    }
    /**
     * Helper method to manage one-to-one and one-to-many relations where
     * the foreign key is on the base table.
     *
     * @param string      $associated_class_name                       The associated class name.
     * @param string|null $foreign_key_name                            The foreign key in the current models table.
     * @param string|null $foreign_key_name_in_associated_models_table The foreign key in the associated table.
     *
     * @return $this|null Instance of the foreign model.
     */
    protected function belongs_to($associated_class_name, $foreign_key_name = null, $foreign_key_name_in_associated_models_table = null)
    {
    }
    /**
     * Helper method to manage many-to-many relationships via an intermediate model. See
     * README for a full explanation of the parameters.
     *
     * @param string      $associated_class_name   The associated class name.
     * @param string|null $join_class_name         The class name to join.
     * @param string|null $key_to_base_table       The key to the the current models table.
     * @param string|null $key_to_associated_table The key to the associated table.
     * @param string|null $key_in_base_table       The key in the current models table.
     * @param string|null $key_in_associated_table The key in the associated table.
     *
     * @return ORM Instance of the ORM.
     */
    protected function has_many_through($associated_class_name, $join_class_name = null, $key_to_base_table = null, $key_to_associated_table = null, $key_in_base_table = null, $key_in_associated_table = null)
    {
    }
    /**
     * Set the wrapped ORM instance associated with this Model instance.
     *
     * @param ORM $orm The ORM instance to set.
     *
     * @return void
     */
    public function set_orm($orm)
    {
    }
    /**
     * Magic getter method, allows $model->property access to data.
     *
     * @param string $property The property to get.
     *
     * @return mixed The value of the property
     */
    public function __get($property)
    {
    }
    /**
     * Magic setter method, allows $model->property = 'value' access to data.
     *
     * @param string $property The property to set.
     * @param string $value    The value to set.
     *
     * @return void
     */
    public function __set($property, $value)
    {
    }
    /**
     * Magic unset method, allows unset($model->property)
     *
     * @param string $property The property to unset.
     *
     * @return void
     */
    public function __unset($property)
    {
    }
    /**
     * JSON serializer.
     *
     * @return array The data of this object.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
    }
    /**
     * Strips all nested dependencies from the debug info.
     *
     * @return array
     */
    public function __debugInfo()
    {
    }
    /**
     * Magic isset method, allows isset($model->property) to work correctly.
     *
     * @param string $property The property to check.
     *
     * @return bool True when value is set.
     */
    public function __isset($property)
    {
    }
    /**
     * Getter method, allows $model->get('property') access to data
     *
     * @param string $property The property to get.
     *
     * @return string The value of a property.
     */
    public function get($property)
    {
    }
    /**
     * Setter method, allows $model->set('property', 'value') access to data.
     *
     * @param string|array $property The property to set.
     * @param string|null  $value    The value to give.
     *
     * @return static Current object.
     */
    public function set($property, $value = null)
    {
    }
    /**
     * Setter method, allows $model->set_expr('property', 'value') access to data.
     *
     * @param string|array $property The property to set.
     * @param string|null  $value    The value to give.
     *
     * @return static Current object.
     */
    public function set_expr($property, $value = null)
    {
    }
    /**
     * Check whether the given property has changed since the object was created or saved.
     *
     * @param string $property The property to check.
     *
     * @return bool True when field is changed.
     */
    public function is_dirty($property)
    {
    }
    /**
     * Check whether the model was the result of a call to create() or not.
     *
     * @return bool True when is new.
     */
    public function is_new()
    {
    }
    /**
     * Wrapper for Idiorm's as_array method.
     *
     * @return array The models data as array.
     */
    public function as_array()
    {
    }
    /**
     * Save the data associated with this model instance to the database.
     *
     * @return bool True on success.
     */
    public function save()
    {
    }
    /**
     * Delete the database row associated with this model instance.
     *
     * @return bool|int Response of wpdb::query.
     */
    public function delete()
    {
    }
    /**
     * Get the database ID of this model instance.
     *
     * @return int The database ID of the models instance.
     *
     * @throws \Exception When the ID is a null value.
     */
    public function id()
    {
    }
    /**
     * Hydrate this model instance with an associative array of data.
     * WARNING: The keys in the array MUST match with columns in the
     * corresponding database table. If any keys are supplied which
     * do not match up with columns, the database will throw an error.
     *
     * @param array $data The data to pass to the ORM.
     *
     * @return void
     */
    public function hydrate($data)
    {
    }
    /**
     * Calls static methods directly on the ORM
     *
     * @param string $method    The method to call.
     * @param array  $arguments The arguments to use.
     *
     * @return array Result of the static call.
     */
    public static function __callStatic($method, $arguments)
    {
    }
  }
  /**
   * Yoast ORM class.
   *
   * Based on Idiorm
   *
   * URL: http://github.com/j4mie/idiorm/
   *
   * A single-class super-simple database abstraction layer for PHP.
   * Provides (nearly) zero-configuration object-relational mapping
   * and a fluent interface for building basic, commonly-used queries.
   *
   * BSD Licensed.
   *
   * Copyright (c) 2010, Jamie Matthews
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   *
   * * Redistributions in binary form must reproduce the above copyright notice,
   *   this list of conditions and the following disclaimer in the documentation
   *   and/or other materials provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * The methods documented below are magic methods that conform to PSR-1.
   * This documentation exposes these methods to doc generators and IDEs.
   *
   * @see http://www.php-fig.org/psr/psr-1/
   */
  class ORM implements \ArrayAccess
  {
    /*
         * --- CLASS CONSTANTS ---
         */
    const CONDITION_FRAGMENT = 0;
    const CONDITION_VALUES = 1;
    /*
         * --- INSTANCE PROPERTIES ---
         */
    /**
     * Holds the class name. Wrapped find_one and find_many classes will return an instance or instances of this class.
     *
     * @var string
     */
    protected $class_name;
    /**
     * Holds the name of the table the current ORM instance is associated with.
     *
     * @var string
     */
    protected $table_name;
    /**
     * Holds the alias for the table to be used in SELECT queries.
     *
     * @var string
     */
    protected $table_alias = null;
    /**
     * Values to be bound to the query.
     *
     * @var array
     */
    protected $values = [];
    /**
     * Columns to select in the result.
     *
     * @var array
     */
    protected $result_columns = ['*'];
    /**
     * Are we using the default result column or have these been manually changed?
     *
     * @var bool
     */
    protected $using_default_result_columns = true;
    /**
     * Holds the join sources.
     *
     * @var array
     */
    protected $join_sources = [];
    /**
     * Should the query include a DISTINCT keyword?
     *
     * @var bool
     */
    protected $distinct = false;
    /**
     * Is this a raw query?
     *
     * @var bool
     */
    protected $is_raw_query = false;
    /**
     * The raw query.
     *
     * @var string
     */
    protected $raw_query = '';
    /**
     * The raw query parameters.
     *
     * @var array
     */
    protected $raw_parameters = [];
    /**
     * Array of WHERE clauses.
     *
     * @var array
     */
    protected $where_conditions = [];
    /**
     * LIMIT.
     *
     * @var int
     */
    protected $limit = null;
    /**
     * OFFSET.
     *
     * @var int
     */
    protected $offset = null;
    /**
     * ORDER BY.
     *
     * @var array
     */
    protected $order_by = [];
    /**
     * GROUP BY.
     *
     * @var array
     */
    protected $group_by = [];
    /**
     * HAVING.
     *
     * @var array
     */
    protected $having_conditions = [];
    /**
     * The data for a hydrated instance of the class.
     *
     * @var array
     */
    protected $data = [];
    /**
     * Lifetime of the object.
     *
     * @var array
     */
    protected $dirty_fields = [];
    /**
     * Fields that are to be inserted in the DB raw.
     *
     * @var array
     */
    protected $expr_fields = [];
    /**
     * Is this a new object (has create() been called)?
     *
     * @var bool
     */
    protected $is_new = false;
    /**
     * Name of the column to use as the primary key for
     * this instance only. Overrides the config settings.
     *
     * @var string
     */
    protected $instance_id_column = null;
    /*
         * --- STATIC METHODS ---
         */
    /**
     * Factory method, return an instance of this class bound to the supplied
     * table name.
     *
     * A repeat of content in parent::for_table, so that created class is ORM.
     *
     * @param string $table_name The table to create instance for.
     *
     * @return ORM Instance of the ORM.
     */
    public static function for_table($table_name)
    {
    }
    /**
     * Executes a raw query as a wrapper for wpdb::query.
     * Useful for queries that can't be accomplished through Idiorm,
     * particularly those using engine-specific features.
     *
     * @example raw_execute('INSERT OR REPLACE INTO `widget` (`id`, `name`) SELECT `id`, `name` FROM `other_table`')
     * @example raw_execute('SELECT `name`, AVG(`order`) FROM `customer` GROUP BY `name` HAVING AVG(`order`) > 10')
     *
     * @param string $query      The raw SQL query.
     * @param array  $parameters Optional bound parameters.
     *
     * @return bool Success.
     */
    public static function raw_execute($query, $parameters = [])
    {
    }
    /**
     * Internal helper method for executing statements.
     *
     * @param string $query      The query.
     * @param array  $parameters An array of parameters to be bound in to the query.
     *
     * @return bool|int Response of wpdb::query
     */
    protected static function execute($query, $parameters = [])
    {
    }
    /*
         * --- INSTANCE METHODS ---
         */
    /**
     * "Private" constructor; shouldn't be called directly.
     * Use the ORM::for_table factory method instead.
     *
     * @param string $table_name Table name.
     * @param array  $data       Data to populate table.
     */
    protected function __construct($table_name, $data = [])
    {
    }
    /**
     * Sets the name of the class which the wrapped methods should return instances of.
     *
     * @param string $class_name The classname to set.
     *
     * @return void
     */
    public function set_class_name($class_name)
    {
    }
    /**
     * Creates a new, empty instance of the class. Used to add a new row to your database. May optionally be passed an
     * associative array of data to populate the instance. If so, all fields will be flagged as dirty so all will be
     * saved to the database when save() is called.
     *
     * @param array|null $data Data to populate table.
     *
     * @return bool|Model|ORM
     */
    public function create($data = null)
    {
    }
    /**
     * Specifies the ID column to use for this instance or array of instances only.
     * This overrides the id_column and id_column_overrides settings.
     *
     * This is mostly useful for libraries built on top of Idiorm, and will not normally be used in manually built
     * queries. If you don't know why you would want to use this, you should probably just ignore it.
     *
     * @param string $id_column The ID column.
     *
     * @return ORM
     */
    public function use_id_column($id_column)
    {
    }
    /**
     * Creates an ORM instance from the given row (an associative array of data fetched from the database).
     *
     * @param array $row A row from the database.
     *
     * @return bool|Model
     */
    protected function create_instance_from_row($row)
    {
    }
    /**
     * Tells the ORM that you are expecting a single result back from your query, and execute it. Will return a single
     * instance of the ORM class, or false if no rows were returned. As a shortcut, you may supply an ID as a parameter
     * to this method. This will perform a primary key lookup on the table.
     *
     * @param int|null $id An (optional) ID.
     *
     * @return bool|Model
     */
    public function find_one($id = null)
    {
    }
    /**
     * Tells the ORM that you are expecting multiple results from your query, and execute it. Will return an array of
     * instances of the ORM class, or an empty array if no rows were returned.
     *
     * @return array
     */
    public function find_many()
    {
    }
    /**
     * Creates an instance of the model class associated with this wrapper and populate it with the supplied Idiorm
     * instance.
     *
     * @param ORM $orm The ORM used by model.
     *
     * @return bool|Model Instance of the model class.
     */
    protected function create_model_instance($orm)
    {
    }
    /**
     * Tells the ORM that you are expecting multiple results from your query, and execute it. Will return an array, or
     * an empty array if no rows were returned.
     *
     * @return array The query results.
     */
    public function find_array()
    {
    }
    /**
     * Tells the ORM that you wish to execute a COUNT query.
     *
     * @param string $column The table column.
     *
     * @return float|int An integer representing the number of rows returned.
     */
    public function count($column = '*')
    {
    }
    /**
     * Tells the ORM that you wish to execute a MAX query.
     *
     * @param string $column The table column.
     *
     * @return float|int The max value of the chosen column.
     */
    public function max($column)
    {
    }
    /**
     * Tells the ORM that you wish to execute a MIN query.
     *
     * @param string $column The table column.
     *
     * @return float|int The min value of the chosen column.
     */
    public function min($column)
    {
    }
    /**
     * Tells the ORM that you wish to execute a AVG query.
     *
     * @param string $column The table column.
     *
     * @return float|int The average value of the chosen column.
     */
    public function avg($column)
    {
    }
    /**
     * Tells the ORM that you wish to execute a SUM query.
     *
     * @param string $column The table column.
     *
     * @return float|int The sum of the chosen column.
     */
    public function sum($column)
    {
    }
    /**
     * Returns the select query as SQL.
     *
     * @return string The select query in SQL.
     */
    public function get_sql()
    {
    }
    /**
     * Returns the update query as SQL.
     *
     * @return string The update query in SQL.
     */
    public function get_update_sql()
    {
    }
    /**
     * Executes an aggregate query on the current connection.
     *
     * @param string $sql_function The aggregate function to call eg. MIN, COUNT, etc.
     * @param string $column       The column to execute the aggregate query against.
     *
     * @return int
     */
    protected function call_aggregate_db_function($sql_function, $column)
    {
    }
    /**
     * Hydrates (populate) this instance of the class from an associative array of data. This will usually be called
     * only from inside the class, but it's public in case you need to call it directly.
     *
     * @param array $data Data to populate table.
     *
     * @return ORM
     */
    public function hydrate($data = [])
    {
    }
    /**
     * Forces the ORM to flag all the fields in the $data array as "dirty" and therefore update them when save() is
     * called.
     *
     * @return ORM
     */
    public function force_all_dirty()
    {
    }
    /**
     * Performs a raw query. The query can contain placeholders in either named or question mark style. If placeholders
     * are used, the parameters should be an array of values which will be bound to the placeholders in the query.
     * If this method is called, all other query building methods will be ignored.
     *
     * @param array $query      The query.
     * @param array $parameters The parameters. Defaults to an empty array.
     *
     * @return ORM
     */
    public function raw_query($query, $parameters = [])
    {
    }
    /**
     * Adds an alias for the main table to be used in SELECT queries.
     *
     * @param string $alias The alias.
     *
     * @return ORM
     */
    public function table_alias($alias)
    {
    }
    /**
     * Adds an unquoted expression to the set of columns returned by the SELECT query. Internal method.
     *
     * @param string      $expr  The expression.
     * @param string|null $alias The alias to return the expression as. Defaults to null.
     *
     * @return ORM
     */
    protected function add_result_column($expr, $alias = null)
    {
    }
    /**
     * Counts the number of columns that belong to the primary key and their value is null.
     *
     * @return int The amount of null columns.
     *
     * @throws \Exception Primary key ID contains null value(s).
     * @throws \Exception Primary key ID missing from row or is null.
     */
    public function count_null_id_columns()
    {
    }
    /**
     * Adds a column to the list of columns returned by the SELECT query.
     *
     * @param string      $column The column. Defaults to '*'.
     * @param string|null $alias  The alias to return the column as. Defaults to null.
     *
     * @return ORM
     */
    public function select($column, $alias = null)
    {
    }
    /**
     * Adds an unquoted expression to the list of columns returned by the SELECT query.
     *
     * @param string      $expr  The expression.
     * @param string|null $alias The alias to return the column as. Defaults to null.
     *
     * @return ORM
     */
    public function select_expr($expr, $alias = null)
    {
    }
    /**
     * Adds columns to the list of columns returned by the SELECT query.
     *
     * This defaults to '*'.
     * Many columns can be supplied as either an array or as a list of parameters to the method.
     * Note that the alias must not be numeric - if you want a numeric alias then prepend it with some alpha chars. eg.
     * a1.
     *
     * @example select_many(array('column', 'column2', 'column3'), 'column4', 'column5');
     * @example select_many(array('alias' => 'column', 'column2', 'alias2' => 'column3'), 'column4', 'column5');
     * @example select_many('column', 'column2', 'column3');
     *
     * @return ORM
     */
    public function select_many()
    {
    }
    /**
     * Adds an unquoted expression to the list of columns returned by the SELECT query.
     *
     * Many columns can be supplied as either an array or as a list of parameters to the method.
     * Note that the alias must not be numeric - if you want a numeric alias then prepend it with some alpha chars. eg.
     * a1
     *
     * @example select_many_expr(array('alias' => 'column', 'column2', 'alias2' => 'column3'), 'column4', 'column5')
     * @example select_many_expr('column', 'column2', 'column3')
     * @example select_many_expr(array('column', 'column2', 'column3'), 'column4', 'column5')
     *
     * @return ORM
     */
    public function select_many_expr()
    {
    }
    /**
     * Takes a column specification for the select many methods and convert it into a normalised array of columns and
     * aliases.
     *
     * It is designed to turn the following styles into a normalised array:
     * array(array('alias' => 'column', 'column2', 'alias2' => 'column3'), 'column4', 'column5'))
     *
     * @param array $columns The columns.
     *
     * @return array
     */
    protected function normalise_select_many_columns($columns)
    {
    }
    /**
     * Adds a DISTINCT keyword before the list of columns in the SELECT query.
     *
     * @return ORM
     */
    public function distinct()
    {
    }
    /**
     * Add a JOIN source to the query. Internal method.
     *
     * The join_operator should be one of INNER, LEFT OUTER, CROSS etc - this
     * will be prepended to JOIN.
     *
     * The table should be the name of the table to join to.
     *
     * The constraint may be either a string or an array with three elements. If it
     * is a string, it will be compiled into the query as-is, with no escaping. The
     * recommended way to supply the constraint is as an array with three elements:
     *
     * first_column, operator, second_column
     *
     * Example: array('user.id', '=', 'profile.user_id')
     *
     * will compile to
     *
     * ON `user`.`id` = `profile`.`user_id`
     *
     * The final (optional) argument specifies an alias for the joined table.
     *
     * @param string      $join_operator The join_operator should be one of INNER, LEFT OUTER, CROSS etc - this will be
     *                                   prepended to JOIN.
     * @param string      $table         The table should be the name of the table to join to.
     * @param string      $constraint    The constraint.
     * @param string|null $table_alias   The alias for the joined table. Defaults to null.
     *
     * @return ORM
     */
    protected function add_join_source($join_operator, $table, $constraint, $table_alias = null)
    {
    }
    /**
     * Adds a RAW JOIN source to the query.
     *
     * @param string $table       The table name.
     * @param string $constraint  The constraint.
     * @param string $table_alias The table alias.
     * @param array  $parameters  The parameters. Defaults to an empty array.
     *
     * @return ORM
     */
    public function raw_join($table, $constraint, $table_alias, $parameters = [])
    {
    }
    /**
     * Adds a simple JOIN source to the query.
     *
     * @param string      $table       The table name.
     * @param string      $constraint  The constraint.
     * @param string|null $table_alias The table alias. Defaults to null.
     *
     * @return ORM
     */
    public function join($table, $constraint, $table_alias = null)
    {
    }
    /**
     * Adds an INNER JOIN source to the query.
     *
     * @param string      $table       The table name.
     * @param string      $constraint  The constraint.
     * @param string|null $table_alias The table alias. Defaults to null.
     *
     * @return ORM
     */
    public function inner_join($table, $constraint, $table_alias = null)
    {
    }
    /**
     * Adds a LEFT OUTER JOIN source to the query.
     *
     * @param string      $table       The table name.
     * @param string      $constraint  The constraint.
     * @param string|null $table_alias The table alias. Defaults to null.
     *
     * @return ORM
     */
    public function left_outer_join($table, $constraint, $table_alias = null)
    {
    }
    /**
     * Adds a RIGHT OUTER JOIN source to the query.
     *
     * @param string      $table       The table name.
     * @param string      $constraint  The constraint.
     * @param string|null $table_alias The table alias. Defaults to null.
     *
     * @return ORM
     */
    public function right_outer_join($table, $constraint, $table_alias = null)
    {
    }
    /**
     * Adds a FULL OUTER JOIN source to the query.
     *
     * @param string      $table       The table name.
     * @param string      $constraint  The constraint.
     * @param string|null $table_alias The table alias. Defaults to null.
     *
     * @return ORM
     */
    public function full_outer_join($table, $constraint, $table_alias = null)
    {
    }
    /**
     * Adds a HAVING condition to the query. Internal method.
     *
     * @param string $fragment The fragment.
     * @param array  $values   The values. Defaults to an empty array.
     *
     * @return ORM
     */
    protected function add_having($fragment, $values = [])
    {
    }
    /**
     * Adds a HAVING condition to the query. Internal method.
     *
     * @param string $column_name The table column.
     * @param string $separator   The separator.
     * @param mixed  $value       The value.
     *
     * @return ORM
     */
    protected function add_simple_having($column_name, $separator, $value)
    {
    }
    /**
     * Adds a HAVING clause with multiple values (like IN and NOT IN). Internal method.
     *
     * @param string|array $column_name The table column.
     * @param string       $separator   The separator.
     * @param array        $values      The values.
     *
     * @return ORM
     */
    public function add_having_placeholder($column_name, $separator, $values)
    {
    }
    /**
     * Adds a HAVING clause with no parameters(like IS NULL and IS NOT NULL). Internal method.
     *
     * @param string $column_name The column name.
     * @param string $operator    The operator.
     *
     * @return ORM
     */
    public function add_having_no_value($column_name, $operator)
    {
    }
    /**
     * Adds a WHERE condition to the query. Internal method.
     *
     * @param string $fragment The fragment.
     * @param array  $values   The values. Defaults to an empty array.
     *
     * @return ORM
     */
    protected function add_where($fragment, $values = [])
    {
    }
    /**
     * Adds a WHERE condition to the query. Internal method.
     *
     * @param string|array $column_name The table column.
     * @param string       $separator   The separator.
     * @param mixed        $value       The value.
     *
     * @return ORM
     */
    protected function add_simple_where($column_name, $separator, $value)
    {
    }
    /**
     * Adds a WHERE clause with multiple values (like IN and NOT IN).
     *
     * @param string|array $column_name The table column.
     * @param string       $separator   The separator.
     * @param array        $values      The values.
     *
     * @return ORM
     */
    public function add_where_placeholder($column_name, $separator, $values)
    {
    }
    /**
     * Adds a WHERE clause with no parameters(like IS NULL and IS NOT NULL).
     *
     * @param string $column_name The column name.
     * @param string $operator    The operator.
     *
     * @return ORM
     */
    public function add_where_no_value($column_name, $operator)
    {
    }
    /**
     * Adds a HAVING or WHERE condition to the query. Internal method.
     *
     * @param string $type     The type.
     * @param string $fragment The fragment.
     * @param array  $values   The values. Defaults to empty array.
     *
     * @return ORM
     */
    protected function add_condition($type, $fragment, $values = [])
    {
    }
    /**
     * Compiles a simple COLUMN SEPARATOR VALUE style HAVING or WHERE condition into a string and value ready to be
     * passed to the add_condition method.
     *
     * Avoids duplication of the call to quote_identifier.
     * If column_name is an associative array, it will add a condition for each column.
     *
     * @param string       $type        The type.
     * @param string|array $column_name The table column.
     * @param string       $separator   The separator.
     * @param mixed        $value       The value.
     *
     * @return ORM
     */
    protected function add_simple_condition($type, $column_name, $separator, $value)
    {
    }
    /**
     * Returns a string containing the given number of question marks, separated by commas. Eg "?, ?, ?".
     *
     * @param array $fields Fields to create placeholder for.
     *
     * @return string
     */
    protected function create_placeholders($fields)
    {
    }
    /**
     * Filters a column/value array returning only those columns that belong to a compound primary key.
     *
     * If the key contains a column that does not exist in the given array, a null value will be returned for it.
     *
     * @param mixed $value The value.
     *
     * @return array
     */
    protected function get_compound_id_column_values($value)
    {
    }
    /**
     * Filters an array containing compound column/value arrays.
     *
     * @param array $values The values.
     *
     * @return array
     */
    protected function get_compound_id_column_values_array($values)
    {
    }
    /**
     * Add a WHERE column = value clause to your query. Each time this is called in the chain, an additional WHERE will
     * be added, and these will be ANDed together when the final query is built.
     *
     * If you use an array in $column_name, a new clause will be added for each element. In this case, $value is
     * ignored.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where($column_name, $value = null)
    {
    }
    /**
     * More explicitly named version of for the where() method. Can be used if preferred.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_equal($column_name, $value = null)
    {
    }
    /**
     * Add a WHERE column != value clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_not_equal($column_name, $value = null)
    {
    }
    /**
     * Queries the table by its primary key. Special method.
     *
     * If primary key is compound, only the columns that belong to they key will be used for the query.
     *
     * @param string $id The ID.
     *
     * @return ORM
     */
    public function where_id_is($id)
    {
    }
    /**
     * Allows adding a WHERE clause that matches any of the conditions specified in the array. Each element in the
     * associative array will be a different condition, where the key will be the column name.
     *
     * By default, an equal operator will be used against all columns, but it can be overriden for any or every column
     * using the second parameter.
     *
     * Each condition will be ORed together when added to the final query.
     *
     * @param array  $values   The values.
     * @param string $operator The operator.
     *
     * @return ORM
     */
    public function where_any_is($values, $operator = '=')
    {
    }
    /**
     * Queries the table by its primary key.
     *
     * Similar to where_id_is() but allowing multiple primary keys.
     * If primary key is compound, only the columns that belong to they key will be used for the query.
     *
     * @param string[] $ids The IDs.
     *
     * @return ORM
     */
    public function where_id_in($ids)
    {
    }
    /**
     * Adds a WHERE ... LIKE clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_like($column_name, $value = null)
    {
    }
    /**
     * Adds where WHERE ... NOT LIKE clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_not_like($column_name, $value = null)
    {
    }
    /**
     * Adds a WHERE ... > clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_gt($column_name, $value = null)
    {
    }
    /**
     * Adds a WHERE ... < clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_lt($column_name, $value = null)
    {
    }
    /**
     * Adds a WHERE ... >= clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_gte($column_name, $value = null)
    {
    }
    /**
     * Adds a WHERE ... <= clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function where_lte($column_name, $value = null)
    {
    }
    /**
     * Adds a WHERE ... IN clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param array        $values      The values.
     *
     * @return ORM
     */
    public function where_in($column_name, $values)
    {
    }
    /**
     * Adds a WHERE ... NOT IN clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param array        $values      The values.
     *
     * @return ORM
     */
    public function where_not_in($column_name, $values)
    {
    }
    /**
     * Adds a WHERE column IS NULL clause to your query.
     *
     * @param string|array $column_name The table column.
     *
     * @return ORM
     */
    public function where_null($column_name)
    {
    }
    /**
     * Adds a WHERE column IS NOT NULL clause to your query.
     *
     * @param string|array $column_name The table column.
     *
     * @return ORM
     */
    public function where_not_null($column_name)
    {
    }
    /**
     * Adds a raw WHERE clause to the query. The clause should contain question mark placeholders, which will be bound
     * to the parameters supplied in the second argument.
     *
     * @param string $clause     The clause that should contain question mark placeholders.
     * @param array  $parameters The parameters to include in the query.
     *
     * @return ORM
     */
    public function where_raw($clause, $parameters = [])
    {
    }
    /**
     * Adds a LIMIT to the query.
     *
     * @param int $limit The limit.
     *
     * @return ORM
     */
    public function limit($limit)
    {
    }
    /**
     * Adds an OFFSET to the query.
     *
     * @param int $offset The offset.
     *
     * @return ORM
     */
    public function offset($offset)
    {
    }
    /**
     * Adds an ORDER BY clause to the query.
     *
     * @param string $column_name The column name.
     * @param string $ordering    The ordering. DESC or ASC.
     *
     * @return ORM
     */
    protected function add_order_by($column_name, $ordering)
    {
    }
    /**
     * Adds an ORDER BY column DESC clause.
     *
     * @param string|array $column_name The table column.
     *
     * @return ORM
     */
    public function order_by_desc($column_name)
    {
    }
    /**
     * Adds an ORDER BY column ASC clause.
     *
     * @param string|array $column_name The table column.
     *
     * @return ORM
     */
    public function order_by_asc($column_name)
    {
    }
    /**
     * Adds an unquoted expression as an ORDER BY clause.
     *
     * @param string $clause The clause.
     *
     * @return ORM
     */
    public function order_by_expr($clause)
    {
    }
    /**
     * Adds a column to the list of columns to GROUP BY.
     *
     * @param string|array $column_name The table column.
     *
     * @return ORM
     */
    public function group_by($column_name)
    {
    }
    /**
     * Adds an unquoted expression to the list of columns to GROUP BY.
     *
     * @param string $expr The expression.
     *
     * @return ORM
     */
    public function group_by_expr($expr)
    {
    }
    /**
     * Adds a HAVING column = value clause to your query.
     *
     * Each time this is called in the chain, an additional HAVING will be added, and these will be ANDed together when
     * the final query is built.
     *
     * If you use an array in $column_name, a new clause will be added for each element. In this case, $value is
     * ignored.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value.
     *
     * @return ORM
     */
    public function having($column_name, $value = null)
    {
    }
    /**
     * Adds a having equal to your query.
     *
     * More explicitly named version of for the having() method. Can be used if preferred.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value.
     *
     * @return ORM
     */
    public function having_equal($column_name, $value = null)
    {
    }
    /**
     * Adds a HAVING column != value clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed|null   $value       The value.
     *
     * @return ORM
     */
    public function having_not_equal($column_name, $value = null)
    {
    }
    /**
     * Queries the table by its primary key. Special method.
     *
     * If primary key is compound, only the columns that belong to they key will be used for the query.
     *
     * @param string $id The ID.
     *
     * @return ORM
     */
    public function having_id_is($id)
    {
    }
    /**
     * Adds a HAVING ... LIKE clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param string|null  $value       The value.
     *
     * @return ORM
     */
    public function having_like($column_name, $value = null)
    {
    }
    /**
     * Adds where HAVING ... NOT LIKE clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param string|null  $value       The value.
     *
     * @return ORM
     */
    public function having_not_like($column_name, $value = null)
    {
    }
    /**
     * Adds a HAVING ... > clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed        $value       The value.
     *
     * @return ORM
     */
    public function having_gt($column_name, $value = null)
    {
    }
    /**
     * Adds a HAVING ... < clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed        $value       The value.
     *
     * @return ORM
     */
    public function having_lt($column_name, $value = null)
    {
    }
    /**
     * Adds a HAVING ... >= clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed        $value       The value. Defaults to null.
     *
     * @return ORM
     */
    public function having_gte($column_name, $value = null)
    {
    }
    /**
     * Adds a HAVING ... <= clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param mixed        $value       The value.
     *
     * @return ORM
     */
    public function having_lte($column_name, $value = null)
    {
    }
    /**
     * Adds a HAVING ... IN clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param array|null   $values      The values. Defaults to null.
     *
     * @return ORM
     */
    public function having_in($column_name, $values = null)
    {
    }
    /**
     * Adds a HAVING ... NOT IN clause to your query.
     *
     * @param string|array $column_name The table column.
     * @param array|null   $values      The values. Defaults to null.
     *
     * @return ORM
     */
    public function having_not_in($column_name, $values = null)
    {
    }
    /**
     * Adds a HAVING column IS NULL clause to your query.
     *
     * @param string|array $column_name The table column.
     *
     * @return ORM
     */
    public function having_null($column_name)
    {
    }
    /**
     * Adds a HAVING column IS NOT NULL clause to your query.
     *
     * @param string|array $column_name The table column.
     *
     * @return ORM
     */
    public function having_not_null($column_name)
    {
    }
    /**
     * Adds a raw HAVING clause to the query. The clause should contain question mark placeholders, which will be bound
     * to the parameters supplied in the second argument.
     *
     * @param string $clause     The clause that should contain question mark placeholders.
     * @param array  $parameters The parameters to include in the query.
     *
     * @return ORM
     */
    public function having_raw($clause, $parameters = [])
    {
    }
    /**
     * Builds a SELECT statement based on the clauses that have been passed to this instance by chaining method calls.
     *
     * @return string
     */
    protected function build_select()
    {
    }
    /**
     * Builds the start of the SELECT statement.
     *
     * @return string
     */
    protected function build_select_start()
    {
    }
    /**
     * Builds the JOIN sources.
     *
     * @return string
     */
    protected function build_join()
    {
    }
    /**
     * Builds the WHERE clause(s).
     *
     * @return string
     */
    protected function build_where()
    {
    }
    /**
     * Build the HAVING clause(s)
     *
     * @return string
     */
    protected function build_having()
    {
    }
    /**
     * Builds GROUP BY.
     *
     * @return string
     */
    protected function build_group_by()
    {
    }
    /**
     * Builds a WHERE or HAVING clause.
     *
     * @param string $type Where or having.
     *
     * @return string
     */
    protected function build_conditions($type)
    {
    }
    /**
     * Builds ORDER BY.
     *
     * @return string
     */
    protected function build_order_by()
    {
    }
    /**
     * Builds LIMIT.
     *
     * @return string
     */
    protected function build_limit()
    {
    }
    /**
     * Builds OFFSET.
     *
     * @return string
     */
    protected function build_offset()
    {
    }
    /**
     * Joins strings if they are not empty.
     *
     * @param string   $glue   Glue.
     * @param string[] $pieces Pieces to join.
     *
     * @return string
     */
    protected function join_if_not_empty($glue, $pieces)
    {
    }
    /**
     * Quotes a string that is used as an identifier (table names, column names etc).
     * This method can also deal with dot-separated identifiers eg table.column.
     *
     * @param string|string[] $identifier One or more identifiers.
     *
     * @return string
     */
    protected function quote_one_identifier($identifier)
    {
    }
    /**
     * Quotes a string that is used as an identifier (table names, column names etc) or an array containing multiple
     * identifiers. This method can also deal with dot-separated identifiers eg table.column.
     *
     * @param string|string[] $identifier One or more identifiers.
     *
     * @return string
     */
    protected function quote_identifier($identifier)
    {
    }
    /**
     * Quotes a single part of an identifier, using the identifier quote character specified in the config
     * (or autodetected).
     *
     * @param string $part The part to quote.
     *
     * @return string
     */
    protected function quote_identifier_part($part)
    {
    }
    /**
     * Executes the SELECT query that has been built up by chaining methods on this class.
     * Return an array of rows as associative arrays.
     *
     * @return array|false The result rows. False if the query failed.
     */
    protected function run()
    {
    }
    /**
     * Resets the Idiorm instance state.
     */
    private function reset_idiorm_state()
    {
    }
    /**
     * Returns the raw data wrapped by this ORM instance as an associative array. Column names may optionally be
     * supplied as arguments, if so, only those keys will be returned.
     *
     * @return array Associative array of the raw data.
     */
    public function as_array()
    {
    }
    /**
     * Returns the value of a property of this object (database row) or null if not present.
     *
     * If a column-names array is passed, it will return a associative array with the value of each column or null if
     * it is not present.
     *
     * @param string|array $key Key.
     *
     * @return array|mixed|null
     */
    public function get($key)
    {
    }
    /**
     * Returns the name of the column in the database table which contains the primary key ID of the row.
     *
     * @return string The primary key ID of the row.
     */
    protected function get_id_column_name()
    {
    }
    /**
     * Gets the primary key ID of this object.
     *
     * @param bool $disallow_null Whether to allow null IDs.
     *
     * @return array|mixed|null
     *
     * @throws \Exception Primary key ID contains null value(s).
     * @throws \Exception Primary key ID missing from row or is null.
     */
    public function id($disallow_null = false)
    {
    }
    /**
     * Sets a property to a particular value on this object.
     *
     * To set multiple properties at once, pass an associative array as the first parameter and leave out the second
     * parameter. Flags the properties as 'dirty' so they will be saved to the database when save() is called.
     *
     * @param string|array $key   Key.
     * @param string|null  $value Value.
     *
     * @return ORM
     */
    public function set($key, $value = null)
    {
    }
    /**
     * Set a property to a particular value on this object as expression.
     *
     * To set multiple properties at once, pass an associative array as the first parameter and leave out the second
     * parameter. Flags the properties as 'dirty' so they will be saved to the database when save() is called.
     *
     * @param string|array $key   Key.
     * @param string|null  $value Value.
     *
     * @return ORM
     */
    public function set_expr($key, $value = null)
    {
    }
    /**
     * Sets a property on the ORM object.
     *
     * @param string|array $key   Key.
     * @param string|null  $value Value.
     * @param bool         $expr  Expression.
     *
     * @return ORM
     */
    protected function set_orm_property($key, $value = null, $expr = false)
    {
    }
    /**
     * Checks whether the given field has been changed since this object was saved.
     *
     * @param mixed $key Key.
     *
     * @return bool
     */
    public function is_dirty($key)
    {
    }
    /**
     * Checks whether the model was the result of a call to create() or not.
     *
     * @return bool
     */
    public function is_new()
    {
    }
    /**
     * Saves any fields which have been modified on this object to the database.
     *
     * @return bool True on success.
     *
     * @throws \Exception Primary key ID contains null value(s).
     * @throws \Exception Primary key ID missing from row or is null.
     */
    public function save()
    {
    }
    /**
     * Extracts and gathers all dirty column names from the given model instances.
     *
     * @param array $models Array of model instances to be inserted.
     *
     * @return array The distinct set of columns that are dirty in at least one of the models.
     *
     * @throws \InvalidArgumentException Instance to be inserted is not a new one.
     */
    public function get_dirty_column_names($models)
    {
    }
    /**
     * Inserts multiple rows in a single query. Expects new rows as it's a strictly insert function, not an update one.
     *
     * @example From the Indexable_Link_Builder class: $this->seo_links_repository->query()->insert_many( $links );
     *
     * @param array $models Array of model instances to be inserted.
     *
     * @return bool True for successful insert, false for failed.
     *
     * @throws \InvalidArgumentException Invalid instances to be inserted.
     * @throws \InvalidArgumentException Instance to be inserted is not a new one.
     */
    public function insert_many($models)
    {
    }
    /**
     * Updates many records in the database.
     *
     * @return int|bool The number of rows changed if the query was succesful. False otherwise.
     */
    public function update_many()
    {
    }
    /**
     * Adds a WHERE clause for every column that belongs to the primary key.
     *
     * @return string The where part of the query.
     */
    public function add_id_column_conditions()
    {
    }
    /**
     * Builds an UPDATE query.
     *
     * @return string The update query.
     */
    protected function build_update()
    {
    }
    /**
     * Builds an INSERT query.
     *
     * @return string The insert query.
     */
    protected function build_insert()
    {
    }
    /**
     * Builds a bulk INSERT query.
     *
     * @param array $models             Array of model instances to be inserted.
     * @param array $dirty_column_names Array of dirty fields to be used in INSERT.
     *
     * @return string The insert query.
     */
    protected function build_insert_many($models, $dirty_column_names)
    {
    }
    /**
     * Deletes this record from the database.
     *
     * @return string The delete query.
     *
     * @throws \Exception Primary key ID contains null value(s).
     * @throws \Exception Primary key ID missing from row or is null.
     */
    public function delete()
    {
    }
    /**
     * Deletes many records from the database.
     *
     * @return bool|int Response of wpdb::query.
     */
    public function delete_many()
    {
    }
    /*
         * ---  ArrayAccess  ---
         */
    /**
     * Checks whether the data has the key.
     *
     * @param mixed $offset Key.
     *
     * @return bool Whether the data has the key.
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
    }
    /**
     * Retrieves the value of the key.
     *
     * @param mixed $offset Key.
     *
     * @return array|mixed|null The value.
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
    }
    /**
     * Sets the value of the key.
     *
     * @param string|int $offset Key.
     * @param mixed      $value  Value.
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
    }
    /**
     * Removes the given key from the data.
     *
     * @param mixed $offset Key.
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
    }
    /*
         * --- MAGIC METHODS ---
         */
    /**
     * Handles magic get via offset.
     *
     * @param mixed $key Key.
     *
     * @return array|mixed|null The value in the offset.
     */
    public function __get($key)
    {
    }
    /**
     * Handles magic set via offset.
     *
     * @param string|int $key   Key.
     * @param mixed      $value Value.
     */
    public function __set($key, $value)
    {
    }
    /**
     * Handles magic unset via offset.
     *
     * @param mixed $key Key.
     */
    public function __unset($key)
    {
    }
    /**
     * Handles magic isset via offset.
     *
     * @param mixed $key Key.
     *
     * @return bool Whether the offset has the key.
     */
    public function __isset($key)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Addon_Installation {
  /**
   * Represents the endpoint for activating a specific Yoast Plugin on WordPress.
   */
  class Addon_Activate_Action
  {
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $addon_manager;
    /**
     * The require file helper.
     *
     * @var Require_File_Helper
     */
    protected $require_file_helper;
    /**
     * Addon_Activate_Action constructor.
     *
     * @param WPSEO_Addon_Manager $addon_manager       The addon manager.
     * @param Require_File_Helper $require_file_helper A file helper.
     */
    public function __construct(\WPSEO_Addon_Manager $addon_manager, \Yoast\WP\SEO\Helpers\Require_File_Helper $require_file_helper)
    {
    }
    /**
     * Activates the plugin based on the given plugin file.
     *
     * @param string $plugin_slug The plugin slug to get download url for.
     *
     * @return bool True when activation is successful.
     *
     * @throws Addon_Activation_Error_Exception       Exception when the activation encounters an error.
     * @throws User_Cannot_Activate_Plugins_Exception Exception when the user is not allowed to activate.
     */
    public function activate_addon($plugin_slug)
    {
    }
    /**
     * Requires the files needed from WordPress itself.
     *
     * @codeCoverageIgnore Only loads a WordPress file.
     *
     * @return void
     */
    protected function load_wordpress_classes()
    {
    }
  }
  /**
   * Represents the endpoint for downloading and installing a zip-file from MyYoast.
   */
  class Addon_Install_Action
  {
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $addon_manager;
    /**
     * The require file helper.
     *
     * @var Require_File_Helper
     */
    protected $require_file_helper;
    /**
     * Addon_Activate_Action constructor.
     *
     * @param WPSEO_Addon_Manager $addon_manager       The addon manager.
     * @param Require_File_Helper $require_file_helper A helper that can require files.
     */
    public function __construct(\WPSEO_Addon_Manager $addon_manager, \Yoast\WP\SEO\Helpers\Require_File_Helper $require_file_helper)
    {
    }
    /**
     * Installs the plugin based on the given slug.
     *
     * @param string $plugin_slug  The plugin slug to install.
     * @param string $download_url The plugin download URL.
     *
     * @return bool True when install is successful.
     *
     * @throws Addon_Already_Installed_Exception  When the addon is already installed.
     * @throws Addon_Installation_Error_Exception When the installation encounters an error.
     * @throws User_Cannot_Install_Plugins_Exception        When the user does not have the permissions to install plugins.
     */
    public function install_addon($plugin_slug, $download_url)
    {
    }
    /**
     * Requires the files needed from WordPress itself.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    protected function load_wordpress_classes()
    {
    }
    /**
     * Checks is a plugin is installed.
     *
     * @param string $plugin_slug The plugin to check.
     *
     * @return bool True when plugin is installed.
     */
    protected function is_installed($plugin_slug)
    {
    }
    /**
     * Runs the installation by using the WordPress installation routine.
     *
     * @codeCoverageIgnore Contains WordPress specific logic.
     *
     * @param string $plugin_download The url to the download.
     *
     * @return bool|WP_Error True when success, WP_Error when something went wrong.
     */
    protected function install($plugin_download)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions {
  /**
   * Class Alert_Dismissal_Action.
   */
  class Alert_Dismissal_Action
  {
    const USER_META_KEY = '_yoast_alerts_dismissed';
    /**
     * Holds the user helper instance.
     *
     * @var User_Helper
     */
    protected $user;
    /**
     * Constructs Alert_Dismissal_Action.
     *
     * @param User_Helper $user User helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\User_Helper $user)
    {
    }
    /**
     * Dismisses an alert.
     *
     * @param string $alert_identifier Alert identifier.
     *
     * @return bool Whether the dismiss was successful or not.
     */
    public function dismiss($alert_identifier)
    {
    }
    /**
     * Resets an alert.
     *
     * @param string $alert_identifier Alert identifier.
     *
     * @return bool Whether the reset was successful or not.
     */
    public function reset($alert_identifier)
    {
    }
    /**
     * Returns if an alert is dismissed or not.
     *
     * @param string $alert_identifier Alert identifier.
     *
     * @return bool Whether the alert has been dismissed.
     */
    public function is_dismissed($alert_identifier)
    {
    }
    /**
     * Returns an object with all alerts dismissed by current user.
     *
     * @return array|false An array with the keys of all Alerts that have been dismissed
     *                     by the current user or `false`.
     */
    public function all_dismissed()
    {
    }
    /**
     * Returns if an alert is allowed or not.
     *
     * @param string $alert_identifier Alert identifier.
     *
     * @return bool Whether the alert is allowed.
     */
    public function is_allowed($alert_identifier)
    {
    }
    /**
     * Retrieves the dismissed alerts.
     *
     * @param int $user_id User ID.
     *
     * @return string[]|false The dismissed alerts. False for an invalid $user_id.
     */
    protected function get_dismissed_alerts($user_id)
    {
    }
    /**
     * Retrieves the allowed dismissable alerts.
     *
     * @return string[] The allowed dismissable alerts.
     */
    protected function get_allowed_dismissable_alerts()
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Configuration {
  /**
   * Class First_Time_Configuration_Action.
   */
  class First_Time_Configuration_Action
  {
    /**
     * The fields for the site representation payload.
     */
    const SITE_REPRESENTATION_FIELDS = ['company_or_person', 'company_name', 'website_name', 'company_logo', 'company_logo_id', 'person_logo', 'person_logo_id', 'company_or_person_user_id', 'description'];
    /**
     * The Options_Helper instance.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The Social_Profiles_Helper instance.
     *
     * @var Social_Profiles_Helper
     */
    protected $social_profiles_helper;
    /**
     * First_Time_Configuration_Action constructor.
     *
     * @param Options_Helper         $options_helper         The WPSEO options helper.
     * @param Social_Profiles_Helper $social_profiles_helper The social profiles helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Social_Profiles_Helper $social_profiles_helper)
    {
    }
    /**
     * Stores the values for the site representation.
     *
     * @param array $params The values to store.
     *
     * @return object The response object.
     */
    public function set_site_representation($params)
    {
    }
    /**
     * Stores the values for the social profiles.
     *
     * @param array $params The values to store.
     *
     * @return object The response object.
     */
    public function set_social_profiles($params)
    {
    }
    /**
     * Stores the values for the social profiles.
     *
     * @param array $params The values to store.
     *
     * @return object The response object.
     */
    public function set_person_social_profiles($params)
    {
    }
    /**
     * Gets the values for the social profiles.
     *
     * @param int $user_id The person ID.
     *
     * @return object The response object.
     */
    public function get_person_social_profiles($user_id)
    {
    }
    /**
     * Stores the values to enable/disable tracking.
     *
     * @param array $params The values to store.
     *
     * @return object The response object.
     */
    public function set_enable_tracking($params)
    {
    }
    /**
     * Checks if the current user has the capability a specific user.
     *
     * @param int $user_id The id of the user to be edited.
     *
     * @return object The response object.
     */
    public function check_capability($user_id)
    {
    }
    /**
     * Stores the first time configuration state.
     *
     * @param array $params The values to store.
     *
     * @return object The response object.
     */
    public function save_configuration_state($params)
    {
    }
    /**
     * Gets the first time configuration state.
     *
     * @return object The response object.
     */
    public function get_configuration_state()
    {
    }
    /**
     * Checks if the current user has the capability to edit a specific user.
     *
     * @param int $person_id The id of the person to edit.
     *
     * @return bool
     */
    private function can_edit_profile($person_id)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Indexing {
  /**
   * Interface definition of reindexing action for indexables.
   */
  interface Indexation_Action_Interface
  {
    /**
     * Returns the total number of unindexed objects.
     *
     * @return int The total number of unindexed objects.
     */
    public function get_total_unindexed();
    /**
     * Indexes a number of objects.
     *
     * NOTE: ALWAYS use limits, this method is intended to be called multiple times over several requests.
     *
     * For indexing that requires JavaScript simply return the objects that should be indexed.
     *
     * @return array The reindexed objects.
     */
    public function index();
    /**
     * Returns the number of objects that will be indexed in a single indexing pass.
     *
     * @return int The limit.
     */
    public function get_limit();
  }
  /**
   * Interface definition of a reindexing action for indexables that have a limited unindexed count.
   */
  interface Limited_Indexing_Action_Interface
  {
    /**
     * Returns a limited number of unindexed posts.
     *
     * @param int $limit Limit the maximum number of unindexed posts that are counted.
     *
     * @return int|false The limited number of unindexed posts. False if the query fails.
     */
    public function get_limited_unindexed_count($limit);
  }
}

namespace Yoast\WP\SEO\Actions\Importing {
  interface Importing_Action_Interface extends \Yoast\WP\SEO\Actions\Indexing\Indexation_Action_Interface, \Yoast\WP\SEO\Actions\Indexing\Limited_Indexing_Action_Interface
  {
    /**
     * Returns the name of the plugin we import from.
     *
     * @return string The plugin name.
     */
    public function get_plugin();
    /**
     * Returns the type of data we import.
     *
     * @return string The type of data.
     */
    public function get_type();
    /**
     * Whether or not this action is capable of importing given a specific plugin and type.
     *
     * @param string|null $plugin The name of the plugin being imported.
     * @param string|null $type   The component of the plugin being imported.
     *
     * @return bool True if the action can import the given plugin's data of the given type.
     */
    public function is_compatible_with($plugin = null, $type = null);
  }
  /**
   * Importing action interface.
   */
  abstract class Abstract_Aioseo_Importing_Action implements \Yoast\WP\SEO\Actions\Importing\Importing_Action_Interface
  {
    /**
     * The plugin the class deals with.
     *
     * @var string
     */
    const PLUGIN = null;
    /**
     * The type the class deals with.
     *
     * @var string
     */
    const TYPE = null;
    /**
     * The AIOSEO helper.
     *
     * @var Aioseo_Helper
     */
    protected $aioseo_helper;
    /**
     * The import cursor helper.
     *
     * @var Import_Cursor_Helper
     */
    protected $import_cursor;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * The sanitization helper.
     *
     * @var Sanitization_Helper
     */
    protected $sanitization;
    /**
     * The replacevar handler.
     *
     * @var Aioseo_Replacevar_Service
     */
    protected $replacevar_handler;
    /**
     * The robots provider service.
     *
     * @var Aioseo_Robots_Provider_Service
     */
    protected $robots_provider;
    /**
     * The robots transformer service.
     *
     * @var Aioseo_Robots_Transformer_Service
     */
    protected $robots_transformer;
    /**
     * Abstract_Aioseo_Importing_Action constructor.
     *
     * @param Import_Cursor_Helper              $import_cursor      The import cursor helper.
     * @param Options_Helper                    $options            The options helper.
     * @param Sanitization_Helper               $sanitization       The sanitization helper.
     * @param Aioseo_Replacevar_Service         $replacevar_handler The replacevar handler.
     * @param Aioseo_Robots_Provider_Service    $robots_provider    The robots provider service.
     * @param Aioseo_Robots_Transformer_Service $robots_transformer The robots transfomer service.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Import_Cursor_Helper $import_cursor, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Sanitization_Helper $sanitization, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Replacevar_Service $replacevar_handler, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service $robots_provider, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Transformer_Service $robots_transformer)
    {
    }
    /**
     * Sets the AIOSEO helper.
     *
     * @required
     *
     * @param Aioseo_Helper $aioseo_helper The AIOSEO helper.
     */
    public function set_aioseo_helper(\Yoast\WP\SEO\Helpers\Aioseo_Helper $aioseo_helper)
    {
    }
    /**
     * The name of the plugin we import from.
     *
     * @return string The plugin we import from.
     *
     * @throws Exception If the PLUGIN constant is not set in the child class.
     */
    public function get_plugin()
    {
    }
    /**
     * The data type we import from the plugin.
     *
     * @return string The data type we import from the plugin.
     *
     * @throws Exception If the TYPE constant is not set in the child class.
     */
    public function get_type()
    {
    }
    /**
     * Can the current action import the data from plugin $plugin of type $type?
     *
     * @param string|null $plugin The plugin to import from.
     * @param string|null $type   The type of data to import.
     *
     * @return bool True if this action can handle the combination of Plugin and Type.
     *
     * @throws Exception If the TYPE constant is not set in the child class.
     */
    public function is_compatible_with($plugin = null, $type = null)
    {
    }
    /**
     * Gets the completed id (to be used as a key for the importing_completed option).
     *
     * @return string The completed id.
     */
    public function get_completed_id()
    {
    }
    /**
     * Returns the stored state of completedness.
     *
     * @return int The stored state of completedness.
     */
    public function get_completed()
    {
    }
    /**
     * Stores the current state of completedness.
     *
     * @param bool $completed Whether the importer is completed.
     *
     * @return void
     */
    public function set_completed($completed)
    {
    }
    /**
     * Returns whether the importing action is enabled.
     *
     * @return bool True by default unless a child class overrides it.
     */
    public function is_enabled()
    {
    }
    /**
     * Gets the cursor id.
     *
     * @return string The cursor id.
     */
    protected function get_cursor_id()
    {
    }
    /**
     * Minimally transforms data to be imported.
     *
     * @param string $meta_data The meta data to be imported.
     *
     * @return string The transformed meta data.
     */
    public function simple_import($meta_data)
    {
    }
    /**
     * Transforms URL to be imported.
     *
     * @param string $meta_data The meta data to be imported.
     *
     * @return string The transformed URL.
     */
    public function url_import($meta_data)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Importing\Aioseo {
  /**
   * Abstract class for importing AIOSEO settings.
   */
  abstract class Abstract_Aioseo_Settings_Importing_Action extends \Yoast\WP\SEO\Actions\Importing\Abstract_Aioseo_Importing_Action
  {
    /**
     * The plugin the class deals with.
     *
     * @var string
     */
    const PLUGIN = null;
    /**
     * The type the class deals with.
     *
     * @var string
     */
    const TYPE = null;
    /**
     * The option_name of the AIOSEO option that contains the settings.
     */
    const SOURCE_OPTION_NAME = null;
    /**
     * The map of aioseo_options to yoast settings.
     *
     * @var array
     */
    protected $aioseo_options_to_yoast_map = [];
    /**
     * The tab of the aioseo settings we're working with, eg. taxonomies, posttypes.
     *
     * @var string
     */
    protected $settings_tab = '';
    /**
     * Additional mapping between AiOSEO replace vars and Yoast replace vars.
     *
     * @var array
     *
     * @see https://yoast.com/help/list-available-snippet-variables-yoast-seo/
     */
    protected $replace_vars_edited_map = [];
    /**
     * The import helper.
     *
     * @var Import_Helper
     */
    protected $import_helper;
    /**
     * Builds the mapping that ties AOISEO option keys with Yoast ones and their data transformation method.
     *
     * @return void
     */
    protected abstract function build_mapping();
    /**
     * Sets the import helper.
     *
     * @required
     *
     * @param Import_Helper $import_helper The import helper.
     */
    public function set_import_helper(\Yoast\WP\SEO\Helpers\Import_Helper $import_helper)
    {
    }
    /**
     * Retrieves the source option_name.
     *
     * @return string The source option_name.
     *
     * @throws Exception If the SOURCE_OPTION_NAME constant is not set in the child class.
     */
    public function get_source_option_name()
    {
    }
    /**
     * Returns the total number of unimported objects.
     *
     * @return int The total number of unimported objects.
     */
    public function get_total_unindexed()
    {
    }
    /**
     * Returns the limited number of unimported objects.
     *
     * @param int $limit The maximum number of unimported objects to be returned.
     *
     * @return int The limited number of unindexed posts.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Returns the number of unimported objects (limited if limit is applied).
     *
     * @param int|null $limit The maximum number of unimported objects to be returned.
     *
     * @return int The number of unindexed posts.
     */
    protected function get_unindexed_count($limit = null)
    {
    }
    /**
     * Imports AIOSEO settings.
     *
     * @return array|false An array of the AIOSEO settings that were imported or false if aioseo data was not found.
     */
    public function index()
    {
    }
    /**
     * Checks if the settings tab subsetting is set in the AIOSEO option.
     *
     * @param string $aioseo_settings The AIOSEO option.
     *
     * @return bool Whether the settings are set.
     */
    public function isset_settings_tab($aioseo_settings)
    {
    }
    /**
     * Queries the database and retrieves unimported AiOSEO settings (in chunks if a limit is applied).
     *
     * @param int|null $limit The maximum number of unimported objects to be returned.
     *
     * @return array The (maybe chunked) unimported AiOSEO settings to import.
     */
    protected function query($limit = null)
    {
    }
    /**
     * Retrieves (a chunk of, if limit is applied) the unimported AIOSEO settings.
     * To apply a chunk, we manipulate the cursor to the keys of the AIOSEO settings.
     *
     * @param array $importable_data All of the available AIOSEO settings.
     * @param int   $limit           The maximum number of unimported objects to be returned.
     *
     * @return array The (chunk of, if limit is applied)) unimported AIOSEO settings.
     */
    protected function get_unimported_chunk($importable_data, $limit)
    {
    }
    /**
     * Returns the number of objects that will be imported in a single importing pass.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
    /**
     * Maps/imports AIOSEO settings into the respective Yoast settings.
     *
     * @param string|array $setting_value The value of the AIOSEO setting at hand.
     * @param string       $setting       The setting at hand, eg. post or movie-category, separator etc.
     *
     * @return void
     */
    protected function map($setting_value, $setting)
    {
    }
    /**
     * Imports a single setting in the db after transforming it to adhere to Yoast conventions.
     *
     * @param string $setting         The name of the setting.
     * @param string $setting_value   The values of the setting.
     * @param array  $setting_mapping The mapping of the setting to Yoast formats.
     *
     * @return void
     */
    protected function import_single_setting($setting, $setting_value, $setting_mapping)
    {
    }
    /**
     * Minimally transforms boolean data to be imported.
     *
     * @param bool $meta_data The boolean meta data to be imported.
     *
     * @return bool The transformed boolean meta data.
     */
    public function simple_boolean_import($meta_data)
    {
    }
    /**
     * Imports the noindex setting, taking into consideration whether they defer to global defaults.
     *
     * @param bool  $noindex The noindex of the type, without taking into consideration whether the type defers to global defaults.
     * @param array $mapping The mapping of the setting we're working with.
     *
     * @return bool The noindex setting.
     */
    public function import_noindex($noindex, $mapping)
    {
    }
    /**
     * Returns a setting map of the robot setting for one subset of post types/taxonomies/archives.
     * For custom archives, it returns an empty array because AIOSEO excludes some custom archives from this option structure, eg. WooCommerce's products and we don't want to raise a false alarm.
     *
     * @return array The setting map of the robot setting for one subset of post types/taxonomies/archives or an empty array.
     */
    public function pluck_robot_setting_from_mapping()
    {
    }
  }
  /**
   * Importing action for cleaning up AIOSEO data.
   */
  class Aioseo_Cleanup_Action extends \Yoast\WP\SEO\Actions\Importing\Abstract_Aioseo_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'cleanup';
    /**
     * The AIOSEO meta_keys to be cleaned up.
     *
     * @var array
     */
    protected $aioseo_postmeta_keys = ['_aioseo_title', '_aioseo_description', '_aioseo_og_title', '_aioseo_og_description', '_aioseo_twitter_title', '_aioseo_twitter_description'];
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Class constructor.
     *
     * @param wpdb           $wpdb    The WordPress database instance.
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\wpdb $wpdb, \Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Retrieves the postmeta along with the db prefix.
     *
     * @return string The postmeta table name along with the db prefix.
     */
    protected function get_postmeta_table()
    {
    }
    /**
     * Just checks if the cleanup has been completed in the past.
     *
     * @return int The total number of unimported objects.
     */
    public function get_total_unindexed()
    {
    }
    /**
     * Just checks if the cleanup has been completed in the past.
     *
     * @param int $limit The maximum number of unimported objects to be returned.
     *
     * @return int|false The limited number of unindexed posts. False if the query fails.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Cleans up AIOSEO data.
     *
     * @return Indexable[]|false An array of created indexables or false if aioseo data was not found.
     */
    public function index()
    {
    }
    /**
     * Creates a DELETE query string for deleting AIOSEO postmeta data.
     *
     * @return string The query to use for importing or counting the number of items to import.
     */
    public function cleanup_postmeta_query()
    {
    }
    /**
     * Creates a TRUNCATE query string for emptying the AIOSEO indexable table, if it exists.
     *
     * @return string The query to use for importing or counting the number of items to import.
     */
    public function truncate_query()
    {
    }
    /**
     * Used nowhere. Exists to comply with the interface.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
  }
  /**
   * Importing action for AIOSEO custom archive settings data.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded
   */
  class Aioseo_Custom_Archive_Settings_Importing_Action extends \Yoast\WP\SEO\Actions\Importing\Aioseo\Abstract_Aioseo_Settings_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'custom_archive_settings';
    /**
     * The option_name of the AIOSEO option that contains the settings.
     */
    const SOURCE_OPTION_NAME = 'aioseo_options_dynamic';
    /**
     * The map of aioseo_options to yoast settings.
     *
     * @var array
     */
    protected $aioseo_options_to_yoast_map = [];
    /**
     * The tab of the aioseo settings we're working with.
     *
     * @var string
     */
    protected $settings_tab = 'archives';
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type;
    /**
     * Aioseo_Custom_Archive_Settings_Importing_Action constructor.
     *
     * @param Import_Cursor_Helper              $import_cursor      The import cursor helper.
     * @param Options_Helper                    $options            The options helper.
     * @param Sanitization_Helper               $sanitization       The sanitization helper.
     * @param Post_Type_Helper                  $post_type          The post type helper.
     * @param Aioseo_Replacevar_Service         $replacevar_handler The replacevar handler.
     * @param Aioseo_Robots_Provider_Service    $robots_provider    The robots provider service.
     * @param Aioseo_Robots_Transformer_Service $robots_transformer The robots transfomer service.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Import_Cursor_Helper $import_cursor, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Sanitization_Helper $sanitization, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Replacevar_Service $replacevar_handler, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service $robots_provider, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Transformer_Service $robots_transformer)
    {
    }
    /**
     * Builds the mapping that ties AOISEO option keys with Yoast ones and their data transformation method.
     *
     * @return void
     */
    protected function build_mapping()
    {
    }
  }
  /**
   * Importing action for AIOSEO default archive settings data.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded
   */
  class Aioseo_Default_Archive_Settings_Importing_Action extends \Yoast\WP\SEO\Actions\Importing\Aioseo\Abstract_Aioseo_Settings_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'default_archive_settings';
    /**
     * The option_name of the AIOSEO option that contains the settings.
     */
    const SOURCE_OPTION_NAME = 'aioseo_options';
    /**
     * The map of aioseo_options to yoast settings.
     *
     * @var array
     */
    protected $aioseo_options_to_yoast_map = [];
    /**
     * The tab of the aioseo settings we're working with.
     *
     * @var string
     */
    protected $settings_tab = 'archives';
    /**
     * Builds the mapping that ties AOISEO option keys with Yoast ones and their data transformation method.
     *
     * @return void
     */
    protected function build_mapping()
    {
    }
    /**
     * Returns a setting map of the robot setting for author archives.
     *
     * @return array The setting map of the robot setting for author archives.
     */
    public function pluck_robot_setting_from_mapping()
    {
    }
  }
  /**
   * Importing action for AIOSEO general settings.
   */
  class Aioseo_General_Settings_Importing_Action extends \Yoast\WP\SEO\Actions\Importing\Aioseo\Abstract_Aioseo_Settings_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'general_settings';
    /**
     * The option_name of the AIOSEO option that contains the settings.
     */
    const SOURCE_OPTION_NAME = 'aioseo_options';
    /**
     * The map of aioseo_options to yoast settings.
     *
     * @var array
     */
    protected $aioseo_options_to_yoast_map = [];
    /**
     * The tab of the aioseo settings we're working with.
     *
     * @var string
     */
    protected $settings_tab = 'global';
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    protected $image;
    /**
     * Aioseo_General_Settings_Importing_Action constructor.
     *
     * @param Import_Cursor_Helper              $import_cursor      The import cursor helper.
     * @param Options_Helper                    $options            The options helper.
     * @param Sanitization_Helper               $sanitization       The sanitization helper.
     * @param Image_Helper                      $image              The image helper.
     * @param Aioseo_Replacevar_Service         $replacevar_handler The replacevar handler.
     * @param Aioseo_Robots_Provider_Service    $robots_provider    The robots provider service.
     * @param Aioseo_Robots_Transformer_Service $robots_transformer The robots transfomer service.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Import_Cursor_Helper $import_cursor, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Sanitization_Helper $sanitization, \Yoast\WP\SEO\Helpers\Image_Helper $image, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Replacevar_Service $replacevar_handler, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service $robots_provider, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Transformer_Service $robots_transformer)
    {
    }
    /**
     * Builds the mapping that ties AOISEO option keys with Yoast ones and their data transformation method.
     *
     * @return void
     */
    protected function build_mapping()
    {
    }
    /**
     * Imports the organization logo while also accounting for the id of the log to be saved in the separate Yoast option.
     *
     * @param string $logo_url The company logo url coming from AIOSEO settings.
     *
     * @return string The transformed company logo url.
     */
    public function import_company_logo($logo_url)
    {
    }
    /**
     * Imports the person logo while also accounting for the id of the log to be saved in the separate Yoast option.
     *
     * @param string $logo_url The person logo url coming from AIOSEO settings.
     *
     * @return string The transformed person logo url.
     */
    public function import_person_logo($logo_url)
    {
    }
    /**
     * Transforms the site represents setting.
     *
     * @param string $site_represents The site represents setting.
     *
     * @return string The transformed site represents setting.
     */
    public function transform_site_represents($site_represents)
    {
    }
    /**
     * Transforms the separator setting.
     *
     * @param string $separator The separator setting.
     *
     * @return string The transformed separator.
     */
    public function transform_separator($separator)
    {
    }
  }
  /**
   * Importing action for AIOSEO post data.
   */
  class Aioseo_Posts_Importing_Action extends \Yoast\WP\SEO\Actions\Importing\Abstract_Aioseo_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'posts';
    /**
     * The map of aioseo to yoast meta.
     *
     * @var array
     */
    protected $aioseo_to_yoast_map = ['title' => ['yoast_name' => 'title', 'transform_method' => 'simple_import_post'], 'description' => ['yoast_name' => 'description', 'transform_method' => 'simple_import_post'], 'og_title' => ['yoast_name' => 'open_graph_title', 'transform_method' => 'simple_import_post'], 'og_description' => ['yoast_name' => 'open_graph_description', 'transform_method' => 'simple_import_post'], 'twitter_title' => ['yoast_name' => 'twitter_title', 'transform_method' => 'simple_import_post', 'twitter_import' => true], 'twitter_description' => ['yoast_name' => 'twitter_description', 'transform_method' => 'simple_import_post', 'twitter_import' => true], 'canonical_url' => ['yoast_name' => 'canonical', 'transform_method' => 'url_import_post'], 'keyphrases' => ['yoast_name' => 'primary_focus_keyword', 'transform_method' => 'keyphrase_import'], 'og_image_url' => ['yoast_name' => 'open_graph_image', 'social_image_import' => true, 'social_setting_prefix_aioseo' => 'og_', 'social_setting_prefix_yoast' => 'open_graph_', 'transform_method' => 'social_image_url_import'], 'twitter_image_url' => ['yoast_name' => 'twitter_image', 'social_image_import' => true, 'social_setting_prefix_aioseo' => 'twitter_', 'social_setting_prefix_yoast' => 'twitter_', 'transform_method' => 'social_image_url_import'], 'robots_noindex' => ['yoast_name' => 'is_robots_noindex', 'transform_method' => 'post_robots_noindex_import', 'robots_import' => true], 'robots_nofollow' => ['yoast_name' => 'is_robots_nofollow', 'transform_method' => 'post_general_robots_import', 'robots_import' => true, 'robot_type' => 'nofollow'], 'robots_noarchive' => ['yoast_name' => 'is_robots_noarchive', 'transform_method' => 'post_general_robots_import', 'robots_import' => true, 'robot_type' => 'noarchive'], 'robots_nosnippet' => ['yoast_name' => 'is_robots_nosnippet', 'transform_method' => 'post_general_robots_import', 'robots_import' => true, 'robot_type' => 'nosnippet'], 'robots_noimageindex' => ['yoast_name' => 'is_robots_noimageindex', 'transform_method' => 'post_general_robots_import', 'robots_import' => true, 'robot_type' => 'noimageindex']];
    /**
     * Represents the indexables repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    protected $image;
    /**
     * The indexable_to_postmeta helper.
     *
     * @var Indexable_To_Postmeta_Helper
     */
    protected $indexable_to_postmeta;
    /**
     * The indexable helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * The social images provider service.
     *
     * @var Aioseo_Social_Images_Provider_Service
     */
    protected $social_images_provider;
    /**
     * Class constructor.
     *
     * @param Indexable_Repository                  $indexable_repository   The indexables repository.
     * @param wpdb                                  $wpdb                   The WordPress database instance.
     * @param Import_Cursor_Helper                  $import_cursor          The import cursor helper.
     * @param Indexable_Helper                      $indexable_helper       The indexable helper.
     * @param Indexable_To_Postmeta_Helper          $indexable_to_postmeta  The indexable_to_postmeta helper.
     * @param Options_Helper                        $options                The options helper.
     * @param Image_Helper                          $image                  The image helper.
     * @param Sanitization_Helper                   $sanitization           The sanitization helper.
     * @param Aioseo_Replacevar_Service             $replacevar_handler     The replacevar handler.
     * @param Aioseo_Robots_Provider_Service        $robots_provider        The robots provider service.
     * @param Aioseo_Robots_Transformer_Service     $robots_transformer     The robots transfomer service.
     * @param Aioseo_Social_Images_Provider_Service $social_images_provider The social images provider service.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository, \wpdb $wpdb, \Yoast\WP\SEO\Helpers\Import_Cursor_Helper $import_cursor, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable_helper, \Yoast\WP\SEO\Helpers\Indexable_To_Postmeta_Helper $indexable_to_postmeta, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Image_Helper $image, \Yoast\WP\SEO\Helpers\Sanitization_Helper $sanitization, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Replacevar_Service $replacevar_handler, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service $robots_provider, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Transformer_Service $robots_transformer, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Social_Images_Provider_Service $social_images_provider)
    {
    }
    // phpcs:disable WordPress.DB.PreparedSQL.NotPrepared -- Reason: They are already prepared.
    /**
     * Returns the total number of unimported objects.
     *
     * @return int The total number of unimported objects.
     */
    public function get_total_unindexed()
    {
    }
    /**
     * Returns the limited number of unimported objects.
     *
     * @param int $limit The maximum number of unimported objects to be returned.
     *
     * @return int|false The limited number of unindexed posts. False if the query fails.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Imports AIOSEO meta data and creates the respective Yoast indexables and postmeta.
     *
     * @return Indexable[]|false An array of created indexables or false if aioseo data was not found.
     */
    public function index()
    {
    }
    // phpcs:enable WordPress.DB.PreparedSQL.NotPrepared
    /**
     * Maps AIOSEO meta data to Yoast meta data.
     *
     * @param Indexable $indexable        The Yoast indexable.
     * @param array     $aioseo_indexable The AIOSEO indexable.
     *
     * @return Indexable The created indexables.
     */
    public function map($indexable, $aioseo_indexable)
    {
    }
    /**
     * Transforms the data to be imported.
     *
     * @param string    $transform_method The method that is going to be used for transforming the data.
     * @param array     $aioseo_indexable The data of the AIOSEO indexable data that is being imported.
     * @param string    $aioseo_key       The name of the specific set of data that is going to be transformed.
     * @param array     $yoast_mapping    Extra details for the import of the specific data that is going to be transformed.
     * @param Indexable $indexable        The Yoast indexable that we are going to import the transformed data into.
     *
     * @return string|bool|null The transformed data to be imported.
     */
    protected function transform_import_data($transform_method, $aioseo_indexable, $aioseo_key, $yoast_mapping, $indexable)
    {
    }
    /**
     * Returns the number of objects that will be imported in a single importing pass.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
    /**
     * Populates the needed data array based on which columns we use from the AIOSEO indexable table.
     *
     * @return array The needed data array that contains all the needed columns.
     */
    public function get_needed_data()
    {
    }
    /**
     * Populates the needed robot data array to be used in validating against its structure.
     *
     * @return array The needed data array that contains all the needed columns.
     */
    public function get_needed_robot_data()
    {
    }
    /**
     * Creates a query for gathering AiOSEO data from the database.
     *
     * @param int  $limit       The maximum number of unimported objects to be returned.
     * @param bool $just_detect Whether we want to just detect if there are unimported objects. If false, we want to actually import them too.
     *
     * @return string The query to use for importing or counting the number of items to import.
     */
    public function query($limit = false, $just_detect = false)
    {
    }
    /**
     * Minimally transforms data to be imported.
     *
     * @param array  $aioseo_data All of the AIOSEO data to be imported.
     * @param string $aioseo_key  The AIOSEO key that contains the setting we're working with.
     *
     * @return string The transformed meta data.
     */
    public function simple_import_post($aioseo_data, $aioseo_key)
    {
    }
    /**
     * Transforms URL to be imported.
     *
     * @param array  $aioseo_data All of the AIOSEO data to be imported.
     * @param string $aioseo_key  The AIOSEO key that contains the setting we're working with.
     *
     * @return string The transformed URL.
     */
    public function url_import_post($aioseo_data, $aioseo_key)
    {
    }
    /**
     * Plucks the keyphrase to be imported from the AIOSEO array of keyphrase meta data.
     *
     * @param array  $aioseo_data All of the AIOSEO data to be imported.
     * @param string $aioseo_key  The AIOSEO key that contains the setting we're working with, aka keyphrases.
     *
     * @return string|null The plucked keyphrase.
     */
    public function keyphrase_import($aioseo_data, $aioseo_key)
    {
    }
    /**
     * Imports the post's noindex setting.
     *
     * @param bool $aioseo_robots_settings AIOSEO's set of robot settings for the post.
     *
     * @return bool|null The value of Yoast's noindex setting for the post.
     */
    public function post_robots_noindex_import($aioseo_robots_settings)
    {
    }
    /**
     * Imports the post's robots setting.
     *
     * @param bool   $aioseo_robots_settings AIOSEO's set of robot settings for the post.
     * @param string $aioseo_key             The AIOSEO key that contains the robot setting we're working with.
     * @param array  $mapping                The mapping of the setting we're working with.
     *
     * @return bool|null The value of Yoast's noindex setting for the post.
     */
    public function post_general_robots_import($aioseo_robots_settings, $aioseo_key, $mapping)
    {
    }
    /**
     * Enhances the mapping of the setting we're working with, with type and the option name, so that we can retrieve the settings for the object we're working with.
     *
     * @param array $mapping The mapping of the setting we're working with.
     *
     * @return array The enhanced mapping.
     */
    public function enhance_mapping($mapping = [])
    {
    }
    /**
     * Imports the og and twitter image url.
     *
     * @param bool      $aioseo_social_image_settings AIOSEO's set of social image settings for the post.
     * @param string    $aioseo_key                   The AIOSEO key that contains the robot setting we're working with.
     * @param array     $mapping                      The mapping of the setting we're working with.
     * @param Indexable $indexable                    The Yoast indexable we're importing into.
     *
     * @return bool|null The url of the social image we're importing, null if there's none.
     */
    public function social_image_url_import($aioseo_social_image_settings, $aioseo_key, $mapping, $indexable)
    {
    }
  }
  /**
   * Importing action for AIOSEO posttype defaults settings data.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded
   */
  class Aioseo_Posttype_Defaults_Settings_Importing_Action extends \Yoast\WP\SEO\Actions\Importing\Aioseo\Abstract_Aioseo_Settings_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'posttype_default_settings';
    /**
     * The option_name of the AIOSEO option that contains the settings.
     */
    const SOURCE_OPTION_NAME = 'aioseo_options_dynamic';
    /**
     * The map of aioseo_options to yoast settings.
     *
     * @var array
     */
    protected $aioseo_options_to_yoast_map = [];
    /**
     * The tab of the aioseo settings we're working with.
     *
     * @var string
     */
    protected $settings_tab = 'postTypes';
    /**
     * Builds the mapping that ties AOISEO option keys with Yoast ones and their data transformation method.
     *
     * @return void
     */
    protected function build_mapping()
    {
    }
    /**
     * Transforms the redirect_attachment setting.
     *
     * @param string $redirect_attachment The redirect_attachment setting.
     *
     * @return bool The transformed redirect_attachment setting.
     */
    public function import_redirect_attachment($redirect_attachment)
    {
    }
  }
  /**
   * Importing action for AIOSEO taxonomies settings data.
   */
  class Aioseo_Taxonomy_Settings_Importing_Action extends \Yoast\WP\SEO\Actions\Importing\Aioseo\Abstract_Aioseo_Settings_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'taxonomy_settings';
    /**
     * The option_name of the AIOSEO option that contains the settings.
     */
    const SOURCE_OPTION_NAME = 'aioseo_options_dynamic';
    /**
     * The map of aioseo_options to yoast settings.
     *
     * @var array
     */
    protected $aioseo_options_to_yoast_map = [];
    /**
     * The tab of the aioseo settings we're working with.
     *
     * @var string
     */
    protected $settings_tab = 'taxonomies';
    /**
     * Additional mapping between AiOSEO replace vars and Yoast replace vars.
     *
     * @var array
     *
     * @see https://yoast.com/help/list-available-snippet-variables-yoast-seo/
     */
    protected $replace_vars_edited_map = [
      '#breadcrumb_404_error_format' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_archive_post_type_format' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_archive_post_type_name' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_author_display_name' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_author_first_name' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_blog_page_title' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_label' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_link' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_search_result_format' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_search_string' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_separator' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#breadcrumb_taxonomy_title' => '',
      // Empty string, as AIOSEO shows nothing for that tag.
      '#taxonomy_title' => '%%term_title%%',
    ];
    /**
     * Builds the mapping that ties AOISEO option keys with Yoast ones and their data transformation method.
     *
     * @return void
     */
    protected function build_mapping()
    {
    }
    /**
     * Returns a setting map of the robot setting for post category taxonomies.
     *
     * @return array The setting map of the robot setting for post category taxonomies.
     */
    public function pluck_robot_setting_from_mapping()
    {
    }
  }
  /**
   * Importing action for validating AIOSEO data before the import occurs.
   */
  class Aioseo_Validate_Data_Action extends \Yoast\WP\SEO\Actions\Importing\Abstract_Aioseo_Importing_Action
  {
    /**
     * The plugin of the action.
     */
    const PLUGIN = 'aioseo';
    /**
     * The type of the action.
     */
    const TYPE = 'validate_data';
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * The Post Importing action.
     *
     * @var Aioseo_Posts_Importing_Action
     */
    protected $post_importing_action;
    /**
     * The settings importing actions.
     *
     * @var array
     */
    protected $settings_importing_actions;
    /**
     * Class constructor.
     *
     * @param wpdb                                               $wpdb                              The WordPress database instance.
     * @param Options_Helper                                     $options                           The options helper.
     * @param Aioseo_Custom_Archive_Settings_Importing_Action    $custom_archive_action             The Custom Archive Settings importing action.
     * @param Aioseo_Default_Archive_Settings_Importing_Action   $default_archive_action            The Default Archive Settings importing action.
     * @param Aioseo_General_Settings_Importing_Action           $general_settings_action           The General Settings importing action.
     * @param Aioseo_Posttype_Defaults_Settings_Importing_Action $posttype_defaults_settings_action The Posttype Defaults Settings importing action.
     * @param Aioseo_Taxonomy_Settings_Importing_Action          $taxonomy_settings_action          The Taxonomy Settings importing action.
     * @param Aioseo_Posts_Importing_Action                      $post_importing_action             The Post importing action.
     */
    public function __construct(\wpdb $wpdb, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Custom_Archive_Settings_Importing_Action $custom_archive_action, \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Default_Archive_Settings_Importing_Action $default_archive_action, \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_General_Settings_Importing_Action $general_settings_action, \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Posttype_Defaults_Settings_Importing_Action $posttype_defaults_settings_action, \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Taxonomy_Settings_Importing_Action $taxonomy_settings_action, \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Posts_Importing_Action $post_importing_action)
    {
    }
    /**
     * Just checks if the action has been completed in the past.
     *
     * @return int 1 if it hasn't been completed in the past, 0 if it has.
     */
    public function get_total_unindexed()
    {
    }
    /**
     * Just checks if the action has been completed in the past.
     *
     * @param int $limit The maximum number of unimported objects to be returned. Not used, exists to comply with the interface.
     *
     * @return int 1 if it hasn't been completed in the past, 0 if it has.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Validates AIOSEO data.
     *
     * @return array An array of validated data or false if aioseo data did not pass validation.
     *
     * @throws Aioseo_Validation_Exception If the validation fails.
     */
    public function index()
    {
    }
    /**
     * Validates the AIOSEO indexable table.
     *
     * @return bool Whether the AIOSEO table exists and has the structure we expect.
     */
    public function validate_aioseo_table()
    {
    }
    /**
     * Validates the AIOSEO settings from the options table.
     *
     * @return bool Whether the AIOSEO settings from the options table exist and have the structure we expect.
     */
    public function validate_aioseo_settings()
    {
    }
    /**
     * Validates the AIOSEO robots settings from the options table.
     *
     * @return bool Whether the AIOSEO robots settings from the options table exist and have the structure we expect.
     */
    public function validate_robot_settings()
    {
    }
    /**
     * Validates the post AIOSEO robots settings from the options table.
     *
     * @return bool Whether the post AIOSEO robots settings from the options table exist and have the structure we expect.
     */
    public function validate_post_robot_settings()
    {
    }
    /**
     * Validates the default AIOSEO robots settings for search appearance settings from the options table.
     *
     * @return bool Whether the AIOSEO robots settings for search appearance settings from the options table exist and have the structure we expect.
     */
    public function validate_default_robot_settings()
    {
    }
    /**
     * Used nowhere. Exists to comply with the interface.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Importing {
  /**
   * Deactivates plug-ins that cause conflicts with Yoast SEO.
   */
  class Deactivate_Conflicting_Plugins_Action extends \Yoast\WP\SEO\Actions\Importing\Abstract_Aioseo_Importing_Action
  {
    /**
     * The plugin the class deals with.
     *
     * @var string
     */
    const PLUGIN = 'conflicting-plugins';
    /**
     * The type the class deals with.
     *
     * @var string
     */
    const TYPE = 'deactivation';
    /**
     * The replacevar handler.
     *
     * @var Aioseo_Replacevar_Service
     */
    protected $replacevar_handler;
    /**
     * Knows all plugins that might possibly conflict.
     *
     * @var Conflicting_Plugins_Service
     */
    protected $conflicting_plugins;
    /**
     * The list of conflicting plugins
     *
     * @var array
     */
    protected $detected_plugins;
    /**
     * Class constructor.
     *
     * @param Import_Cursor_Helper              $import_cursor               The import cursor helper.
     * @param Options_Helper                    $options                     The options helper.
     * @param Sanitization_Helper               $sanitization                The sanitization helper.
     * @param Aioseo_Replacevar_Service         $replacevar_handler          The replacevar handler.
     * @param Aioseo_Robots_Provider_Service    $robots_provider             The robots provider service.
     * @param Aioseo_Robots_Transformer_Service $robots_transformer          The robots transfomer service.
     * @param Conflicting_Plugins_Service       $conflicting_plugins_service The Conflicting plugins Service.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Import_Cursor_Helper $import_cursor, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Sanitization_Helper $sanitization, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Replacevar_Service $replacevar_handler, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service $robots_provider, \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Transformer_Service $robots_transformer, \Yoast\WP\SEO\Services\Importing\Conflicting_Plugins_Service $conflicting_plugins_service)
    {
    }
    /**
     * Get the total number of conflicting plugins.
     */
    public function get_total_unindexed()
    {
    }
    /**
     * Returns whether the updated importer framework is enabled.
     *
     * @return bool True if the updated importer framework is enabled.
     */
    public function is_enabled()
    {
    }
    /**
     * Deactivate conflicting plugins.
     */
    public function index()
    {
    }
    /**
     * {@inheritDoc}
     */
    public function get_limit()
    {
    }
    /**
     * Returns the total number of unindexed objects up to a limit.
     *
     * @param int $limit The maximum.
     *
     * @return int The total number of unindexed objects.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Returns all detected plugins.
     *
     * @return array The detected plugins.
     */
    protected function get_detected_plugins()
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Indexables {
  /**
   * Get head action for indexables.
   */
  class Indexable_Head_Action
  {
    /**
     * Caches the output.
     *
     * @var mixed
     */
    protected $cache;
    /**
     * The meta surface.
     *
     * @var Meta_Surface
     */
    private $meta_surface;
    /**
     * Indexable_Head_Action constructor.
     *
     * @param Meta_Surface $meta_surface The meta surface.
     */
    public function __construct(\Yoast\WP\SEO\Surfaces\Meta_Surface $meta_surface)
    {
    }
    /**
     * Retrieves the head for a url.
     *
     * @param string $url The url to get the head for.
     *
     * @return object Object with head and status properties.
     */
    public function for_url($url)
    {
    }
    /**
     * Retrieves the head for a post.
     *
     * @param int $id The id.
     *
     * @return object Object with head and status properties.
     */
    public function for_post($id)
    {
    }
    /**
     * Retrieves the head for a term.
     *
     * @param int $id The id.
     *
     * @return object Object with head and status properties.
     */
    public function for_term($id)
    {
    }
    /**
     * Retrieves the head for an author.
     *
     * @param int $id The id.
     *
     * @return object Object with head and status properties.
     */
    public function for_author($id)
    {
    }
    /**
     * Retrieves the head for a post type archive.
     *
     * @param int $type The id.
     *
     * @return object Object with head and status properties.
     */
    public function for_post_type_archive($type)
    {
    }
    /**
     * Retrieves the head for the posts page.
     *
     * @return object Object with head and status properties.
     */
    public function for_posts_page()
    {
    }
    /**
     * Retrieves the head for the 404 page. Always sets the status to 404.
     *
     * @return object Object with head and status properties.
     */
    public function for_404()
    {
    }
    /**
     * Retrieves the head for a successful page load.
     *
     * @param object $head The calculated Yoast head.
     *
     * @return object The presentations and status code 200.
     */
    protected function for_200($head)
    {
    }
    /**
     * Returns the head with 404 fallback
     *
     * @param Meta|false $meta The meta object.
     *
     * @return object The head response.
     */
    protected function with_404_fallback($meta)
    {
    }
    /**
     * Retrieves a value from the meta surface cached.
     *
     * @param string $type     The type of value to retrieve.
     * @param string $argument Optional. The argument for the value.
     *
     * @return Meta The meta object.
     */
    protected function with_cache($type, $argument = '')
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Indexing {
  /**
   * Base class of indexing actions.
   */
  abstract class Abstract_Indexing_Action implements \Yoast\WP\SEO\Actions\Indexing\Indexation_Action_Interface, \Yoast\WP\SEO\Actions\Indexing\Limited_Indexing_Action_Interface
  {
    /**
     * The transient name.
     *
     * This is a trick to force derived classes to define a transient themselves.
     *
     * @var string
     */
    const UNINDEXED_COUNT_TRANSIENT = null;
    /**
     * The transient cache key for limited counts.
     *
     * @var string
     */
    const UNINDEXED_LIMITED_COUNT_TRANSIENT = self::UNINDEXED_COUNT_TRANSIENT . '_limited';
    /**
     * Builds a query for selecting the ID's of unindexed posts.
     *
     * @param bool $limit The maximum number of post IDs to return.
     *
     * @return string The prepared query string.
     */
    protected abstract function get_select_query($limit);
    /**
     * Builds a query for counting the number of unindexed posts.
     *
     * @return string The prepared query string.
     */
    protected abstract function get_count_query();
    /**
     * Returns a limited number of unindexed posts.
     *
     * @param int $limit Limit the maximum number of unindexed posts that are counted.
     *
     * @return int The limited number of unindexed posts. 0 if the query fails.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Returns the total number of unindexed posts.
     *
     * @return int|false The total number of unindexed posts. False if the query fails.
     */
    public function get_total_unindexed()
    {
    }
  }
  /**
   * Reindexing action for link indexables.
   */
  abstract class Abstract_Link_Indexing_Action extends \Yoast\WP\SEO\Actions\Indexing\Abstract_Indexing_Action
  {
    /**
     * The link builder.
     *
     * @var Indexable_Link_Builder
     */
    protected $link_builder;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Indexable_Post_Indexing_Action constructor
     *
     * @param Indexable_Link_Builder $link_builder The indexable link builder.
     * @param Indexable_Repository   $repository   The indexable repository.
     * @param wpdb                   $wpdb         The WordPress database instance.
     */
    public function __construct(\Yoast\WP\SEO\Builders\Indexable_Link_Builder $link_builder, \Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \wpdb $wpdb)
    {
    }
    /**
     * Builds links for indexables which haven't had their links indexed yet.
     *
     * @return SEO_Links[] The created SEO links.
     */
    public function index()
    {
    }
    /**
     * In the case of term-links and post-links we want to use the total unindexed count, because using
     * the limited unindexed count actually leads to worse performance.
     *
     * @param int|bool $limit Unused.
     *
     * @return int The total number of unindexed links.
     */
    public function get_limited_unindexed_count($limit = false)
    {
    }
    /**
     * Returns the number of texts that will be indexed in a single link indexing pass.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
    /**
     * Returns objects to be indexed.
     *
     * @return array Objects to be indexed, should be an array of objects with object_id, object_type and content.
     */
    protected abstract function get_objects();
  }
  /**
   * General reindexing action for indexables.
   */
  class Indexable_General_Indexation_Action implements \Yoast\WP\SEO\Actions\Indexing\Indexation_Action_Interface, \Yoast\WP\SEO\Actions\Indexing\Limited_Indexing_Action_Interface
  {
    /**
     * The transient cache key.
     */
    const UNINDEXED_COUNT_TRANSIENT = 'wpseo_total_unindexed_general_items';
    /**
     * Represents the indexables repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Indexable_General_Indexation_Action constructor.
     *
     * @param Indexable_Repository $indexable_repository The indexables repository.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Returns the total number of unindexed objects.
     *
     * @return int The total number of unindexed objects.
     */
    public function get_total_unindexed()
    {
    }
    /**
     * Returns a limited number of unindexed posts.
     *
     * @param int $limit Limit the maximum number of unindexed posts that are counted.
     *
     * @return int|false The limited number of unindexed posts. False if the query fails.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Creates indexables for unindexed system pages, the date archive, and the homepage.
     *
     * @return Indexable[] The created indexables.
     */
    public function index()
    {
    }
    /**
     * Returns the number of objects that will be indexed in a single indexing pass.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
    /**
     * Check which indexables already exist and return the values of the ones to create.
     *
     * @return array The indexable types to create.
     */
    private function query()
    {
    }
  }
  /**
   * Indexing action to call when the indexable indexing process is completed.
   */
  class Indexable_Indexing_Complete_Action
  {
    /**
     * The options helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * Indexable_Indexing_Complete_Action constructor.
     *
     * @param Indexable_Helper $indexable_helper The indexable helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Indexable_Helper $indexable_helper)
    {
    }
    /**
     * Wraps up the indexing process.
     *
     * @return void
     */
    public function complete()
    {
    }
  }
  /**
   * Reindexing action for post indexables.
   */
  class Indexable_Post_Indexation_Action extends \Yoast\WP\SEO\Actions\Indexing\Abstract_Indexing_Action
  {
    /**
     * The transient cache key.
     *
     * @var string
     */
    const UNINDEXED_COUNT_TRANSIENT = 'wpseo_total_unindexed_posts';
    /**
     * The transient cache key for limited counts.
     *
     * @var string
     */
    const UNINDEXED_LIMITED_COUNT_TRANSIENT = self::UNINDEXED_COUNT_TRANSIENT . '_limited';
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * The post helper.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * The latest version of Post Indexables.
     *
     * @var int
     */
    protected $version;
    /**
     * Indexable_Post_Indexing_Action constructor
     *
     * @param Post_Type_Helper           $post_type_helper The post type helper.
     * @param Indexable_Repository       $repository       The indexable repository.
     * @param wpdb                       $wpdb             The WordPress database instance.
     * @param Indexable_Builder_Versions $builder_versions The latest versions for each Indexable type.
     * @param Post_Helper                $post_helper      The post helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \wpdb $wpdb, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $builder_versions, \Yoast\WP\SEO\Helpers\Post_Helper $post_helper)
    {
    }
    /**
     * Creates indexables for unindexed posts.
     *
     * @return Indexable[] The created indexables.
     */
    public function index()
    {
    }
    /**
     * Returns the number of posts that will be indexed in a single indexing pass.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
    /**
     * Builds a query for counting the number of unindexed posts.
     *
     * @return string The prepared query string.
     */
    protected function get_count_query()
    {
    }
    /**
     * Builds a query for selecting the ID's of unindexed posts.
     *
     * @param bool $limit The maximum number of post IDs to return.
     *
     * @return string The prepared query string.
     */
    protected function get_select_query($limit = false)
    {
    }
  }
  /**
   * Reindexing action for post type archive indexables.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded
   */
  class Indexable_Post_Type_Archive_Indexation_Action implements \Yoast\WP\SEO\Actions\Indexing\Indexation_Action_Interface, \Yoast\WP\SEO\Actions\Indexing\Limited_Indexing_Action_Interface
  {
    /**
     * The transient cache key.
     */
    const UNINDEXED_COUNT_TRANSIENT = 'wpseo_total_unindexed_post_type_archives';
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * The current version of the post type archive indexable builder.
     *
     * @var int
     */
    protected $version;
    /**
     * Indexation_Post_Type_Archive_Action constructor.
     *
     * @param Indexable_Repository       $repository The indexable repository.
     * @param Indexable_Builder          $builder    The indexable builder.
     * @param Post_Type_Helper           $post_type  The post type helper.
     * @param Indexable_Builder_Versions $versions   The current versions of all indexable builders.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions)
    {
    }
    /**
     * Returns the total number of unindexed post type archives.
     *
     * @param int $limit Limit the number of counted objects.
     *
     * @return int The total number of unindexed post type archives.
     */
    public function get_total_unindexed($limit = false)
    {
    }
    /**
     * Creates indexables for post type archives.
     *
     * @return Indexable[] The created indexables.
     */
    public function index()
    {
    }
    /**
     * Returns the number of post type archives that will be indexed in a single indexing pass.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
    /**
     * Retrieves the list of post types for which no indexable for its archive page has been made yet.
     *
     * @param int|false $limit Limit the number of retrieved indexables to this number.
     *
     * @return array The list of post types for which no indexable for its archive page has been made yet.
     */
    protected function get_unindexed_post_type_archives($limit = false)
    {
    }
    /**
     * Returns the names of all the post types that have archive pages.
     *
     * @return array The list of names of all post types that have archive pages.
     */
    protected function get_post_types_with_archive_pages()
    {
    }
    /**
     * Retrieves the list of post type names for which an archive indexable exists.
     *
     * @return array The list of names of post types with unindexed archive pages.
     */
    protected function get_indexed_post_type_archives()
    {
    }
    /**
     * Returns a limited number of unindexed posts.
     *
     * @param int $limit Limit the maximum number of unindexed posts that are counted.
     *
     * @return int|false The limited number of unindexed posts. False if the query fails.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
  }
  /**
   * Reindexing action for term indexables.
   */
  class Indexable_Term_Indexation_Action extends \Yoast\WP\SEO\Actions\Indexing\Abstract_Indexing_Action
  {
    /**
     * The transient cache key.
     */
    const UNINDEXED_COUNT_TRANSIENT = 'wpseo_total_unindexed_terms';
    /**
     * The transient cache key for limited counts.
     *
     * @var string
     */
    const UNINDEXED_LIMITED_COUNT_TRANSIENT = self::UNINDEXED_COUNT_TRANSIENT . '_limited';
    /**
     * The post type helper.
     *
     * @var Taxonomy_Helper
     */
    protected $taxonomy;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * The latest version of the Indexable term builder
     *
     * @var int
     */
    protected $version;
    /**
     * Indexable_Term_Indexation_Action constructor
     *
     * @param Taxonomy_Helper            $taxonomy         The taxonomy helper.
     * @param Indexable_Repository       $repository       The indexable repository.
     * @param wpdb                       $wpdb             The WordPress database instance.
     * @param Indexable_Builder_Versions $builder_versions The latest versions of all indexable builders.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy, \Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \wpdb $wpdb, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $builder_versions)
    {
    }
    /**
     * Creates indexables for unindexed terms.
     *
     * @return Indexable[] The created indexables.
     */
    public function index()
    {
    }
    /**
     * Returns the number of terms that will be indexed in a single indexing pass.
     *
     * @return int The limit.
     */
    public function get_limit()
    {
    }
    /**
     * Builds a query for counting the number of unindexed terms.
     *
     * @return string The prepared query string.
     */
    protected function get_count_query()
    {
    }
    /**
     * Builds a query for selecting the ID's of unindexed terms.
     *
     * @param bool $limit The maximum number of term IDs to return.
     *
     * @return string The prepared query string.
     */
    protected function get_select_query($limit = false)
    {
    }
  }
  /**
   * Indexing action to call when the indexing is completed.
   */
  class Indexing_Complete_Action
  {
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * Indexing_Complete_Action constructor.
     *
     * @param Indexing_Helper $indexing_helper The indexing helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper)
    {
    }
    /**
     * Wraps up the indexing process.
     *
     * @return void
     */
    public function complete()
    {
    }
  }
  /**
   * Class Indexing_Prepare_Action.
   *
   * Action for preparing the indexing routine.
   */
  class Indexing_Prepare_Action
  {
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * Action for preparing the indexing routine.
     *
     * @param Indexing_Helper $indexing_helper The indexing helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper)
    {
    }
    /**
     * Prepares the indexing routine.
     *
     * @return void
     */
    public function prepare()
    {
    }
  }
  /**
   * Reindexing action for post link indexables.
   */
  class Post_Link_Indexing_Action extends \Yoast\WP\SEO\Actions\Indexing\Abstract_Link_Indexing_Action
  {
    /**
     * The transient name.
     *
     * @var string
     */
    const UNINDEXED_COUNT_TRANSIENT = 'wpseo_unindexed_post_link_count';
    /**
     * The transient cache key for limited counts.
     *
     * @var string
     */
    const UNINDEXED_LIMITED_COUNT_TRANSIENT = self::UNINDEXED_COUNT_TRANSIENT . '_limited';
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * Sets the required helper.
     *
     * @required
     *
     * @param Post_Type_Helper $post_type_helper The post type helper.
     *
     * @return void
     */
    public function set_helper(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper)
    {
    }
    /**
     * Returns objects to be indexed.
     *
     * @return array Objects to be indexed.
     */
    protected function get_objects()
    {
    }
    /**
     * Builds a query for counting the number of unindexed post links.
     *
     * @return string The prepared query string.
     */
    protected function get_count_query()
    {
    }
    /**
     * Builds a query for selecting the ID's of unindexed post links.
     *
     * @param int|false $limit The maximum number of post link IDs to return.
     *
     * @return string The prepared query string.
     */
    protected function get_select_query($limit = false)
    {
    }
  }
  /**
   * Reindexing action for term link indexables.
   */
  class Term_Link_Indexing_Action extends \Yoast\WP\SEO\Actions\Indexing\Abstract_Link_Indexing_Action
  {
    /**
     * The transient name.
     *
     * @var string
     */
    const UNINDEXED_COUNT_TRANSIENT = 'wpseo_unindexed_term_link_count';
    /**
     * The transient cache key for limited counts.
     *
     * @var string
     */
    const UNINDEXED_LIMITED_COUNT_TRANSIENT = self::UNINDEXED_COUNT_TRANSIENT . '_limited';
    /**
     * The post type helper.
     *
     * @var Taxonomy_Helper
     */
    protected $taxonomy_helper;
    /**
     * Sets the required helper.
     *
     * @required
     *
     * @param Taxonomy_Helper $taxonomy_helper The taxonomy helper.
     *
     * @return void
     */
    public function set_helper(\Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy_helper)
    {
    }
    /**
     * Returns objects to be indexed.
     *
     * @return array Objects to be indexed.
     */
    protected function get_objects()
    {
    }
    /**
     * Builds a query for counting the number of unindexed term links.
     *
     * @return string The prepared query string.
     */
    protected function get_count_query()
    {
    }
    /**
     * Builds a query for selecting the ID's of unindexed term links.
     *
     * @param int|false $limit The maximum number of term link IDs to return.
     *
     * @return string The prepared query string.
     */
    protected function get_select_query($limit = false)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions {
  /**
   * Class Integrations_Action.
   */
  class Integrations_Action
  {
    /**
     * The Options_Helper instance.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Integrations_Action constructor.
     *
     * @param Options_Helper $options_helper The WPSEO options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Sets an integration state.
     *
     * @param string  $integration_name The name of the integration to activate/deactivate.
     * @param boolean $value            The value to store.
     *
     * @return object The response object.
     */
    public function set_integration_active($integration_name, $value)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\SEMrush {
  /**
   * Class SEMrush_Login_Action
   */
  class SEMrush_Login_Action
  {
    /**
     * The SEMrush_Client instance.
     *
     * @var SEMrush_Client
     */
    protected $client;
    /**
     * SEMrush_Login_Action constructor.
     *
     * @param SEMrush_Client $client The API client.
     */
    public function __construct(\Yoast\WP\SEO\Config\SEMrush_Client $client)
    {
    }
    /**
     * Authenticates with SEMrush to request the necessary tokens.
     *
     * @param string $code The authentication code to use to request a token with.
     *
     * @return object The response object.
     */
    public function authenticate($code)
    {
    }
    /**
     * Performs the login request, if necessary.
     */
    public function login()
    {
    }
  }
  /**
   * Class SEMrush_Options_Action
   */
  class SEMrush_Options_Action
  {
    /**
     * The Options_Helper instance.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * SEMrush_Options_Action constructor.
     *
     * @param Options_Helper $options_helper The WPSEO options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Stores SEMrush country code in the WPSEO options.
     *
     * @param string $country_code The country code to store.
     *
     * @return object The response object.
     */
    public function set_country_code($country_code)
    {
    }
  }
  /**
   * Class SEMrush_Phrases_Action
   */
  class SEMrush_Phrases_Action
  {
    /**
     * The transient cache key.
     */
    const TRANSIENT_CACHE_KEY = 'wpseo_semrush_related_keyphrases_%s_%s';
    /**
     * The SEMrush keyphrase URL.
     *
     * @var string
     */
    const KEYPHRASES_URL = 'https://oauth.semrush.com/api/v1/keywords/phrase_fullsearch';
    /**
     * The SEMrush_Client instance.
     *
     * @var SEMrush_Client
     */
    protected $client;
    /**
     * SEMrush_Phrases_Action constructor.
     *
     * @param SEMrush_Client $client The API client.
     */
    public function __construct(\Yoast\WP\SEO\Config\SEMrush_Client $client)
    {
    }
    /**
     * Gets the related keyphrases and data based on the passed keyphrase and database country code.
     *
     * @param string $keyphrase The keyphrase to search for.
     * @param string $database  The database's country code.
     *
     * @return object The response object.
     */
    public function get_related_keyphrases($keyphrase, $database)
    {
    }
    /**
     * Converts the passed dataset to an object.
     *
     * @param array $result The result dataset to convert to an object.
     *
     * @return object The result object.
     */
    protected function to_result_object($result)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions {
  /**
   * Settings_Introduction_Action class.
   */
  class Settings_Introduction_Action
  {
    const USER_META_KEY = '_yoast_settings_introduction';
    const DEFAULT_VALUES = ['wistia_embed_permission' => false, 'show' => true];
    /**
     * Holds the User_Helper instance.
     *
     * @var User_Helper
     */
    private $user_helper;
    /**
     * Constructs Settings_Introduction_Action.
     *
     * @param User_Helper $user_helper The User_Helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\User_Helper $user_helper)
    {
    }
    /**
     * Retrieves the Wistia embed permission value.
     *
     * @throws Exception If an invalid user ID is supplied.
     *
     * @return bool The value of the Wistia embed permission.
     */
    public function get_wistia_embed_permission()
    {
    }
    /**
     * Sets the Wistia embed permission value.
     *
     * @param bool $value The value.
     *
     * @throws Exception If an invalid user ID is supplied.
     *
     * @return bool Whether the update was successful.
     */
    public function set_wistia_embed_permission($value)
    {
    }
    /**
     * Retrieves the show value.
     *
     * @throws Exception If an invalid user ID is supplied.
     *
     * @return bool The value of show.
     */
    public function get_show()
    {
    }
    /**
     * Sets the show value.
     *
     * @param bool $value The value.
     *
     * @throws Exception If an invalid user ID is supplied.
     *
     * @return bool Whether the update was successful.
     */
    public function set_show($value)
    {
    }
    /**
     * Retrieves the (meta) values for a user.
     *
     * @param int $user_id User ID.
     *
     * @throws Exception If an invalid user ID is supplied.
     *
     * @return array The (meta) values.
     */
    private function get_values_for_user($user_id)
    {
    }
  }
}

namespace Yoast\WP\SEO\Actions\Wincher {
  /**
   * Class Wincher_Account_Action
   */
  class Wincher_Account_Action
  {
    const ACCOUNT_URL = 'https://api.wincher.com/beta/account';
    /**
     * The Wincher_Client instance.
     *
     * @var Wincher_Client
     */
    protected $client;
    /**
     * The Options_Helper instance.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Wincher_Account_Action constructor.
     *
     * @param Wincher_Client $client         The API client.
     * @param Options_Helper $options_helper The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Config\Wincher_Client $client, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Checks the account limit for tracking keyphrases.
     *
     * @return object The response object.
     */
    public function check_limit()
    {
    }
  }
  /**
   * Class Wincher_Keyphrases_Action
   */
  class Wincher_Keyphrases_Action
  {
    /**
     * The Wincher keyphrase URL for bulk addition.
     *
     * @var string
     */
    const KEYPHRASES_ADD_URL = 'https://api.wincher.com/beta/websites/%s/keywords/bulk';
    /**
     * The Wincher tracked keyphrase retrieval URL.
     *
     * @var string
     */
    const KEYPHRASES_URL = 'https://api.wincher.com/beta/yoast/%s';
    /**
     * The Wincher delete tracked keyphrase URL.
     *
     * @var string
     */
    const KEYPHRASE_DELETE_URL = 'https://api.wincher.com/beta/websites/%s/keywords/%s';
    /**
     * The Wincher_Client instance.
     *
     * @var Wincher_Client
     */
    protected $client;
    /**
     * The Options_Helper instance.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The Indexable_Repository instance.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Wincher_Keyphrases_Action constructor.
     *
     * @param Wincher_Client       $client               The API client.
     * @param Options_Helper       $options_helper       The options helper.
     * @param Indexable_Repository $indexable_repository The indexables repository.
     */
    public function __construct(\Yoast\WP\SEO\Config\Wincher_Client $client, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Sends the tracking API request for one or more keyphrases.
     *
     * @param string|array $keyphrases One or more keyphrases that should be tracked.
     * @param Object       $limits     The limits API call response data.
     *
     * @return Object The reponse object.
     */
    public function track_keyphrases($keyphrases, $limits)
    {
    }
    /**
     * Sends an untrack request for the passed keyword ID.
     *
     * @param int $keyphrase_id The ID of the keyphrase to untrack.
     *
     * @return object The response object.
     */
    public function untrack_keyphrase($keyphrase_id)
    {
    }
    /**
     * Gets the keyphrase data for the passed keyphrases.
     * Retrieves all available data if no keyphrases are provided.
     *
     * @param array|null  $used_keyphrases The currently used keyphrases. Optional.
     * @param string|null $permalink       The current permalink. Optional.
     *
     * @return object The keyphrase chart data.
     */
    public function get_tracked_keyphrases($used_keyphrases = null, $permalink = null)
    {
    }
    /**
     * Collects the keyphrases associated with the post.
     *
     * @param WP_Post $post The post object.
     *
     * @return array The keyphrases.
     */
    public function collect_keyphrases_from_post($post)
    {
    }
    /**
     * Collects all keyphrases known to Yoast.
     *
     * @return array
     */
    protected function collect_all_keyphrases()
    {
    }
    /**
     * Filters the results based on the passed keyphrases.
     *
     * @param array $results         The results to filter.
     * @param array $used_keyphrases The used keyphrases.
     *
     * @return array The filtered results.
     */
    protected function filter_results_by_used_keyphrases($results, $used_keyphrases)
    {
    }
    /**
     * Determines whether the amount of keyphrases would mean the user exceeds their account limits.
     *
     * @param string|array $keyphrases The keyphrases to be added.
     * @param object       $limits     The current account limits.
     *
     * @return bool Whether the limit is exceeded.
     */
    protected function would_exceed_limits($keyphrases, $limits)
    {
    }
    /**
     * Converts the passed dataset to an object.
     *
     * @param array $result The result dataset to convert to an object.
     *
     * @return object The result object.
     */
    protected function to_result_object($result)
    {
    }
  }
  /**
   * Class Wincher_Login_Action
   */
  class Wincher_Login_Action
  {
    /**
     * The Wincher_Client instance.
     *
     * @var Wincher_Client
     */
    protected $client;
    /**
     * The Options_Helper instance.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Wincher_Login_Action constructor.
     *
     * @param Wincher_Client $client         The API client.
     * @param Options_Helper $options_helper The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Config\Wincher_Client $client, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Returns the authorization URL.
     *
     * @return object The response object.
     */
    public function get_authorization_url()
    {
    }
    /**
     * Authenticates with Wincher to request the necessary tokens.
     *
     * @param string $code       The authentication code to use to request a token with.
     * @param string $website_id The website id associated with the code.
     *
     * @return object The response object.
     */
    public function authenticate($code, $website_id)
    {
    }
  }
}

namespace Yoast\WP\SEO\Builders {
  /**
   * Trait for determine the social image to use in the indexable.
   *
   * Represents the trait used in builders for handling social images.
   */
  trait Indexable_Social_Image_Trait
  {
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    protected $image;
    /**
     * The Open Graph image helper.
     *
     * @var Open_Graph_Image_Helper
     */
    protected $open_graph_image;
    /**
     * The Twitter image helper.
     *
     * @var Twitter_Image_Helper
     */
    protected $twitter_image;
    /**
     * Sets the helpers for the trait.
     *
     * @required
     *
     * @param Image_Helper            $image            The image helper.
     * @param Open_Graph_Image_Helper $open_graph_image The Open Graph image helper.
     * @param Twitter_Image_Helper    $twitter_image    The Twitter image helper.
     */
    public function set_social_image_helpers(\Yoast\WP\SEO\Helpers\Image_Helper $image, \Yoast\WP\SEO\Helpers\Open_Graph\Image_Helper $open_graph_image, \Yoast\WP\SEO\Helpers\Twitter\Image_Helper $twitter_image)
    {
    }
    /**
     * Sets the alternative on an indexable.
     *
     * @param array     $alternative_image The alternative image to set.
     * @param Indexable $indexable         The indexable to set image for.
     */
    protected function set_alternative_image(array $alternative_image, \Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Sets the Open Graph image meta data for an og image
     *
     * @param Indexable $indexable The indexable.
     */
    protected function set_open_graph_image_meta_data(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Handles the social images.
     *
     * @param Indexable $indexable The indexable to handle.
     */
    protected function handle_social_images(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Resets the social images.
     *
     * @param Indexable $indexable The indexable to set images for.
     */
    protected function reset_social_images(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
  }
  /**
   * Author Builder for the indexables.
   *
   * Formats the author meta to indexable format.
   */
  class Indexable_Author_Builder
  {
    use \Yoast\WP\SEO\Builders\Indexable_Social_Image_Trait;
    /**
     * The author archive helper.
     *
     * @var Author_Archive_Helper
     */
    private $author_archive;
    /**
     * The latest version of the Indexable_Author_Builder.
     *
     * @var int
     */
    protected $version;
    /**
     * Holds the taxonomy helper instance.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The WPDB instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Indexable_Author_Builder constructor.
     *
     * @param Author_Archive_Helper      $author_archive The author archive helper.
     * @param Indexable_Builder_Versions $versions       The Indexable version manager.
     * @param Post_Helper                $post_helper    The post helper.
     * @param wpdb                       $wpdb           The WPDB instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Author_Archive_Helper $author_archive, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions, \Yoast\WP\SEO\Helpers\Post_Helper $post_helper, \wpdb $wpdb)
    {
    }
    /**
     * Formats the data.
     *
     * @param int       $user_id   The user to retrieve the indexable for.
     * @param Indexable $indexable The indexable to format.
     *
     * @return Indexable The extended indexable.
     *
     * @throws Author_Not_Built_Exception When author is not built.
     */
    public function build($user_id, \Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Retrieves the meta data for this indexable.
     *
     * @param int $user_id The user to retrieve the meta data for.
     *
     * @return array List of meta entries.
     */
    protected function get_meta_data($user_id)
    {
    }
    /**
     * Retrieves the author meta.
     *
     * @param int    $user_id The user to retrieve the indexable for.
     * @param string $key     The meta entry to retrieve.
     *
     * @return string|null The value of the meta field.
     */
    protected function get_author_meta($user_id, $key)
    {
    }
    /**
     * Finds an alternative image for the social image.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return array|bool False when not found, array with data when found.
     */
    protected function find_alternative_image(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Returns the timestamps for a given author.
     *
     * @param int $author_id The author ID.
     *
     * @return object An object with last_modified and published_at timestamps.
     */
    protected function get_object_timestamps($author_id)
    {
    }
    /**
     * Checks if the user should be indexed.
     * Returns an exception with an appropriate message if not.
     *
     * @param string $user_id The user id.
     *
     * @return Author_Not_Built_Exception|null The exception if it should not be indexed, or `null` if it should.
     */
    protected function check_if_user_should_be_indexed($user_id)
    {
    }
  }
  /**
   * Builder for the indexables.
   *
   * Creates all the indexables.
   */
  class Indexable_Builder
  {
    /**
     * The author builder.
     *
     * @var Indexable_Author_Builder
     */
    private $author_builder;
    /**
     * The post builder.
     *
     * @var Indexable_Post_Builder
     */
    private $post_builder;
    /**
     * The term builder.
     *
     * @var Indexable_Term_Builder
     */
    private $term_builder;
    /**
     * The home page builder.
     *
     * @var Indexable_Home_Page_Builder
     */
    private $home_page_builder;
    /**
     * The post type archive builder.
     *
     * @var Indexable_Post_Type_Archive_Builder
     */
    private $post_type_archive_builder;
    /**
     * The data archive builder.
     *
     * @var Indexable_Date_Archive_Builder
     */
    private $date_archive_builder;
    /**
     * The system page builder.
     *
     * @var Indexable_System_Page_Builder
     */
    private $system_page_builder;
    /**
     * The indexable hierarchy builder.
     *
     * @var Indexable_Hierarchy_Builder
     */
    private $hierarchy_builder;
    /**
     * The primary term builder
     *
     * @var Primary_Term_Builder
     */
    private $primary_term_builder;
    /**
     * The link builder
     *
     * @var Indexable_Link_Builder
     */
    private $link_builder;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    private $indexable_repository;
    /**
     * The indexable helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * The Indexable Version Manager.
     *
     * @var Indexable_Version_Manager
     */
    protected $version_manager;
    /**
     * Returns the instance of this class constructed through the ORM Wrapper.
     *
     * @param Indexable_Author_Builder            $author_builder            The author builder for creating missing indexables.
     * @param Indexable_Post_Builder              $post_builder              The post builder for creating missing indexables.
     * @param Indexable_Term_Builder              $term_builder              The term builder for creating missing indexables.
     * @param Indexable_Home_Page_Builder         $home_page_builder         The front page builder for creating missing indexables.
     * @param Indexable_Post_Type_Archive_Builder $post_type_archive_builder The post type archive builder for creating missing indexables.
     * @param Indexable_Date_Archive_Builder      $date_archive_builder      The date archive builder for creating missing indexables.
     * @param Indexable_System_Page_Builder       $system_page_builder       The search result builder for creating missing indexables.
     * @param Indexable_Hierarchy_Builder         $hierarchy_builder         The hierarchy builder for creating the indexable hierarchy.
     * @param Primary_Term_Builder                $primary_term_builder      The primary term builder for creating primary terms for posts.
     * @param Indexable_Helper                    $indexable_helper          The indexable helper.
     * @param Indexable_Version_Manager           $version_manager           The indexable version manager.
     * @param Indexable_Link_Builder              $link_builder              The link builder for creating missing SEO links.
     */
    public function __construct(\Yoast\WP\SEO\Builders\Indexable_Author_Builder $author_builder, \Yoast\WP\SEO\Builders\Indexable_Post_Builder $post_builder, \Yoast\WP\SEO\Builders\Indexable_Term_Builder $term_builder, \Yoast\WP\SEO\Builders\Indexable_Home_Page_Builder $home_page_builder, \Yoast\WP\SEO\Builders\Indexable_Post_Type_Archive_Builder $post_type_archive_builder, \Yoast\WP\SEO\Builders\Indexable_Date_Archive_Builder $date_archive_builder, \Yoast\WP\SEO\Builders\Indexable_System_Page_Builder $system_page_builder, \Yoast\WP\SEO\Builders\Indexable_Hierarchy_Builder $hierarchy_builder, \Yoast\WP\SEO\Builders\Primary_Term_Builder $primary_term_builder, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable_helper, \Yoast\WP\SEO\Services\Indexables\Indexable_Version_Manager $version_manager, \Yoast\WP\SEO\Builders\Indexable_Link_Builder $link_builder)
    {
    }
    /**
     * Sets the indexable repository. Done to avoid circular dependencies.
     *
     * @required
     *
     * @param Indexable_Repository $indexable_repository The indexable repository.
     */
    public function set_indexable_repository(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Creates a clean copy of an Indexable to allow for later database operations.
     *
     * @param Indexable $indexable The Indexable to copy.
     *
     * @return bool|Indexable
     */
    protected function deep_copy_indexable($indexable)
    {
    }
    /**
     * Creates an indexable by its ID and type.
     *
     * @param int            $object_id   The indexable object ID.
     * @param string         $object_type The indexable object type.
     * @param Indexable|bool $indexable   Optional. An existing indexable to overwrite.
     *
     * @return bool|Indexable Instance of indexable. False when unable to build.
     */
    public function build_for_id_and_type($object_id, $object_type, $indexable = false)
    {
    }
    /**
     * Creates an indexable for the homepage.
     *
     * @param Indexable|bool $indexable Optional. An existing indexable to overwrite.
     *
     * @return Indexable The home page indexable.
     */
    public function build_for_home_page($indexable = false)
    {
    }
    /**
     * Creates an indexable for the date archive.
     *
     * @param Indexable|bool $indexable Optional. An existing indexable to overwrite.
     *
     * @return Indexable The date archive indexable.
     */
    public function build_for_date_archive($indexable = false)
    {
    }
    /**
     * Creates an indexable for a post type archive.
     *
     * @param string         $post_type The post type.
     * @param Indexable|bool $indexable Optional. An existing indexable to overwrite.
     *
     * @return Indexable The post type archive indexable.
     */
    public function build_for_post_type_archive($post_type, $indexable = false)
    {
    }
    /**
     * Creates an indexable for a system page.
     *
     * @param string         $page_type The type of system page.
     * @param Indexable|bool $indexable Optional. An existing indexable to overwrite.
     *
     * @return Indexable The search result indexable.
     */
    public function build_for_system_page($page_type, $indexable = false)
    {
    }
    /**
     * Ensures we have a valid indexable. Creates one if false is passed.
     *
     * @param Indexable|false $indexable The indexable.
     * @param array           $defaults  The initial properties of the Indexable.
     *
     * @return Indexable The indexable.
     */
    private function ensure_indexable($indexable, $defaults = [])
    {
    }
    /**
     * Saves and returns an indexable (on production environments only).
     *
     * @param Indexable      $indexable        The indexable.
     * @param Indexable|null $indexable_before The indexable before possible changes.
     *
     * @return Indexable The indexable.
     */
    protected function save_indexable($indexable, $indexable_before = null)
    {
    }
    /**
     * Build and author indexable from an author id if it does not exist yet, or if the author indexable needs to be upgraded.
     *
     * @param int $author_id The author id.
     *
     * @return Indexable|false The author indexable if it has been built, `false` if it could not be built.
     */
    protected function maybe_build_author_indexable($author_id)
    {
    }
    /**
     * Checks if the indexable type is one that is not supposed to have object ID for.
     *
     * @param string $type The type of the indexable.
     *
     * @return bool Whether the indexable type is one that is not supposed to have object ID for.
     */
    private function is_type_with_no_id($type)
    {
    }
    // phpcs:disable Squiz.Commenting.FunctionCommentThrowTag.Missing -- Exceptions are handled by the catch statement in the method.
    /**
     * Rebuilds an Indexable from scratch.
     *
     * @param Indexable  $indexable The Indexable to (re)build.
     * @param array|null $defaults  The object type of the Indexable.
     *
     * @return Indexable|false The resulting Indexable.
     */
    public function build($indexable, $defaults = null)
    {
    }
    // phpcs:enable
  }
  /**
   * Date Archive Builder for the indexables.
   *
   * Formats the date archive meta to indexable format.
   */
  class Indexable_Date_Archive_Builder
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * The latest version of the Indexable_Date_Archive_Builder.
     *
     * @var int
     */
    protected $version;
    /**
     * Indexable_Date_Archive_Builder constructor.
     *
     * @param Options_Helper             $options  The options helper.
     * @param Indexable_Builder_Versions $versions The latest version for all indexable builders.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions)
    {
    }
    /**
     * Formats the data.
     *
     * @param Indexable $indexable The indexable to format.
     *
     * @return Indexable The extended indexable.
     */
    public function build($indexable)
    {
    }
  }
  /**
   * Builder for the indexables hierarchy.
   *
   * Builds the indexable hierarchy for indexables.
   */
  class Indexable_Hierarchy_Builder
  {
    /**
     * Holds a list of indexables where the ancestors are saved for.
     *
     * @var array
     */
    protected $saved_ancestors = [];
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    private $indexable_repository;
    /**
     * The indexable hierarchy repository.
     *
     * @var Indexable_Hierarchy_Repository
     */
    private $indexable_hierarchy_repository;
    /**
     * The primary term repository.
     *
     * @var Primary_Term_Repository
     */
    private $primary_term_repository;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Holds the Post_Helper instance.
     *
     * @var Post_Helper
     */
    private $post;
    /**
     * Indexable_Author_Builder constructor.
     *
     * @param Indexable_Hierarchy_Repository $indexable_hierarchy_repository The indexable hierarchy repository.
     * @param Primary_Term_Repository        $primary_term_repository        The primary term repository.
     * @param Options_Helper                 $options                        The options helper.
     * @param Post_Helper                    $post                           The post helper.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Hierarchy_Repository $indexable_hierarchy_repository, \Yoast\WP\SEO\Repositories\Primary_Term_Repository $primary_term_repository, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Post_Helper $post)
    {
    }
    /**
     * Sets the indexable repository. Done to avoid circular dependencies.
     *
     * @required
     *
     * @param Indexable_Repository $indexable_repository The indexable repository.
     */
    public function set_indexable_repository(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Builds the ancestor hierarchy for an indexable.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return Indexable The indexable.
     */
    public function build(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Checks if a hierarchy is built already for the given indexable.
     *
     * @param Indexable $indexable The indexable to check.
     *
     * @return bool True when indexable has a built hierarchy.
     */
    protected function hierarchy_is_built(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Saves the ancestors.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return void
     */
    private function save_ancestors($indexable)
    {
    }
    /**
     * Adds ancestors for a post.
     *
     * @param int   $indexable_id The indexable id, this is the id of the original indexable.
     * @param int   $post_id      The post id, this is the id of the post currently being evaluated.
     * @param int[] $parents      The indexable IDs of all parents.
     *
     * @return void
     */
    private function add_ancestors_for_post($indexable_id, $post_id, &$parents)
    {
    }
    /**
     * Adds ancestors for a term.
     *
     * @param int   $indexable_id The indexable id, this is the id of the original indexable.
     * @param int   $term_id      The term id, this is the id of the term currently being evaluated.
     * @param int[] $parents      The indexable IDs of all parents.
     *
     * @return void
     */
    private function add_ancestors_for_term($indexable_id, $term_id, &$parents = [])
    {
    }
    /**
     * Gets the primary term ID for a post.
     *
     * @param WP_Post $post The post.
     *
     * @return int The primary term ID. 0 if none exists.
     */
    private function find_primary_term_id_for_post($post)
    {
    }
    /**
     * Find the deepest term in an array of term objects.
     *
     * @param array $terms Terms set.
     *
     * @return int The deepest term ID.
     */
    private function find_deepest_term_id($terms)
    {
    }
    /**
     * Get a term's parents.
     *
     * @param WP_Term $term Term to get the parents for.
     *
     * @return WP_Term[] An array of all this term's parents.
     */
    private function get_term_parents($term)
    {
    }
    /**
     * Checks if an ancestor is valid to add.
     *
     * @param Indexable $ancestor     The ancestor (presumed indexable) to check.
     * @param int       $indexable_id The indexable id we're adding ancestors for.
     * @param int[]     $parents      The indexable ids of the parents already added.
     *
     * @return bool
     */
    private function is_invalid_ancestor($ancestor, $indexable_id, $parents)
    {
    }
    /**
     * Returns the ID for an indexable. Catches situations where the id is null due to errors.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return string|int A unique ID for the indexable.
     */
    private function get_indexable_id(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Returns the primary term id of a post.
     *
     * @param int    $post_id       The post ID.
     * @param string $main_taxonomy The main taxonomy.
     *
     * @return int The ID of the primary term.
     */
    private function get_primary_term_id($post_id, $main_taxonomy)
    {
    }
  }
  /**
   * Homepage Builder for the indexables.
   *
   * Formats the homepage meta to indexable format.
   */
  class Indexable_Home_Page_Builder
  {
    use \Yoast\WP\SEO\Builders\Indexable_Social_Image_Trait;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    protected $url_helper;
    /**
     * The latest version of the Indexable-Home-Page-Builder.
     *
     * @var int
     */
    protected $version;
    /**
     * Holds the taxonomy helper instance.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The WPDB instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Indexable_Home_Page_Builder constructor.
     *
     * @param Options_Helper             $options     The options helper.
     * @param Url_Helper                 $url_helper  The url helper.
     * @param Indexable_Builder_Versions $versions    Knows the latest version of each Indexable type.
     * @param Post_Helper                $post_helper The post helper.
     * @param wpdb                       $wpdb        The WPDB instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Url_Helper $url_helper, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions, \Yoast\WP\SEO\Helpers\Post_Helper $post_helper, \wpdb $wpdb)
    {
    }
    /**
     * Formats the data.
     *
     * @param Indexable $indexable The indexable to format.
     *
     * @return Indexable The extended indexable.
     */
    public function build($indexable)
    {
    }
    /**
     * Returns the timestamps for the homepage.
     *
     * @return object An object with last_modified and published_at timestamps.
     */
    protected function get_object_timestamps()
    {
    }
  }
  /**
   * Indexable link builder.
   */
  class Indexable_Link_Builder
  {
    /**
     * The SEO links repository.
     *
     * @var SEO_Links_Repository
     */
    protected $seo_links_repository;
    /**
     * The url helper.
     *
     * @var Url_Helper
     */
    protected $url_helper;
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    protected $image_helper;
    /**
     * The post helper.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Indexable_Link_Builder constructor.
     *
     * @param SEO_Links_Repository $seo_links_repository The SEO links repository.
     * @param Url_Helper           $url_helper           The URL helper.
     * @param Post_Helper          $post_helper          The post helper.
     * @param Options_Helper       $options_helper       The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\SEO_Links_Repository $seo_links_repository, \Yoast\WP\SEO\Helpers\Url_Helper $url_helper, \Yoast\WP\SEO\Helpers\Post_Helper $post_helper, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Sets the indexable repository.
     *
     * @required
     *
     * @param Indexable_Repository $indexable_repository The indexable repository.
     * @param Image_Helper         $image_helper         The image helper.
     *
     * @return void
     */
    public function set_dependencies(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository, \Yoast\WP\SEO\Helpers\Image_Helper $image_helper)
    {
    }
    /**
     * Builds the links for a post.
     *
     * @param Indexable $indexable The indexable.
     * @param string    $content   The content. Expected to be unfiltered.
     *
     * @return SEO_Links[] The created SEO links.
     */
    public function build($indexable, $content)
    {
    }
    /**
     * Deletes all SEO links for an indexable.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return void
     */
    public function delete($indexable)
    {
    }
    /**
     * Fixes existing SEO links that are supposed to have a target indexable but don't, because of prior indexable cleanup.
     *
     * @param Indexable $indexable The indexable to be the target of SEO Links.
     *
     * @return void
     */
    public function patch_seo_links(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Gathers all links from content.
     *
     * @param string $content The content.
     *
     * @return string[] An array of urls.
     */
    protected function gather_links($content)
    {
    }
    /**
     * Gathers all images from content.
     *
     * @param string $content The content.
     *
     * @return string[] An array of urls.
     */
    protected function gather_images($content)
    {
    }
    /**
     * Creates link models from lists of URLs and image sources.
     *
     * @param Indexable $indexable The indexable.
     * @param string[]  $links     The link URLs.
     * @param string[]  $images    The image sources.
     *
     * @return SEO_Links[] The link models.
     */
    protected function create_links($indexable, $links, $images)
    {
    }
    /**
     * Get the post ID based on the link's type and its target's permalink.
     *
     * @param string $type      The type of link (either SEO_Links::TYPE_INTERNAL or SEO_Links::TYPE_INTERNAL_IMAGE).
     * @param string $permalink The permalink of the link's target.
     *
     * @return int The post ID.
     */
    protected function get_post_id($type, $permalink)
    {
    }
    /**
     * Creates an internal link.
     *
     * @param string    $url       The url of the link.
     * @param array     $home_url  The home url, as parsed by wp_parse_url.
     * @param Indexable $indexable The indexable of the post containing the link.
     * @param bool      $is_image  Whether or not the link is an image.
     *
     * @return SEO_Links The created link.
     */
    protected function create_internal_link($url, $home_url, $indexable, $is_image = false)
    {
    }
    /**
     * Enhances the link model with information from its indexable.
     *
     * @param SEO_Links $model     The link's model.
     * @param string    $permalink The link's permalink.
     *
     * @return SEO_Links The enhanced link model.
     */
    protected function enhance_link_from_indexable($model, $permalink)
    {
    }
    /**
     * Builds the link's permalink.
     *
     * @param string $url      The url of the link.
     * @param array  $home_url The home url, as parsed by wp_parse_url.
     *
     * @return string The link's permalink.
     */
    protected function build_permalink($url, $home_url)
    {
    }
    /**
     * Filters out links that point to the same page with a fragment or query.
     *
     * @param SEO_Links $link        The link.
     * @param array     $current_url The url of the page the link is on, as parsed by wp_parse_url.
     *
     * @return bool Whether or not the link should be filtered.
     */
    protected function filter_link(\Yoast\WP\SEO\Models\SEO_Links $link, $current_url)
    {
    }
    /**
     * Updates the link counts for related indexables.
     *
     * @param Indexable   $indexable The indexable.
     * @param SEO_Links[] $links     The link models.
     *
     * @return void
     */
    protected function update_related_indexables($indexable, $links)
    {
    }
    /**
     * Creates a diff between two arrays of SEO links, based on urls.
     *
     * @param SEO_Links[] $links_a The array to compare.
     * @param SEO_Links[] $links_b The array to compare against.
     *
     * @return SEO_Links[] Links that are in $links_a, but not in $links_b.
     */
    protected function links_diff($links_a, $links_b)
    {
    }
    /**
     * Returns the number of internal links in an array of link models.
     *
     * @param SEO_Links[] $links The link models.
     *
     * @return int The number of internal links.
     */
    protected function get_internal_link_count($links)
    {
    }
    /**
     * Returns a cleaned permalink for a given link.
     *
     * @param string $link     The raw URL.
     * @param array  $home_url The home URL, as parsed by wp_parse_url.
     *
     * @return string The cleaned permalink.
     */
    protected function get_permalink($link, $home_url)
    {
    }
    /**
     * Updates incoming link counts for related indexables.
     *
     * @param int[] $related_indexable_ids The IDs of all related indexables.
     *
     * @return void
     */
    protected function update_incoming_links_for_related_indexables($related_indexable_ids)
    {
    }
  }
  /**
   * Post Builder for the indexables.
   *
   * Formats the post meta to indexable format.
   */
  class Indexable_Post_Builder
  {
    use \Yoast\WP\SEO\Builders\Indexable_Social_Image_Trait;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Holds the Post_Helper instance.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * Knows the latest version of the Indexable post builder type.
     *
     * @var int
     */
    protected $version;
    /**
     * The meta helper.
     *
     * @var Meta_Helper
     */
    protected $meta;
    /**
     * Indexable_Post_Builder constructor.
     *
     * @param Post_Helper                $post_helper      The post helper.
     * @param Post_Type_Helper           $post_type_helper The post type helper.
     * @param Indexable_Builder_Versions $versions         The indexable builder versions.
     * @param Meta_Helper                $meta             The meta helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Helper $post_helper, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions, \Yoast\WP\SEO\Helpers\Meta_Helper $meta)
    {
    }
    /**
     * Sets the indexable repository. Done to avoid circular dependencies.
     *
     * @required
     *
     * @param Indexable_Repository $indexable_repository The indexable repository.
     */
    public function set_indexable_repository(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Formats the data.
     *
     * @param int       $post_id   The post ID to use.
     * @param Indexable $indexable The indexable to format.
     *
     * @return bool|Indexable The extended indexable. False when unable to build.
     *
     * @throws Post_Not_Found_Exception When the post could not be found.
     * @throws Post_Not_Built_Exception When the post should not be indexed.
     */
    public function build($post_id, $indexable)
    {
    }
    /**
     * Retrieves the permalink for a post with the given post type and ID.
     *
     * @param string $post_type The post type.
     * @param int    $post_id   The post ID.
     *
     * @return false|string|WP_Error The permalink.
     */
    protected function get_permalink($post_type, $post_id)
    {
    }
    /**
     * Determines the value of is_public.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return bool|null Whether or not the post type is public. Null if no override is set.
     */
    protected function is_public($indexable)
    {
    }
    /**
     * Determines the value of is_public for attachments.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return bool|null False when it has no parent. Null when it has a parent.
     */
    protected function is_public_attachment($indexable)
    {
    }
    /**
     * Determines the value of has_public_posts.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return bool|null Whether the attachment has a public parent, can be true, false and null. Null when it is not an attachment.
     */
    protected function has_public_posts($indexable)
    {
    }
    /**
     * Converts the meta robots noindex value to the indexable value.
     *
     * @param int $value Meta value to convert.
     *
     * @return bool|null True for noindex, false for index, null for default of parent/type.
     */
    protected function get_robots_noindex($value)
    {
    }
    /**
     * Retrieves the robot options to search for.
     *
     * @return array List of robots values.
     */
    protected function get_robots_options()
    {
    }
    /**
     * Determines the focus keyword score.
     *
     * @param string $keyword The focus keyword that is set.
     * @param int    $score   The score saved on the meta data.
     *
     * @return int|null Score to use.
     */
    protected function get_keyword_score($keyword, $score)
    {
    }
    /**
     * Retrieves the lookup table.
     *
     * @return array Lookup table for the indexable fields.
     */
    protected function get_indexable_lookup()
    {
    }
    /**
     * Finds an alternative image for the social image.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return array|bool False when not found, array with data when found.
     */
    protected function find_alternative_image(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Gets the number of pages for a post.
     *
     * @param object $post The post object.
     *
     * @return int|null The number of pages or null if the post isn't paginated.
     */
    protected function get_number_of_pages_for_post($post)
    {
    }
    /**
     * Checks whether an indexable should be built for this post.
     *
     * @param WP_Post $post The post for which an indexable should be built.
     *
     * @return bool `true` if the post should be excluded from building, `false` if not.
     */
    protected function should_exclude_post($post)
    {
    }
    /**
     * Transforms an empty string into null. Leaves non-empty strings intact.
     *
     * @param string $text The string.
     *
     * @return string|null The input string or null.
     */
    protected function empty_string_to_null($text)
    {
    }
  }
  /**
   * Post type archive builder for the indexables.
   *
   * Formats the post type archive meta to indexable format.
   */
  class Indexable_Post_Type_Archive_Builder
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * The latest version of the Indexable_Post_Type_Archive_Builder.
     *
     * @var int
     */
    protected $version;
    /**
     * Holds the taxonomy helper instance.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The WPDB instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Indexable_Post_Type_Archive_Builder constructor.
     *
     * @param Options_Helper             $options     The options helper.
     * @param Indexable_Builder_Versions $versions    The latest version of each Indexable builder.
     * @param Post_Helper                $post_helper The post helper.
     * @param wpdb                       $wpdb        The WPDB instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions, \Yoast\WP\SEO\Helpers\Post_Helper $post_helper, \wpdb $wpdb)
    {
    }
    /**
     * Formats the data.
     *
     * @param string    $post_type The post type to build the indexable for.
     * @param Indexable $indexable The indexable to format.
     *
     * @return Indexable The extended indexable.
     */
    public function build($post_type, \Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Returns the fallback breadcrumb title for a given post.
     *
     * @param string $post_type The post type to get the fallback breadcrumb title for.
     *
     * @return string
     */
    private function get_breadcrumb_title($post_type)
    {
    }
    /**
     * Returns the timestamps for a given post type.
     *
     * @param string $post_type The post type.
     *
     * @return object An object with last_modified and published_at timestamps.
     */
    protected function get_object_timestamps($post_type)
    {
    }
  }
  /**
   * System page builder for the indexables.
   *
   * Formats system pages ( search and error ) meta to indexable format.
   */
  class Indexable_System_Page_Builder
  {
    /**
     * Mapping of object type to title option keys.
     */
    const OPTION_MAPPING = ['search-result' => ['title' => 'title-search-wpseo'], '404' => ['title' => 'title-404-wpseo', 'breadcrumb_title' => 'breadcrumbs-404crumb']];
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * The latest version of the Indexable_System_Page_Builder.
     *
     * @var int
     */
    protected $version;
    /**
     * Indexable_System_Page_Builder constructor.
     *
     * @param Options_Helper             $options  The options helper.
     * @param Indexable_Builder_Versions $versions The latest version of each Indexable Builder.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions)
    {
    }
    /**
     * Formats the data.
     *
     * @param string    $object_sub_type The object sub type of the system page.
     * @param Indexable $indexable       The indexable to format.
     *
     * @return Indexable The extended indexable.
     */
    public function build($object_sub_type, \Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
  }
  /**
   * Term Builder for the indexables.
   *
   * Formats the term meta to indexable format.
   */
  class Indexable_Term_Builder
  {
    use \Yoast\WP\SEO\Builders\Indexable_Social_Image_Trait;
    /**
     * Holds the taxonomy helper instance.
     *
     * @var Taxonomy_Helper
     */
    protected $taxonomy_helper;
    /**
     * The latest version of the Indexable_Term_Builder.
     *
     * @var int
     */
    protected $version;
    /**
     * Holds the taxonomy helper instance.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The WPDB instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Indexable_Term_Builder constructor.
     *
     * @param Taxonomy_Helper            $taxonomy_helper The taxonomy helper.
     * @param Indexable_Builder_Versions $versions        The latest version of each Indexable Builder.
     * @param Post_Helper                $post_helper     The post helper.
     * @param wpdb                       $wpdb            The WPDB instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy_helper, \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $versions, \Yoast\WP\SEO\Helpers\Post_Helper $post_helper, \wpdb $wpdb)
    {
    }
    /**
     * Formats the data.
     *
     * @param int       $term_id   ID of the term to save data for.
     * @param Indexable $indexable The indexable to format.
     *
     * @return bool|Indexable The extended indexable. False when unable to build.
     *
     * @throws Invalid_Term_Exception   When the term is invalid.
     * @throws Term_Not_Built_Exception When the term is not viewable.
     * @throws Term_Not_Found_Exception When the term is not found.
     */
    public function build($term_id, $indexable)
    {
    }
    /**
     * Converts the meta noindex value to the indexable value.
     *
     * @param string $meta_value Term meta to base the value on.
     *
     * @return bool|null
     */
    protected function get_noindex_value($meta_value)
    {
    }
    /**
     * Determines the focus keyword score.
     *
     * @param string $keyword The focus keyword that is set.
     * @param int    $score   The score saved on the meta data.
     *
     * @return int|null Score to use.
     */
    protected function get_keyword_score($keyword, $score)
    {
    }
    /**
     * Retrieves the lookup table.
     *
     * @return array Lookup table for the indexable fields.
     */
    protected function get_indexable_lookup()
    {
    }
    /**
     * Retrieves a meta value from the given meta data.
     *
     * @param string $meta_key  The key to extract.
     * @param array  $term_meta The meta data.
     *
     * @return string|null The meta value.
     */
    protected function get_meta_value($meta_key, $term_meta)
    {
    }
    /**
     * Finds an alternative image for the social image.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return array|bool False when not found, array with data when found.
     */
    protected function find_alternative_image(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Returns the timestamps for a given term.
     *
     * @param int    $term_id  The term ID.
     * @param string $taxonomy The taxonomy.
     *
     * @return object An object with last_modified and published_at timestamps.
     */
    protected function get_object_timestamps($term_id, $taxonomy)
    {
    }
  }
  /**
   * Primary term builder.
   *
   * Creates the primary term for a post.
   */
  class Primary_Term_Builder
  {
    /**
     * The primary term repository.
     *
     * @var Primary_Term_Repository
     */
    protected $repository;
    /**
     * The primary term helper.
     *
     * @var Primary_Term_Helper
     */
    private $primary_term;
    /**
     * The meta helper.
     *
     * @var Meta_Helper
     */
    private $meta;
    /**
     * Primary_Term_Builder constructor.
     *
     * @param Primary_Term_Repository $repository   The primary term repository.
     * @param Primary_Term_Helper     $primary_term The primary term helper.
     * @param Meta_Helper             $meta         The meta helper.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Primary_Term_Repository $repository, \Yoast\WP\SEO\Helpers\Primary_Term_Helper $primary_term, \Yoast\WP\SEO\Helpers\Meta_Helper $meta)
    {
    }
    /**
     * Formats and saves the primary terms for the post with the given post id.
     *
     * @param int $post_id The post ID.
     *
     * @return void
     */
    public function build($post_id)
    {
    }
    /**
     * Save the primary term for a specific taxonomy.
     *
     * @param int    $post_id  Post ID to save primary term for.
     * @param string $taxonomy Taxonomy to save primary term for.
     *
     * @return void
     */
    protected function save_primary_term($post_id, $taxonomy)
    {
    }
  }
}

namespace Yoast\WP\SEO\Commands {
  /**
   * Interface definition for WP CLI commands.
   *
   * An interface for registering integrations with WordPress.
   */
  interface Command_Interface
  {
    /**
     * Returns the namespace of this command.
     *
     * @return string
     */
    public static function get_namespace();
  }
  /**
   * A WP CLI command that helps with cleaning up unwanted records from our custom tables.
   */
  final class Cleanup_Command implements \Yoast\WP\SEO\Commands\Command_Interface
  {
    /**
     * The integration that cleans up on cron.
     *
     * @var Cleanup_Integration
     */
    private $cleanup_integration;
    /**
     * The constructor.
     *
     * @param Cleanup_Integration $cleanup_integration The integration that cleans up on cron.
     */
    public function __construct(\Yoast\WP\SEO\Integrations\Cleanup_Integration $cleanup_integration)
    {
    }
    /**
     * Returns the namespace of this command.
     *
     * @return string
     */
    public static function get_namespace()
    {
    }
    /**
     * Performs a cleanup of custom Yoast tables.
     *
     * This removes unused, unwanted or orphaned database records, which ensures the best performance. Including:
     * - Indexables
     * - Indexable hierarchy
     * - SEO links
     *
     * ## OPTIONS
     *
     * [--batch-size=<batch-size>]
     * : The number of database records to clean up in a single sql query.
     * ---
     * default: 1000
     * ---
     *
     * [--interval=<interval>]
     * : The number of microseconds (millionths of a second) to wait between cleanup batches.
     * ---
     * default: 500000
     * ---
     *
     * [--network]
     * : Performs the cleanup on all sites within the network.
     *
     * ## EXAMPLES
     *
     *     wp yoast cleanup
     *
     * @when after_wp_load
     *
     * @param array|null $args       The arguments.
     * @param array|null $assoc_args The associative arguments.
     *
     * @return void
     *
     * @throws ExitException When the input args are invalid.
     */
    public function cleanup($args = null, $assoc_args = null)
    {
    }
    /**
     * Performs the cleanup for the entire network.
     *
     * @param array|null $assoc_args The associative arguments.
     *
     * @return int The number of cleaned up records.
     */
    private function cleanup_network($assoc_args)
    {
    }
    /**
     * Performs the cleanup for a single site.
     *
     * @param array|null $assoc_args The associative arguments.
     *
     * @return int The number of cleaned up records.
     */
    private function cleanup_current_site($assoc_args)
    {
    }
  }
  /**
   * Command to generate indexables for all posts and terms.
   */
  class Index_Command implements \Yoast\WP\SEO\Commands\Command_Interface
  {
    /**
     * The post indexation action.
     *
     * @var Indexable_Post_Indexation_Action
     */
    private $post_indexation_action;
    /**
     * The term indexation action.
     *
     * @var Indexable_Term_Indexation_Action
     */
    private $term_indexation_action;
    /**
     * The post type archive indexation action.
     *
     * @var Indexable_Post_Type_Archive_Indexation_Action
     */
    private $post_type_archive_indexation_action;
    /**
     * The general indexation action.
     *
     * @var Indexable_General_Indexation_Action
     */
    private $general_indexation_action;
    /**
     * The term link indexing action.
     *
     * @var Term_Link_Indexing_Action
     */
    private $term_link_indexing_action;
    /**
     * The post link indexing action.
     *
     * @var Post_Link_Indexing_Action
     */
    private $post_link_indexing_action;
    /**
     * The complete indexation action.
     *
     * @var Indexable_Indexing_Complete_Action
     */
    private $complete_indexation_action;
    /**
     * The indexing prepare action.
     *
     * @var Indexing_Prepare_Action
     */
    private $prepare_indexing_action;
    /**
     * Generate_Indexables_Command constructor.
     *
     * @param Indexable_Post_Indexation_Action              $post_indexation_action              The post indexation
     *                                                                                           action.
     * @param Indexable_Term_Indexation_Action              $term_indexation_action              The term indexation
     *                                                                                           action.
     * @param Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation_action The post type archive
     *                                                                                           indexation action.
     * @param Indexable_General_Indexation_Action           $general_indexation_action           The general indexation
     *                                                                                           action.
     * @param Indexable_Indexing_Complete_Action            $complete_indexation_action          The complete indexation
     *                                                                                           action.
     * @param Indexing_Prepare_Action                       $prepare_indexing_action             The prepare indexing
     *                                                                                           action.
     * @param Post_Link_Indexing_Action                     $post_link_indexing_action           The post link indexation
     *                                                                                           action.
     * @param Term_Link_Indexing_Action                     $term_link_indexing_action           The term link indexation
     *                                                                                           action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Indexation_Action $post_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_Term_Indexation_Action $term_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_General_Indexation_Action $general_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_Indexing_Complete_Action $complete_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexing_Prepare_Action $prepare_indexing_action, \Yoast\WP\SEO\Actions\Indexing\Post_Link_Indexing_Action $post_link_indexing_action, \Yoast\WP\SEO\Actions\Indexing\Term_Link_Indexing_Action $term_link_indexing_action)
    {
    }
    /**
     * Gets the namespace.
     *
     * @return string
     */
    public static function get_namespace()
    {
    }
    /**
     * Indexes all your content to ensure the best performance.
     *
     * ## OPTIONS
     *
     * [--network]
     * : Performs the indexation on all sites within the network.
     *
     * [--reindex]
     * : Removes all existing indexables and then reindexes them.
     *
     * [--skip-confirmation]
     * : Skips the confirmations (for automated systems).
     *
     * [--interval=<interval>]
     * : The number of microseconds (millionths of a second) to wait between index actions.
     * ---
     * default: 500000
     * ---
     *
     * ## EXAMPLES
     *
     *     wp yoast index
     *
     * @when after_wp_load
     *
     * @param array|null $args       The arguments.
     * @param array|null $assoc_args The associative arguments.
     *
     * @return void
     */
    public function index($args = null, $assoc_args = null)
    {
    }
    /**
     * Runs all indexation actions.
     *
     * @param array $assoc_args The associative arguments.
     *
     * @return void
     */
    protected function run_indexation_actions($assoc_args)
    {
    }
    /**
     * Runs an indexation action.
     *
     * @param string                      $name              The name of the object to be indexed.
     * @param Indexation_Action_Interface $indexation_action The indexation action.
     * @param int                         $interval          Number of microseconds (millionths of a second) to wait between index actions.
     *
     * @return void
     */
    protected function run_indexation_action($name, \Yoast\WP\SEO\Actions\Indexing\Indexation_Action_Interface $indexation_action, $interval)
    {
    }
    /**
     * Clears the database related to the indexables.
     */
    protected function clear()
    {
    }
  }
}

namespace Yoast\WP\SEO\Conditionals {
  /**
   * Conditional interface, used to prevent integrations from loading.
   */
  interface Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met();
  }
  /**
   * Abstract class for creating conditionals based on feature flags.
   */
  abstract class Feature_Flag_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
    /**
     * Returns the name of the feature flag.
     * 'YOAST_SEO_' is automatically prepended to it and it will be uppercased.
     *
     * @return string the name of the feature flag.
     */
    protected abstract function get_feature_flag();
    /**
     * Returns the feature name.
     *
     * @return string the name of the feature flag.
     */
    public function get_feature_name()
    {
    }
  }
  /**
   * Checks if the Addon_Installation constant is set.
   */
  class Addon_Installation_Conditional extends \Yoast\WP\SEO\Conditionals\Feature_Flag_Conditional
  {
    /**
     * Returns the name of the feature flag.
     * 'YOAST_SEO_' is automatically prepended to it and it will be uppercased.
     *
     * @return string the name of the feature flag.
     */
    protected function get_feature_flag()
    {
    }
  }
  /**
   * Conditional that is only met when in the admin.
   */
  class Admin_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
}

namespace Yoast\WP\SEO\Conditionals\Admin {
  /**
   * Checks if the post is saved by inline-save. This is the case when doing quick edit.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded -- Base class can't be written shorter without abbreviating.
   */
  class Doing_Post_Quick_Edit_Save_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Checks if the current request is ajax and the action is inline-save.
     *
     * @return bool True when the quick edit action is executed.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only when we want the Estimated Reading Time.
   */
  class Estimated_Reading_Time_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The Post Conditional.
     *
     * @var Post_Conditional
     */
    protected $post_conditional;
    /**
     * Constructs the Estimated Reading Time Conditional.
     *
     * @param Post_Conditional $post_conditional The post conditional.
     */
    public function __construct(\Yoast\WP\SEO\Conditionals\Admin\Post_Conditional $post_conditional)
    {
    }
    /**
     * Returns whether this conditional is met.
     *
     * @return bool Whether the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when current page is the tools page.
   */
  class Licenses_Page_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when not on a network admin page.
   */
  class Non_Network_Admin_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when on a post edit or new post page.
   */
  class Post_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when on a post overview page or during an ajax request.
   */
  class Posts_Overview_Or_Ajax_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
}

namespace Yoast\WP\SEO\Conditionals {
  /**
   * Conditional that is only met when the 'Redirect attachment URLs to the attachment itself' setting is enabled.
   */
  class Attachment_Redirections_Enabled_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Attachment_Redirections_Enabled_Conditional constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Returns whether the 'Redirect attachment URLs to the attachment itself' setting has been enabled.
     *
     * @return bool `true` when the 'Redirect attachment URLs to the attachment itself' setting has been enabled.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when in development mode.
   */
  class Development_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when NOT in the admin.
   */
  class Front_End_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns `true` when NOT on an admin page.
     *
     * @return bool `true` when NOT on an admin page.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when the current request uses the GET method.
   */
  class Get_Request_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when the headless rest endpoints are enabled.
   */
  class Headless_Rest_Endpoints_Enabled_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Headless_Rest_Endpoints_Enabled_Conditional constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Returns `true` whether the headless REST endpoints have been enabled.
     *
     * @return bool `true` when the headless REST endpoints have been enabled.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when current page is not a specific tool's page.
   */
  class Import_Tool_Selected_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when Jetpack exists.
   */
  class Jetpack_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns `true` when the Jetpack plugin exists on this
     * WordPress installation.
     *
     * @return bool `true` when the Jetpack plugin exists on this WordPress installation.
     */
    public function is_met()
    {
    }
  }
  /**
   * Feature flag conditional for the new settings UI.
   */
  class New_Settings_Ui_Conditional extends \Yoast\WP\SEO\Conditionals\Feature_Flag_Conditional
  {
    /**
     * Returns the name of the feature flag.
     *
     * @return string The name of the feature flag.
     */
    protected function get_feature_flag()
    {
    }
  }
  /**
   * Conditional that is only met when news SEO is activated.
   */
  class News_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Trait for integrations that do not have any conditionals.
   */
  trait No_Conditionals
  {
    /**
     * Returns an empty array, meaning no conditionals are required to load whatever uses this trait.
     *
     * @return array The conditionals that must be met to load this.
     */
    public static function get_conditionals()
    {
    }
  }
  /**
   * Conditional that is only met when current page is not a specific tool's page.
   */
  class No_Tool_Selected_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when we aren't in a multisite setup.
   */
  class Non_Multisite_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns `true` when we aren't in a multisite setup.
     *
     * @return bool `true` when we aren't in a multisite setup.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when not in a admin-ajax request.
   */
  class Not_Admin_Ajax_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when the Open Graph feature is enabled.
   */
  class Open_Graph_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Open_Graph_Conditional constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Returns `true` when the Open Graph feature is enabled.
     *
     * @return bool `true` when the Open Graph feature is enabled.
     */
    public function is_met()
    {
    }
  }
  /**
   * Class Premium_Active_Conditional.
   */
  class Premium_Active_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Abstract class for creating conditionals based on feature flags.
   */
  class Premium_Inactive_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when in frontend or page is a post overview or post add/edit form.
   */
  class Primary_Category_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    private $current_page;
    /**
     * Primary_Category_Conditional constructor.
     *
     * @param Current_Page_Helper $current_page The current page helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page)
    {
    }
    /**
     * Returns `true` when on the frontend,
     * or when on the post overview, post edit or new post admin page,
     * or when on additional admin pages, allowed by filter.
     *
     * @return bool `true` when on the frontend, or when on the post overview,
     *          post edit, new post admin page or additional admin pages, allowed by filter.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when on the front end or Yoast file editor page.
   */
  class Robots_Txt_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Holds the Front_End_Conditional instance.
     *
     * @var Front_End_Conditional
     */
    protected $front_end_conditional;
    /**
     * Constructs the class.
     *
     * @param Front_End_Conditional $front_end_conditional The front end conditional.
     */
    public function __construct(\Yoast\WP\SEO\Conditionals\Front_End_Conditional $front_end_conditional)
    {
    }
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
    /**
     * Returns whether the current page is the file editor page.
     *
     * This checks for two locations:
     * - Multisite network admin file editor page
     * - Single site file editor page (under tools)
     *
     * @return bool
     */
    protected function is_file_editor_page()
    {
    }
  }
  /**
   * Conditional that is only met when the SEMrush integration is enabled.
   */
  class SEMrush_Enabled_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * SEMrush_Enabled_Conditional constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Class Settings_Conditional.
   */
  class Settings_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Holds User_Can_Manage_Wpseo_Options_Conditional.
     *
     * @var User_Can_Manage_Wpseo_Options_Conditional
     */
    protected $user_can_manage_wpseo_options_conditional;
    /**
     * Constructs Settings_Conditional.
     *
     * @param User_Can_Manage_Wpseo_Options_Conditional $user_can_manage_wpseo_options_conditional The User_Can_Manage_Wpseo_Options_Conditional.
     */
    public function __construct(\Yoast\WP\SEO\Conditionals\User_Can_Manage_Wpseo_Options_Conditional $user_can_manage_wpseo_options_conditional)
    {
    }
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Should_Index_Links_Conditional class.
   */
  class Should_Index_Links_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Should_Index_Links_Conditional constructor.
     *
     * @param Options_Helper $options_helper The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Returns `true` when the links on this website should be indexed.
     *
     * @return bool `true` when the links on this website should be indexed.
     */
    public function is_met()
    {
    }
  }
  /**
   * Checks if the YOAST_SEO_TEXT_FORMALITY constant is set.
   */
  class Text_Formality_Conditional extends \Yoast\WP\SEO\Conditionals\Feature_Flag_Conditional
  {
    /**
     * Returns the name of the feature flag.
     * 'YOAST_SEO_' is automatically prepended to it and it will be uppercased.
     *
     * @return string the name of the feature flag.
     */
    public function get_feature_flag()
    {
    }
  }
}

namespace Yoast\WP\SEO\Conditionals\Third_Party {
  /**
   * Conditional that is met when the Elementor plugin is installed and activated.
   */
  class Elementor_Activated_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Checks if the Elementor plugins is installed and activated.
     *
     * @return bool `true` when the Elementor plugin is installed and activated.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when on an Elementor edit page or when the current
   * request is an ajax request for saving our post meta data.
   */
  class Elementor_Edit_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether this conditional is met.
     *
     * @return bool Whether the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when Jetpack_Boost exists.
   */
  class Jetpack_Boost_Active_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns `true` when the Jetpack_Boost class exists within this WordPress installation.
     *
     * @return bool `true` when the Jetpack_Boost class exists within this WordPress installation.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is met when Jetpack Boost is not installed, activated or premium.
   */
  class Jetpack_Boost_Not_Premium_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Whether Jetpack Boost is not premium.
     *
     * @return bool Whether Jetpack Boost is not premium.
     */
    public function is_met()
    {
    }
    /**
     * Retrieves, if available, if Jetpack Boost has priority feature available.
     *
     * @return bool Whether Jetpack Boost is premium.
     */
    private function is_premium()
    {
    }
  }
  /**
   * Conditional that is only met when the Polylang plugin is active.
   */
  class Polylang_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Checks whether the Polylang plugin is installed and active.
     *
     * @return bool Whether Polylang is installed and active.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when the TranslatePress plugin is active.
   */
  class TranslatePress_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Checks whether the TranslatePress plugin is active.
     *
     * @return bool Whether the TranslatePress plugin is active.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when in the admin.
   */
  class W3_Total_Cache_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is met when the WordProof integration is toggled on.
   */
  class Wordproof_Integration_Active_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The WordProof helper.
     *
     * @var Wordproof_Helper
     */
    private $wordproof;
    /**
     * WordProof integration active constructor.
     *
     * @param Wordproof_Helper $wordproof The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Wordproof_Helper $wordproof)
    {
    }
    /**
     * Returns whether or not the WordProof Timestamp plugin is active.
     *
     * @return bool Whether or not the WordProof Timestamp plugin is active.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is met when the WordProof Timestamp plugin is inactive.
   */
  class Wordproof_Plugin_Inactive_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not the WordProof Timestamp plugin is active.
     *
     * @return bool Whether or not the WordProof Timestamp plugin is active.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when WPML is active.
   */
  class WPML_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is met when the Yoast SEO Multilingual plugin,
   * a glue plugin developed by and for WPML, is active.
   */
  class WPML_WPSEO_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Path to the Yoast SEO Multilingual plugin file.
     *
     * @internal
     */
    const PATH_TO_WPML_WPSEO_PLUGIN_FILE = 'wp-seo-multilingual/plugin.php';
    /**
     * Returns whether or not the Yoast SEO Multilingual plugin is active.
     *
     * @return bool Whether or not the Yoast SEO Multilingual plugin is active.
     */
    public function is_met()
    {
    }
  }
}

namespace Yoast\WP\SEO\Conditionals\Traits {
  /**
   * Trait for all integration that rely on the Admin-conditional
   */
  trait Admin_Conditional_Trait
  {
    /**
     * Returns an empty array, meaning no conditionals are required to load whatever uses this trait.
     *
     * @return array The conditionals that must be met to load this.
     */
    public static function get_conditionals()
    {
    }
  }
}

namespace Yoast\WP\SEO\Conditionals {
  /**
   * Feature flag conditional for the updated importer framework.
   */
  class Updated_Importer_Framework_Conditional extends \Yoast\WP\SEO\Conditionals\Feature_Flag_Conditional
  {
    /**
     * Returns the name of the updated importer framework feature flag.
     *
     * @return string The name of the feature flag.
     */
    protected function get_feature_flag()
    {
    }
  }
  /**
   * Conditional that is only met when the current user has the `wpseo_manage_options` capability.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded
   */
  class User_Can_Manage_Wpseo_Options_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when the current user has the `wpseo_manage_options` capability.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded
   */
  class User_Can_Publish_Posts_And_Pages_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when Web Stories are active.
   */
  class Web_Stories_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns `true` when the Web Stories plugins is installed and active.
     *
     * @return bool `true` when the Web Stories plugins is installed and active.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when the Wincher automatic tracking is enabled.
   */
  class Wincher_Automatically_Track_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Wincher_Automatically_Track_Conditional constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Returns whether this conditional is met.
     *
     * @return bool Whether the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional for the Wincher integration.
   */
  class Wincher_Conditional extends \Yoast\WP\SEO\Conditionals\Non_Multisite_Conditional
  {
  }
  /**
   * Conditional that is only met when the Wincher integration is enabled.
   */
  class Wincher_Enabled_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Wincher_Enabled_Conditional constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when the Wincher token is set.
   */
  class Wincher_Token_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * The Wincher client.
     *
     * @var Wincher_Client
     */
    private $client;
    /**
     * Wincher_Token_Conditional constructor.
     *
     * @param Wincher_Client $client The Wincher client.
     */
    public function __construct(\Yoast\WP\SEO\Config\Wincher_Client $client)
    {
    }
    /**
     * Returns whether this conditional is met.
     *
     * @return bool Whether the conditional is met.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when WooCommerce is active.
   */
  class WooCommerce_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns `true` when the WooCommerce plugin is installed and activated.
     *
     * @return bool `true` when the WooCommerce plugin is installed and activated.
     */
    public function is_met()
    {
    }
  }
  /**
   * Class that checks if wp_robots exists.
   */
  class WP_Robots_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Checks if the wp_robots function exists.
     *
     * @return bool True when the wp_robots function exists.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is met when the current request is an XML-RPC request.
   */
  class XMLRPC_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether the current request is an XML-RPC request.
     *
     * @return bool `true` when the current request is an XML-RPC request, `false` if not.
     */
    public function is_met()
    {
    }
  }
  /**
   * Conditional that is only met when in the admin dashboard, update or Yoast SEO pages.
   */
  class Yoast_Admin_And_Dashboard_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns `true` when on the admin dashboard, update or Yoast SEO pages.
     *
     * @return bool `true` when on the admin dashboard, update or Yoast SEO pages.
     */
    public function is_met()
    {
    }
    /**
     * Checks if we are on a theme or plugin upgrade page.
     *
     * @return bool Whether we are on a theme or plugin upgrade page.
     */
    private function on_upgrade_page()
    {
    }
  }
  /**
   * Conditional that is only met when current page is the tools page.
   */
  class Yoast_Tools_Page_Conditional implements \Yoast\WP\SEO\Conditionals\Conditional
  {
    /**
     * Returns whether or not this conditional is met.
     *
     * @return bool Whether or not the conditional is met.
     */
    public function is_met()
    {
    }
  }
}

namespace Yoast\WP\SEO\Config {
  /**
   * Class Badge_Group_Names.
   *
   * This class defines groups for "new" badges, with the version in which those groups are no longer considered
   * to be "new".
   */
  class Badge_Group_Names
  {
    const GROUP_GLOBAL_TEMPLATES = 'global-templates';
    /**
     * Constant describing when certain groups of new badges will no longer be shown.
     */
    const GROUP_NAMES = [self::GROUP_GLOBAL_TEMPLATES => '16.7-beta0'];
    /**
     * The current plugin version.
     *
     * @var string
     */
    protected $version;
    /**
     * Badge_Group_Names constructor.
     *
     * @param string|null $version Optional: the current plugin version.
     */
    public function __construct($version = null)
    {
    }
    /**
     * Check whether a group of badges is still eligible for a "new" badge.
     *
     * @param string      $group           One of the GROUP_* constants.
     * @param string|null $current_version The current version of the plugin that's being checked.
     *
     * @return bool Whether a group of badges is still eligible for a "new" badge.
     */
    public function is_still_eligible_for_new_badge($group, $current_version = null)
    {
    }
  }
  /**
   * Conflicting_Plugins class that holds all known conflicting plugins.
   */
  class Conflicting_Plugins
  {
    const OPEN_GRAPH_PLUGINS = [
      '2-click-socialmedia-buttons/2-click-socialmedia-buttons.php',
      // 2 Click Social Media Buttons.
      'add-link-to-facebook/add-link-to-facebook.php',
      // Add Link to Facebook.
      'add-meta-tags/add-meta-tags.php',
      // Add Meta Tags.
      'easy-facebook-share-thumbnails/esft.php',
      // Easy Facebook Share Thumbnail.
      'facebook/facebook.php',
      // Facebook (official plugin).
      'facebook-awd/AWD_facebook.php',
      // Facebook AWD All in one.
      'facebook-featured-image-and-open-graph-meta-tags/fb-featured-image.php',
      // Facebook Featured Image & OG Meta Tags.
      'facebook-meta-tags/facebook-metatags.php',
      // Facebook Meta Tags.
      'wonderm00ns-simple-facebook-open-graph-tags/wonderm00n-open-graph.php',
      // Facebook Open Graph Meta Tags for WordPress.
      'facebook-revised-open-graph-meta-tag/index.php',
      // Facebook Revised Open Graph Meta Tag.
      'facebook-thumb-fixer/_facebook-thumb-fixer.php',
      // Facebook Thumb Fixer.
      'facebook-and-digg-thumbnail-generator/facebook-and-digg-thumbnail-generator.php',
      // Fedmich's Facebook Open Graph Meta.
      'network-publisher/networkpub.php',
      // Network Publisher.
      'nextgen-facebook/nextgen-facebook.php',
      // NextGEN Facebook OG.
      'opengraph/opengraph.php',
      // Open Graph.
      'open-graph-protocol-framework/open-graph-protocol-framework.php',
      // Open Graph Protocol Framework.
      'seo-facebook-comments/seofacebook.php',
      // SEO Facebook Comments.
      'sexybookmarks/sexy-bookmarks.php',
      // Shareaholic.
      'shareaholic/sexy-bookmarks.php',
      // Shareaholic.
      'sharepress/sharepress.php',
      // SharePress.
      'simple-facebook-connect/sfc.php',
      // Simple Facebook Connect.
      'social-discussions/social-discussions.php',
      // Social Discussions.
      'social-sharing-toolkit/social_sharing_toolkit.php',
      // Social Sharing Toolkit.
      'socialize/socialize.php',
      // Socialize.
      'only-tweet-like-share-and-google-1/tweet-like-plusone.php',
      // Tweet, Like, Google +1 and Share.
      'wordbooker/wordbooker.php',
      // Wordbooker.
      'wpsso/wpsso.php',
      // WordPress Social Sharing Optimization.
      'wp-caregiver/wp-caregiver.php',
      // WP Caregiver.
      'wp-facebook-like-send-open-graph-meta/wp-facebook-like-send-open-graph-meta.php',
      // WP Facebook Like Send & Open Graph Meta.
      'wp-facebook-open-graph-protocol/wp-facebook-ogp.php',
      // WP Facebook Open Graph protocol.
      'wp-ogp/wp-ogp.php',
      // WP-OGP.
      'zoltonorg-social-plugin/zosp.php',
    ];
    const XML_SITEMAPS_PLUGINS = [
      'google-sitemap-plugin/google-sitemap-plugin.php',
      // Google Sitemap (BestWebSoft).
      'xml-sitemaps/xml-sitemaps.php',
      // XML Sitemaps (Denis de Bernardy and Mike Koepke).
      'bwp-google-xml-sitemaps/bwp-simple-gxs.php',
      // Better WordPress Google XML Sitemaps (Khang Minh).
      'google-sitemap-generator/sitemap.php',
      // Google XML Sitemaps (Arne Brachhold).
      'xml-sitemap-feed/xml-sitemap.php',
      // XML Sitemap & Google News feeds (RavanH).
      'google-monthly-xml-sitemap/monthly-xml-sitemap.php',
      // Google Monthly XML Sitemap (Andrea Pernici).
      'simple-google-sitemap-xml/simple-google-sitemap-xml.php',
      // Simple Google Sitemap XML (iTx Technologies).
      'another-simple-xml-sitemap/another-simple-xml-sitemap.php',
      // Another Simple XML Sitemap.
      'xml-maps/google-sitemap.php',
      // Xml Sitemap (Jason Martens).
      'google-xml-sitemap-generator-by-anton-dachauer/adachauer-google-xml-sitemap.php',
      // Google XML Sitemap Generator by Anton Dachauer (Anton Dachauer).
      'wp-xml-sitemap/wp-xml-sitemap.php',
      // WP XML Sitemap (Team Vivacity).
      'sitemap-generator-for-webmasters/sitemap.php',
      // Sitemap Generator for Webmasters (iwebslogtech).
      'xml-sitemap-xml-sitemapcouk/xmls.php',
      // XML Sitemap - XML-Sitemap.co.uk (Simon Hancox).
      'sewn-in-xml-sitemap/sewn-xml-sitemap.php',
      // Sewn In XML Sitemap (jcow).
      'rps-sitemap-generator/rps-sitemap-generator.php',
    ];
    const CLOAKING_PLUGINS = [
      'rs-head-cleaner/rs-head-cleaner.php',
      // RS Head Cleaner Plus https://wordpress.org/plugins/rs-head-cleaner/.
      'rs-head-cleaner-lite/rs-head-cleaner-lite.php',
    ];
    const SEO_PLUGINS = [
      'all-in-one-seo-pack/all_in_one_seo_pack.php',
      // All in One SEO Pack.
      'seo-ultimate/seo-ultimate.php',
      // SEO Ultimate.
      'seo-by-rank-math/rank-math.php',
    ];
    /**
     * Returns the list of all conflicting plugins.
     *
     * @return array The list of all conflicting plugins.
     */
    public static function all_plugins()
    {
    }
  }
  /**
   * Class Indexing_Reasons. Contains constants that aren't context specific.
   */
  class Indexing_Reasons
  {
    /**
     * Represents the reason that the indexing process failed and should be tried again.
     */
    const REASON_INDEXING_FAILED = 'indexing_failed';
    /**
     * Represents the reason that the permalink settings are changed.
     */
    const REASON_PERMALINK_SETTINGS = 'permalink_settings_changed';
    /**
     * Represents the reason that the category base is changed.
     */
    const REASON_CATEGORY_BASE_PREFIX = 'category_base_changed';
    /**
     * Represents the reason that the tag base is changed.
     */
    const REASON_TAG_BASE_PREFIX = 'tag_base_changed';
    /**
     * Represents the reason that the home url option is changed.
     */
    const REASON_HOME_URL_OPTION = 'home_url_option_changed';
    /**
     * Represents the reason that a post type has been made public.
     */
    const REASON_POST_TYPE_MADE_PUBLIC = 'post_type_made_public';
    /**
     * Represents the reason that a post type has been made viewable.
     */
    const REASON_TAXONOMY_MADE_PUBLIC = 'taxonomy_made_public';
    /**
     * Represents the reason that attachments have stopped being redirected.
     */
    const REASON_ATTACHMENTS_MADE_ENABLED = 'attachments_made_enabled';
  }
  /**
   * Migration_Status class.
   *
   * Used to validate whether or not migrations have been run and whether or not they should be run again.
   */
  class Migration_Status
  {
    /**
     * The migration option key.
     *
     * @var string
     */
    const MIGRATION_OPTION_KEY = 'yoast_migrations_';
    /**
     * The migration options.
     *
     * @var array
     */
    protected $migration_options = [];
    /**
     * Checks if a given migration should be run.
     *
     * @param string $name    The name of the migration.
     * @param string $version The current version.
     *
     * @return bool Whether or not the migration should be run.
     */
    public function should_run_migration($name, $version = \WPSEO_VERSION)
    {
    }
    /**
     * Checks whether or not the given migration is at least the given version, defaults to checking for the latest version.
     *
     * @param string $name    The name of the migration.
     * @param string $version The version to check, defaults to the latest version.
     *
     * @return bool Whether or not the requested migration is at least the requested version.
     */
    public function is_version($name, $version = \WPSEO_VERSION)
    {
    }
    /**
     * Gets the error of a given migration if it exists.
     *
     * @param string $name The name of the migration.
     *
     * @return bool|array False if there is no error, otherwise the error.
     */
    public function get_error($name)
    {
    }
    /**
     * Sets an error for the migration.
     *
     * @param string $name    The name of the migration.
     * @param string $message Message explaining the reason for the error.
     * @param string $version The current version.
     *
     * @return void
     */
    public function set_error($name, $message, $version = \WPSEO_VERSION)
    {
    }
    /**
     * Updates the migration version to the latest version.
     *
     * @param string $name    The name of the migration.
     * @param string $version The current version.
     *
     * @return void
     */
    public function set_success($name, $version = \WPSEO_VERSION)
    {
    }
    /**
     * Locks the migration status.
     *
     * @param string $name The name of the migration.
     *
     * @return bool Whether or not the migration was succesfully locked.
     */
    public function lock_migration($name)
    {
    }
    /**
     * Retrieves the migration option.
     *
     * @param string $name The name of the migration.
     *
     * @return bool|array The status of the migration, false if no status exists.
     */
    protected function get_migration_status($name)
    {
    }
    /**
     * Retrieves the migration option.
     *
     * @param string $name             The name of the migration.
     * @param array  $migration_status The migration status.
     *
     * @return bool True if the status was succesfully updated, false otherwise.
     */
    protected function set_migration_status($name, $migration_status)
    {
    }
  }
  /**
   * Class Schema_IDs.
   */
  class Schema_IDs
  {
    /**
     * Hash used for the Author `@id`.
     */
    const AUTHOR_HASH = '#author';
    /**
     * Hash used for the Author Logo's `@id`.
     */
    const AUTHOR_LOGO_HASH = '#authorlogo';
    /**
     * Hash used for the Breadcrumb's `@id`.
     */
    const BREADCRUMB_HASH = '#breadcrumb';
    /**
     * Hash used for the Person `@id`.
     */
    const PERSON_HASH = '#/schema/person/';
    /**
     * Hash used for the Article `@id`.
     */
    const ARTICLE_HASH = '#article';
    /**
     * Hash used for the Organization `@id`.
     */
    const ORGANIZATION_HASH = '#organization';
    /**
     * Hash used for the Organization `@id`.
     */
    const ORGANIZATION_LOGO_HASH = '#/schema/logo/image/';
    /**
     * Hash used for the logo `@id`.
     */
    const PERSON_LOGO_HASH = '#/schema/person/image/';
    /**
     * Hash used for an Article's primary image `@id`.
     */
    const PRIMARY_IMAGE_HASH = '#primaryimage';
    /**
     * Hash used for the WebPage's `@id`.
     *
     * @deprecated 19.3
     */
    const WEBPAGE_HASH = '';
    /**
     * Hash used for the Website's `@id`.
     */
    const WEBSITE_HASH = '#website';
  }
  /**
   * Class Schema_Types.
   */
  class Schema_Types
  {
    /**
     * Holds the possible schema page types.
     *
     * Capitalized in this way so the value can be directly used in the schema output.
     *
     * @var string[]
     */
    const PAGE_TYPES = ['WebPage' => '', 'ItemPage' => '', 'AboutPage' => '', 'FAQPage' => '', 'QAPage' => '', 'ProfilePage' => '', 'ContactPage' => '', 'MedicalWebPage' => '', 'CollectionPage' => '', 'CheckoutPage' => '', 'RealEstateListing' => '', 'SearchResultsPage' => ''];
    /**
     * Holds the possible schema article types.
     *
     * Capitalized in this way so the value can be directly used in the schema output.
     *
     * @var string[]
     */
    const ARTICLE_TYPES = ['Article' => '', 'BlogPosting' => '', 'SocialMediaPosting' => '', 'NewsArticle' => '', 'AdvertiserContentArticle' => '', 'SatiricalArticle' => '', 'ScholarlyArticle' => '', 'TechArticle' => '', 'Report' => '', 'None' => ''];
    /**
     * Gets the page type options.
     *
     * @return array[] The schema page type options.
     */
    public function get_page_type_options()
    {
    }
    /**
     * Gets the article type options.
     *
     * @return array[] The schema article type options.
     */
    public function get_article_type_options()
    {
    }
    /**
     * Gets the values of the article type options.
     *
     * @deprecated 19.12
     * @codeCoverageIgnore
     *
     * @return array[] The values of the Schema article type options.
     */
    public function get_article_type_options_values()
    {
    }
  }
}

namespace YoastSEO_Vendor\League\OAuth2\Client\Tool {
  /**
   * Provides generic array navigation tools.
   */
  trait ArrayAccessorTrait
  {
    /**
     * Returns a value by key using dot notation.
     *
     * @param  array      $data
     * @param  string     $key
     * @param  mixed|null $default
     * @return mixed
     */
    private function getValueByKey(array $data, $key, $default = null)
    {
    }
  }
  /**
   * Provides support for blacklisting explicit properties from the
   * mass assignment behavior.
   */
  trait GuardedPropertyTrait
  {
    /**
     * The properties that aren't mass assignable.
     *
     * @var array
     */
    protected $guarded = [];
    /**
     * Attempts to mass assign the given options to explicitly defined properties,
     * skipping over any properties that are defined in the guarded array.
     *
     * @param array $options
     * @return mixed
     */
    protected function fillProperties(array $options = [])
    {
    }
    /**
     * Returns current guarded properties.
     *
     * @return array
     */
    public function getGuarded()
    {
    }
    /**
     * Determines if the given property is guarded.
     *
     * @param  string  $property
     * @return bool
     */
    public function isGuarded($property)
    {
    }
  }
  /**
   * Provides a standard way to generate query strings.
   */
  trait QueryBuilderTrait
  {
    /**
     * Build a query string from an array.
     *
     * @param array $params
     *
     * @return string
     */
    protected function buildQueryString(array $params)
    {
    }
  }
}

namespace YoastSEO_Vendor\League\OAuth2\Client\Provider {
  /**
   * Represents a service provider (authorization server).
   *
   * @link http://tools.ietf.org/html/rfc6749#section-1.1 Roles (RFC 6749, §1.1)
   */
  abstract class AbstractProvider
  {
    use \YoastSEO_Vendor\League\OAuth2\Client\Tool\ArrayAccessorTrait;
    use \YoastSEO_Vendor\League\OAuth2\Client\Tool\GuardedPropertyTrait;
    use \YoastSEO_Vendor\League\OAuth2\Client\Tool\QueryBuilderTrait;
    /**
     * @var string Key used in a token response to identify the resource owner.
     */
    const ACCESS_TOKEN_RESOURCE_OWNER_ID = null;
    /**
     * @var string HTTP method used to fetch access tokens.
     */
    const METHOD_GET = 'GET';
    /**
     * @var string HTTP method used to fetch access tokens.
     */
    const METHOD_POST = 'POST';
    /**
     * @var string
     */
    protected $clientId;
    /**
     * @var string
     */
    protected $clientSecret;
    /**
     * @var string
     */
    protected $redirectUri;
    /**
     * @var string
     */
    protected $state;
    /**
     * @var GrantFactory
     */
    protected $grantFactory;
    /**
     * @var RequestFactory
     */
    protected $requestFactory;
    /**
     * @var HttpClientInterface
     */
    protected $httpClient;
    /**
     * @var OptionProviderInterface
     */
    protected $optionProvider;
    /**
     * Constructs an OAuth 2.0 service provider.
     *
     * @param array $options An array of options to set on this provider.
     *     Options include `clientId`, `clientSecret`, `redirectUri`, and `state`.
     *     Individual providers may introduce more options, as needed.
     * @param array $collaborators An array of collaborators that may be used to
     *     override this provider's default behavior. Collaborators include
     *     `grantFactory`, `requestFactory`, and `httpClient`.
     *     Individual providers may introduce more collaborators, as needed.
     */
    public function __construct(array $options = [], array $collaborators = [])
    {
    }
    /**
     * Returns the list of options that can be passed to the HttpClient
     *
     * @param array $options An array of options to set on this provider.
     *     Options include `clientId`, `clientSecret`, `redirectUri`, and `state`.
     *     Individual providers may introduce more options, as needed.
     * @return array The options to pass to the HttpClient constructor
     */
    protected function getAllowedClientOptions(array $options)
    {
    }
    /**
     * Sets the grant factory instance.
     *
     * @param  GrantFactory $factory
     * @return self
     */
    public function setGrantFactory(\YoastSEO_Vendor\League\OAuth2\Client\Grant\GrantFactory $factory)
    {
    }
    /**
     * Returns the current grant factory instance.
     *
     * @return GrantFactory
     */
    public function getGrantFactory()
    {
    }
    /**
     * Sets the request factory instance.
     *
     * @param  RequestFactory $factory
     * @return self
     */
    public function setRequestFactory(\YoastSEO_Vendor\League\OAuth2\Client\Tool\RequestFactory $factory)
    {
    }
    /**
     * Returns the request factory instance.
     *
     * @return RequestFactory
     */
    public function getRequestFactory()
    {
    }
    /**
     * Sets the HTTP client instance.
     *
     * @param  HttpClientInterface $client
     * @return self
     */
    public function setHttpClient(\YoastSEO_Vendor\GuzzleHttp\ClientInterface $client)
    {
    }
    /**
     * Returns the HTTP client instance.
     *
     * @return HttpClientInterface
     */
    public function getHttpClient()
    {
    }
    /**
     * Sets the option provider instance.
     *
     * @param  OptionProviderInterface $provider
     * @return self
     */
    public function setOptionProvider(\YoastSEO_Vendor\League\OAuth2\Client\OptionProvider\OptionProviderInterface $provider)
    {
    }
    /**
     * Returns the option provider instance.
     *
     * @return OptionProviderInterface
     */
    public function getOptionProvider()
    {
    }
    /**
     * Returns the current value of the state parameter.
     *
     * This can be accessed by the redirect handler during authorization.
     *
     * @return string
     */
    public function getState()
    {
    }
    /**
     * Returns the base URL for authorizing a client.
     *
     * Eg. https://oauth.service.com/authorize
     *
     * @return string
     */
    public abstract function getBaseAuthorizationUrl();
    /**
     * Returns the base URL for requesting an access token.
     *
     * Eg. https://oauth.service.com/token
     *
     * @param array $params
     * @return string
     */
    public abstract function getBaseAccessTokenUrl(array $params);
    /**
     * Returns the URL for requesting the resource owner's details.
     *
     * @param AccessToken $token
     * @return string
     */
    public abstract function getResourceOwnerDetailsUrl(\YoastSEO_Vendor\League\OAuth2\Client\Token\AccessToken $token);
    /**
     * Returns a new random string to use as the state parameter in an
     * authorization flow.
     *
     * @param  int $length Length of the random string to be generated.
     * @return string
     */
    protected function getRandomState($length = 32)
    {
    }
    /**
     * Returns the default scopes used by this provider.
     *
     * This should only be the scopes that are required to request the details
     * of the resource owner, rather than all the available scopes.
     *
     * @return array
     */
    protected abstract function getDefaultScopes();
    /**
     * Returns the string that should be used to separate scopes when building
     * the URL for requesting an access token.
     *
     * @return string Scope separator, defaults to ','
     */
    protected function getScopeSeparator()
    {
    }
    /**
     * Returns authorization parameters based on provided options.
     *
     * @param  array $options
     * @return array Authorization parameters
     */
    protected function getAuthorizationParameters(array $options)
    {
    }
    /**
     * Builds the authorization URL's query string.
     *
     * @param  array $params Query parameters
     * @return string Query string
     */
    protected function getAuthorizationQuery(array $params)
    {
    }
    /**
     * Builds the authorization URL.
     *
     * @param  array $options
     * @return string Authorization URL
     */
    public function getAuthorizationUrl(array $options = [])
    {
    }
    /**
     * Redirects the client for authorization.
     *
     * @param  array $options
     * @param  callable|null $redirectHandler
     * @return mixed
     */
    public function authorize(array $options = [], callable $redirectHandler = null)
    {
    }
    /**
     * Appends a query string to a URL.
     *
     * @param  string $url The URL to append the query to
     * @param  string $query The HTTP query string
     * @return string The resulting URL
     */
    protected function appendQuery($url, $query)
    {
    }
    /**
     * Returns the method to use when requesting an access token.
     *
     * @return string HTTP method
     */
    protected function getAccessTokenMethod()
    {
    }
    /**
     * Returns the key used in the access token response to identify the resource owner.
     *
     * @return string|null Resource owner identifier key
     */
    protected function getAccessTokenResourceOwnerId()
    {
    }
    /**
     * Builds the access token URL's query string.
     *
     * @param  array $params Query parameters
     * @return string Query string
     */
    protected function getAccessTokenQuery(array $params)
    {
    }
    /**
     * Checks that a provided grant is valid, or attempts to produce one if the
     * provided grant is a string.
     *
     * @param  AbstractGrant|string $grant
     * @return AbstractGrant
     */
    protected function verifyGrant($grant)
    {
    }
    /**
     * Returns the full URL to use when requesting an access token.
     *
     * @param array $params Query parameters
     * @return string
     */
    protected function getAccessTokenUrl(array $params)
    {
    }
    /**
     * Returns a prepared request for requesting an access token.
     *
     * @param array $params Query string parameters
     * @return RequestInterface
     */
    protected function getAccessTokenRequest(array $params)
    {
    }
    /**
     * Requests an access token using a specified grant and option set.
     *
     * @param  mixed $grant
     * @param  array $options
     * @throws IdentityProviderException
     * @return AccessTokenInterface
     */
    public function getAccessToken($grant, array $options = [])
    {
    }
    /**
     * Returns a PSR-7 request instance that is not authenticated.
     *
     * @param  string $method
     * @param  string $url
     * @param  array $options
     * @return RequestInterface
     */
    public function getRequest($method, $url, array $options = [])
    {
    }
    /**
     * Returns an authenticated PSR-7 request instance.
     *
     * @param  string $method
     * @param  string $url
     * @param  AccessTokenInterface|string $token
     * @param  array $options Any of "headers", "body", and "protocolVersion".
     * @return RequestInterface
     */
    public function getAuthenticatedRequest($method, $url, $token, array $options = [])
    {
    }
    /**
     * Creates a PSR-7 request instance.
     *
     * @param  string $method
     * @param  string $url
     * @param  AccessTokenInterface|string|null $token
     * @param  array $options
     * @return RequestInterface
     */
    protected function createRequest($method, $url, $token, array $options)
    {
    }
    /**
     * Sends a request instance and returns a response instance.
     *
     * WARNING: This method does not attempt to catch exceptions caused by HTTP
     * errors! It is recommended to wrap this method in a try/catch block.
     *
     * @param  RequestInterface $request
     * @return ResponseInterface
     */
    public function getResponse(\YoastSEO_Vendor\Psr\Http\Message\RequestInterface $request)
    {
    }
    /**
     * Sends a request and returns the parsed response.
     *
     * @param  RequestInterface $request
     * @throws IdentityProviderException
     * @return mixed
     */
    public function getParsedResponse(\YoastSEO_Vendor\Psr\Http\Message\RequestInterface $request)
    {
    }
    /**
     * Attempts to parse a JSON response.
     *
     * @param  string $content JSON content from response body
     * @return array Parsed JSON data
     * @throws UnexpectedValueException if the content could not be parsed
     */
    protected function parseJson($content)
    {
    }
    /**
     * Returns the content type header of a response.
     *
     * @param  ResponseInterface $response
     * @return string Semi-colon separated join of content-type headers.
     */
    protected function getContentType(\YoastSEO_Vendor\Psr\Http\Message\ResponseInterface $response)
    {
    }
    /**
     * Parses the response according to its content-type header.
     *
     * @throws UnexpectedValueException
     * @param  ResponseInterface $response
     * @return array
     */
    protected function parseResponse(\YoastSEO_Vendor\Psr\Http\Message\ResponseInterface $response)
    {
    }
    /**
     * Checks a provider response for errors.
     *
     * @throws IdentityProviderException
     * @param  ResponseInterface $response
     * @param  array|string $data Parsed response data
     * @return void
     */
    protected abstract function checkResponse(\YoastSEO_Vendor\Psr\Http\Message\ResponseInterface $response, $data);
    /**
     * Prepares an parsed access token response for a grant.
     *
     * Custom mapping of expiration, etc should be done here. Always call the
     * parent method when overloading this method.
     *
     * @param  mixed $result
     * @return array
     */
    protected function prepareAccessTokenResponse(array $result)
    {
    }
    /**
     * Creates an access token from a response.
     *
     * The grant that was used to fetch the response can be used to provide
     * additional context.
     *
     * @param  array $response
     * @param  AbstractGrant $grant
     * @return AccessTokenInterface
     */
    protected function createAccessToken(array $response, \YoastSEO_Vendor\League\OAuth2\Client\Grant\AbstractGrant $grant)
    {
    }
    /**
     * Generates a resource owner object from a successful resource owner
     * details request.
     *
     * @param  array $response
     * @param  AccessToken $token
     * @return ResourceOwnerInterface
     */
    protected abstract function createResourceOwner(array $response, \YoastSEO_Vendor\League\OAuth2\Client\Token\AccessToken $token);
    /**
     * Requests and returns the resource owner of given access token.
     *
     * @param  AccessToken $token
     * @return ResourceOwnerInterface
     */
    public function getResourceOwner(\YoastSEO_Vendor\League\OAuth2\Client\Token\AccessToken $token)
    {
    }
    /**
     * Requests resource owner details.
     *
     * @param  AccessToken $token
     * @return mixed
     */
    protected function fetchResourceOwnerDetails(\YoastSEO_Vendor\League\OAuth2\Client\Token\AccessToken $token)
    {
    }
    /**
     * Returns the default headers used by this provider.
     *
     * Typically this is used to set 'Accept' or 'Content-Type' headers.
     *
     * @return array
     */
    protected function getDefaultHeaders()
    {
    }
    /**
     * Returns the authorization headers used by this provider.
     *
     * Typically this is "Bearer" or "MAC". For more information see:
     * http://tools.ietf.org/html/rfc6749#section-7.1
     *
     * No default is provided, providers must overload this method to activate
     * authorization headers.
     *
     * @param  mixed|null $token Either a string or an access token instance
     * @return array
     */
    protected function getAuthorizationHeaders($token = null)
    {
    }
    /**
     * Returns all headers used by this provider for a request.
     *
     * The request will be authenticated if an access token is provided.
     *
     * @param  mixed|null $token object or string
     * @return array
     */
    public function getHeaders($token = null)
    {
    }
  }
}

namespace YoastSEO_Vendor\League\OAuth2\Client\Tool {
  /**
   * Enables `Bearer` header authorization for providers.
   *
   * @link http://tools.ietf.org/html/rfc6750 Bearer Token Usage (RFC 6750)
   */
  trait BearerAuthorizationTrait
  {
    /**
     * Returns authorization headers for the 'bearer' grant.
     *
     * @param  AccessTokenInterface|string|null $token Either a string or an access token instance
     * @return array
     */
    protected function getAuthorizationHeaders($token = null)
    {
    }
  }
}

namespace YoastSEO_Vendor\League\OAuth2\Client\Provider {
  /**
   * Represents a generic service provider that may be used to interact with any
   * OAuth 2.0 service provider, using Bearer token authentication.
   */
  class GenericProvider extends \YoastSEO_Vendor\League\OAuth2\Client\Provider\AbstractProvider
  {
    use \YoastSEO_Vendor\League\OAuth2\Client\Tool\BearerAuthorizationTrait;
    /**
     * @var string
     */
    private $urlAuthorize;
    /**
     * @var string
     */
    private $urlAccessToken;
    /**
     * @var string
     */
    private $urlResourceOwnerDetails;
    /**
     * @var string
     */
    private $accessTokenMethod;
    /**
     * @var string
     */
    private $accessTokenResourceOwnerId;
    /**
     * @var array|null
     */
    private $scopes = null;
    /**
     * @var string
     */
    private $scopeSeparator;
    /**
     * @var string
     */
    private $responseError = 'error';
    /**
     * @var string
     */
    private $responseCode;
    /**
     * @var string
     */
    private $responseResourceOwnerId = 'id';
    /**
     * @param array $options
     * @param array $collaborators
     */
    public function __construct(array $options = [], array $collaborators = [])
    {
    }
    /**
     * Returns all options that can be configured.
     *
     * @return array
     */
    protected function getConfigurableOptions()
    {
    }
    /**
     * Returns all options that are required.
     *
     * @return array
     */
    protected function getRequiredOptions()
    {
    }
    /**
     * Verifies that all required options have been passed.
     *
     * @param  array $options
     * @return void
     * @throws InvalidArgumentException
     */
    private function assertRequiredOptions(array $options)
    {
    }
    /**
     * @inheritdoc
     */
    public function getBaseAuthorizationUrl()
    {
    }
    /**
     * @inheritdoc
     */
    public function getBaseAccessTokenUrl(array $params)
    {
    }
    /**
     * @inheritdoc
     */
    public function getResourceOwnerDetailsUrl(\YoastSEO_Vendor\League\OAuth2\Client\Token\AccessToken $token)
    {
    }
    /**
     * @inheritdoc
     */
    public function getDefaultScopes()
    {
    }
    /**
     * @inheritdoc
     */
    protected function getAccessTokenMethod()
    {
    }
    /**
     * @inheritdoc
     */
    protected function getAccessTokenResourceOwnerId()
    {
    }
    /**
     * @inheritdoc
     */
    protected function getScopeSeparator()
    {
    }
    /**
     * @inheritdoc
     */
    protected function checkResponse(\YoastSEO_Vendor\Psr\Http\Message\ResponseInterface $response, $data)
    {
    }
    /**
     * @inheritdoc
     */
    protected function createResourceOwner(array $response, \YoastSEO_Vendor\League\OAuth2\Client\Token\AccessToken $token)
    {
    }
  }
}

namespace Yoast\WP\SEO\Config {
  /**
   * Class Wincher_PKCE_Provider
   *
   * @codeCoverageIgnore Ignoring as this class is purely a temporary wrapper until https://github.com/thephpleague/oauth2-client/pull/901 is merged.
   *
   * @phpcs:disable WordPress.NamingConventions.ValidVariableName.PropertyNotSnakeCase -- This class extends an external class.
   * @phpcs:disable WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase -- This class extends an external class.
   */
  class Wincher_PKCE_Provider extends \YoastSEO_Vendor\League\OAuth2\Client\Provider\GenericProvider
  {
    use \YoastSEO_Vendor\League\OAuth2\Client\Tool\BearerAuthorizationTrait;
    /**
     * The method to use.
     *
     * @var string
     */
    protected $pkceMethod = null;
    /**
     * The PKCE code.
     *
     * @var string
     */
    protected $pkceCode;
    /**
     * Set the value of the pkceCode parameter.
     *
     * When using PKCE this should be set before requesting an access token.
     *
     * @param string $pkce_code The value for the pkceCode.
     * @return self
     */
    public function setPkceCode($pkce_code)
    {
    }
    /**
     * Returns the current value of the pkceCode parameter.
     *
     * This can be accessed by the redirect handler during authorization.
     *
     * @return string
     */
    public function getPkceCode()
    {
    }
    /**
     * Returns a new random string to use as PKCE code_verifier and
     * hashed as code_challenge parameters in an authorization flow.
     * Must be between 43 and 128 characters long.
     *
     * @param int $length Length of the random string to be generated.
     *
     * @return string
     *
     * @throws \Exception Throws exception if an invalid value is passed to random_bytes.
     */
    protected function getRandomPkceCode($length = 64)
    {
    }
    /**
     * Returns the current value of the pkceMethod parameter.
     *
     * @return string|null
     */
    protected function getPkceMethod()
    {
    }
    /**
     * Returns authorization parameters based on provided options.
     *
     * @param array $options The options to use in the authorization parameters.
     *
     * @return array The authorization parameters
     *
     * @throws InvalidArgumentException Throws exception if an invalid PCKE method is passed in the options.
     * @throws \Exception               When something goes wrong with generating the PKCE code.
     */
    protected function getAuthorizationParameters(array $options)
    {
    }
    /**
     * Requests an access token using a specified grant and option set.
     *
     * @param mixed $grant   The grant to request access for.
     * @param array $options The options to use with the current request.
     *
     * @return AccessToken|AccessTokenInterface The access token.
     *
     * @throws UnexpectedValueException Exception thrown if the provider response contains errors.
     */
    public function getAccessToken($grant, array $options = [])
    {
    }
    /**
     * Returns all options that can be configured.
     *
     * @return array The configurable options.
     */
    protected function getConfigurableOptions()
    {
    }
    /**
     * Parses the request response.
     *
     * @param RequestInterface $request The request interface.
     *
     * @return array The parsed response.
     *
     * @throws IdentityProviderException Exception thrown if there is no proper identity provider.
     */
    public function getParsedResponse(\YoastSEO_Vendor\Psr\Http\Message\RequestInterface $request)
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Config {
  interface AppConfigInterface
  {
    /**
     * Your partner name.
     *
     * @default wordproof
     * @return string
     */
    public function getPartner();
    /**
     * The WordProof environment used. Either staging or production.
     *
     * @default production
     * @return string
     */
    public function getEnvironment();
    /**
     * The WordProof environment used. Either staging or production.
     *
     * @default true
     * @return boolean
     */
    public function getLoadUikitFromCdn();
    /**
     * Only used for local development.
     *
     * @return integer
     */
    public function getOauthClient();
    /**
     * Only used for local development.
     *
     * @return string
     */
    public function getWordProofUrl();
    /**
     * Only used for local development.
     *
     * @return string
     */
    public function getScriptsFileOverwrite();
  }
  class DefaultAppConfig implements \YoastSEO_Vendor\WordProof\SDK\Config\AppConfigInterface
  {
    /**
     * @return string
     */
    public function getPartner()
    {
    }
    /**
     * @return string
     */
    public function getEnvironment()
    {
    }
    /**
     * @return boolean
     */
    public function getLoadUikitFromCdn()
    {
    }
    /**
     * @return null
     */
    public function getOauthClient()
    {
    }
    /**
     * @return null
     */
    public function getWordProofUrl()
    {
    }
    /**
     * @return null
     */
    public function getScriptsFileOverwrite()
    {
    }
  }
}

namespace Yoast\WP\SEO\Config {
  /**
   * Class WordProof_App_Config.
   *
   * @package Yoast\WP\SEO\Config
   */
  class Wordproof_App_Config extends \YoastSEO_Vendor\WordProof\SDK\Config\DefaultAppConfig
  {
    /**
     * Returns the partner.
     *
     * @return string The partner.
     */
    public function getPartner()
    {
    }
    /**
     * Returns if the WordProof Uikit should be loaded from a cdn.
     *
     * @return bool True or false.
     */
    public function getLoadUikitFromCdn()
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Translations {
  interface TranslationsInterface
  {
    public function getNoBalanceNotice();
    public function getTimestampSuccessNotice();
    public function getTimestampFailedNotice();
    public function getWebhookFailedNotice();
    public function getNotAuthenticatedNotice();
    public function getOpenSettingsButtonText();
    public function getOpenAuthenticationButtonText();
    public function getContactWordProofSupportButtonText();
  }
}

namespace Yoast\WP\SEO\Config {
  /**
   * Class WordProof_Translations
   *
   * @package Yoast\WP\SEO\Config
   */
  class Wordproof_Translations implements \YoastSEO_Vendor\WordProof\SDK\Translations\TranslationsInterface
  {
    /**
     * Returns no balance notice translation.
     *
     * @return string The translation.
     */
    public function getNoBalanceNotice()
    {
    }
    /**
     * Returns no balance notice translation.
     *
     * @return string The translation.
     */
    public function getTimestampSuccessNotice()
    {
    }
    /**
     * Returns timestamp failed notice translation.
     *
     * @return string The translation.
     */
    public function getTimestampFailedNotice()
    {
    }
    /**
     * Returns webhook failed notice translation.
     *
     * @return string The translation.
     */
    public function getWebhookFailedNotice()
    {
    }
    /**
     * Returns no authentication notice translation.
     *
     * @return string The translation.
     */
    public function getNotAuthenticatedNotice()
    {
    }
    /**
     * Returns authenticate button text.
     *
     * @return string The translation.
     */
    public function getOpenAuthenticationButtonText()
    {
    }
    /**
     * Returns open settings button translation.
     *
     * @return string The translation.
     */
    public function getOpenSettingsButtonText()
    {
    }
    /**
     * Returns get contact WordProof Support button translation.
     *
     * @return string The translation.
     */
    public function getContactWordProofSupportButtonText()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presentations {
  /**
   * The abstract presentation class.
   */
  #[\AllowDynamicProperties]
  class Abstract_Presentation
  {
    /**
     * The model.
     *
     * @var mixed
     */
    public $model;
    /**
     * Whether or not there is a presentation prototype.
     *
     * @var bool
     */
    private $is_prototype = true;
    /**
     * Creates a model presentation.
     *
     * @param array $data The data that this is a presentation of.
     *
     * @return static A model presentation.
     *
     * @throws Exception If attempting to create a model presentation from another model presentation.
     */
    public function of($data)
    {
    }
    /**
     * Magic getter for lazy loading of generate functions.
     *
     * @param string $name The property to get.
     *
     * @return mixed The value if it could be generated.
     *
     * @throws Exception If there is no generator for the property.
     */
    public function __get($name)
    {
    }
    /**
     * Magic isset for ensuring methods that have a generator are recognised.
     *
     * @codeCoverageIgnore Wrapper method.
     *
     * @param string $name The property to get.
     *
     * @return bool Whether or not there is a generator for the requested property.
     */
    public function __isset($name)
    {
    }
    /**
     * Returns `true` if this class is a prototype.
     *
     * @codeCoverageIgnore Wrapper method.
     *
     * @return bool If this class is a prototype or not.
     */
    protected function is_prototype()
    {
    }
  }
}

namespace Yoast\WP\SEO\Context {
  /**
   * Class Meta_Tags_Context.
   *
   * Class that contains all relevant data for rendering the meta tags.
   *
   * @property string          $canonical
   * @property string          $permalink
   * @property string          $title
   * @property string          $description
   * @property string          $id
   * @property string          $site_name
   * @property string          $alternate_site_name
   * @property string          $wordpress_site_name
   * @property string          $site_url
   * @property string          $company_name
   * @property string          $company_alternate_name
   * @property int             $company_logo_id
   * @property array           $company_logo_meta
   * @property int             $person_logo_id
   * @property array           $person_logo_meta
   * @property int             $site_user_id
   * @property string          $site_represents
   * @property array|false     $site_represents_reference
   * @property string          $schema_page_type
   * @property string|string[] $schema_article_type      Represents the type of article.
   * @property string          $main_schema_id
   * @property string|array    $main_entity_of_page
   * @property bool            $open_graph_enabled
   * @property string          $open_graph_publisher
   * @property string          $twitter_card
   * @property string          $page_type
   * @property bool            $has_article
   * @property bool            $has_image
   * @property int             $main_image_id
   * @property string          $main_image_url
   */
  class Meta_Tags_Context extends \Yoast\WP\SEO\Presentations\Abstract_Presentation
  {
    /**
     * The indexable.
     *
     * @var Indexable
     */
    public $indexable;
    /**
     * The WP Block Parser Block.
     *
     * @var WP_Block_Parser_Block[]
     */
    public $blocks;
    /**
     * The WP Post.
     *
     * @var WP_Post
     */
    public $post;
    /**
     * The indexable presentation.
     *
     * @var Indexable_Presentation
     */
    public $presentation;
    /**
     * Determines whether we have an Article piece. Set to true by the Article piece itself.
     *
     * @var bool
     */
    public $has_article = false;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    private $url;
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    private $image;
    /**
     * The ID helper.
     *
     * @var ID_Helper
     */
    private $id_helper;
    /**
     * The WPSEO Replace Vars object.
     *
     * @var WPSEO_Replace_Vars
     */
    private $replace_vars;
    /**
     * The site helper.
     *
     * @var Site_Helper
     */
    private $site;
    /**
     * The user helper.
     *
     * @var User_Helper
     */
    private $user;
    /**
     * The permalink helper.
     *
     * @var Permalink_Helper
     */
    private $permalink_helper;
    /**
     * The indexable helper.
     *
     * @var Indexable_Helper
     */
    private $indexable_helper;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    private $indexable_repository;
    /**
     * Meta_Tags_Context constructor.
     *
     * @param Options_Helper       $options              The options helper.
     * @param Url_Helper           $url                  The url helper.
     * @param Image_Helper         $image                The image helper.
     * @param ID_Helper            $id_helper            The schema id helper.
     * @param WPSEO_Replace_Vars   $replace_vars         The replace vars helper.
     * @param Site_Helper          $site                 The site helper.
     * @param User_Helper          $user                 The user helper.
     * @param Permalink_Helper     $permalink_helper     The permalink helper.
     * @param Indexable_Helper     $indexable_helper     The indexable helper.
     * @param Indexable_Repository $indexable_repository The indexable repository.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Url_Helper $url, \Yoast\WP\SEO\Helpers\Image_Helper $image, \Yoast\WP\SEO\Helpers\Schema\ID_Helper $id_helper, \WPSEO_Replace_Vars $replace_vars, \Yoast\WP\SEO\Helpers\Site_Helper $site, \Yoast\WP\SEO\Helpers\User_Helper $user, \Yoast\WP\SEO\Helpers\Permalink_Helper $permalink_helper, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable_helper, \Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Generates the title.
     *
     * @return string the title
     */
    public function generate_title()
    {
    }
    /**
     * Generates the description.
     *
     * @return string the description
     */
    public function generate_description()
    {
    }
    /**
     * Generates the canonical.
     *
     * @return string the canonical
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the permalink.
     *
     * @return string
     */
    public function generate_permalink()
    {
    }
    /**
     * Generates the id.
     *
     * @return string the id
     */
    public function generate_id()
    {
    }
    /**
     * Generates the site name.
     *
     * @return string The site name.
     */
    public function generate_site_name()
    {
    }
    /**
     * Generates the alternate site name.
     *
     * @return string The alternate site name.
     */
    public function generate_alternate_site_name()
    {
    }
    /**
     * Generates the site name from the WordPress options.
     *
     * @return string The site name from the WordPress options.
     */
    public function generate_wordpress_site_name()
    {
    }
    /**
     * Generates the site url.
     *
     * @return string The site url.
     */
    public function generate_site_url()
    {
    }
    /**
     * Generates the company name.
     *
     * @return string The company name.
     */
    public function generate_company_name()
    {
    }
    /**
     * Generates the alternate company name.
     *
     * @return string
     */
    public function generate_company_alternate_name()
    {
    }
    /**
     * Generates the person logo id.
     *
     * @return int|bool The company logo id.
     */
    public function generate_person_logo_id()
    {
    }
    /**
     * Retrieve the person logo meta.
     *
     * @return array|bool
     */
    public function generate_person_logo_meta()
    {
    }
    /**
     * Generates the company logo id.
     *
     * @return int|bool The company logo id.
     */
    public function generate_company_logo_id()
    {
    }
    /**
     * Retrieve the company logo meta.
     *
     * @return array|bool
     */
    public function generate_company_logo_meta()
    {
    }
    /**
     * Generates the site user id.
     *
     * @return int The site user id.
     */
    public function generate_site_user_id()
    {
    }
    /**
     * Determines what our site represents, and grabs their values.
     *
     * @return string|false Person or company. False if invalid value.
     */
    public function generate_site_represents()
    {
    }
    /**
     * Returns the site represents reference.
     *
     * @return array|bool The site represents reference. False if none.
     */
    public function generate_site_represents_reference()
    {
    }
    /**
     * Returns whether or not open graph is enabled.
     *
     * @return bool Whether or not open graph is enabled.
     */
    public function generate_open_graph_enabled()
    {
    }
    /**
     * Returns the open graph publisher.
     *
     * @return string The open graph publisher.
     */
    public function generate_open_graph_publisher()
    {
    }
    /**
     * Returns the twitter card type.
     *
     * @return string The twitter card type.
     */
    public function generate_twitter_card()
    {
    }
    /**
     * Returns the schema page type.
     *
     * @return string|array The schema page type.
     */
    public function generate_schema_page_type()
    {
    }
    /**
     * Returns the schema article type.
     *
     * @return string|array The schema article type.
     */
    public function generate_schema_article_type()
    {
    }
    /**
     * Returns the main schema id.
     *
     * The main schema id.
     *
     * @return string
     */
    public function generate_main_schema_id()
    {
    }
    /**
     * Retrieves the main image URL. This is the featured image by default.
     *
     * @return string|null The main image URL.
     */
    public function generate_main_image_url()
    {
    }
    /**
     * Gets the main image ID.
     *
     * @return int|null The main image ID.
     */
    public function generate_main_image_id()
    {
    }
    /**
     * Determines whether the current indexable has an image.
     *
     * @return bool Whether the current indexable has an image.
     */
    public function generate_has_image()
    {
    }
    /**
     * Strips all nested dependencies from the debug info.
     *
     * @return array
     */
    public function __debugInfo()
    {
    }
    /**
     * Retrieve the site logo ID from WordPress settings.
     *
     * @return false|int
     */
    public function fallback_to_site_logo()
    {
    }
    /**
     * Get the ID for a post's featured image.
     *
     * @param int $id Post ID.
     *
     * @return int|null
     */
    private function get_singular_post_image($id)
    {
    }
  }
}

namespace Yoast\WP\SEO\Exceptions\Addon_Installation {
  /**
   * Class Addon_Activation_Error_Exception
   */
  class Addon_Activation_Error_Exception extends \Exception
  {
  }
  /**
   * Class Addon_Already_Installed_Exception
   */
  class Addon_Already_Installed_Exception extends \Exception
  {
  }
  /**
   * Class Addon_Installation_Error
   */
  class Addon_Installation_Error_Exception extends \Exception
  {
  }
  /**
   * Class User_Cannot_Activate_Plugins
   */
  class User_Cannot_Activate_Plugins_Exception extends \Exception
  {
  }
  /**
   * Class User_Cannot_Install_Plugins_Exception
   */
  class User_Cannot_Install_Plugins_Exception extends \Exception
  {
  }
}

namespace Yoast\WP\SEO\Exceptions {
  /**
   * Exception for attempting a mutation on properties that are made readonly through magic getters and setters.
   */
  class Forbidden_Property_Mutation_Exception extends \RuntimeException
  {
    /**
     * Creates a Forbidden_Property_Mutation_Exception exception when an attempt is made
     * to assign a value to an immutable property.
     *
     * @param string $property_name The name of the immutable property.
     *
     * @return Forbidden_Property_Mutation_Exception The exception.
     */
    public static function cannot_set_because_property_is_immutable($property_name)
    {
    }
    /**
     * Creates a Forbidden_Property_Mutation_Exception exception when an attempt is made to unset an immutable property.
     *
     * @param string $property_name The name of the immutable property.
     *
     * @return Forbidden_Property_Mutation_Exception The exception.
     */
    public static function cannot_unset_because_property_is_immutable($property_name)
    {
    }
  }
}

namespace Yoast\WP\SEO\Exceptions\Importing {
  /**
   * Class Aioseo_Validation_Exception
   */
  class Aioseo_Validation_Exception extends \Exception
  {
    /**
     * Exception that is thrown whenever validation of the
     * AIOSEO data structure has failed.
     */
    public function __construct()
    {
    }
  }
}

namespace Yoast\WP\SEO\Exceptions\Indexable {
  /**
   * Class Indexable_Exception
   */
  abstract class Indexable_Exception extends \Exception
  {
  }
  /**
   * Class Not_Built_Exception
   */
  class Not_Built_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Indexable_Exception
  {
    /**
     * Creates an exception that should be thrown when an indexable
     * was not built because of an invalid object id.
     *
     * @param int $object_id The invalid object id.
     *
     * @return Not_Built_Exception The exception.
     */
    public static function invalid_object_id($object_id)
    {
    }
  }
  /**
   * For when an author indexable is not being built.
   */
  class Author_Not_Built_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Not_Built_Exception
  {
    /**
     * Named constructor for creating an Author_Not_Built_Exception
     * when author archives are disabled for users without posts.
     *
     * @param string $user_id The user id.
     *
     * @return Author_Not_Built_Exception The exception.
     */
    public static function author_archives_are_not_indexed_for_users_without_posts($user_id)
    {
    }
    /**
     * Named constructor for creating an Author_Not_Built_Exception
     * when author archives are disabled.
     *
     * @param string $user_id The user id.
     *
     * @return Author_Not_Built_Exception The exception.
     */
    public static function author_archives_are_disabled($user_id)
    {
    }
    /**
     * Named constructor for creating an Author_Not_Build_Exception
     * when an author is excluded because of the `'wpseo_should_build_and_save_user_indexable'` filter.
     *
     * @param string $user_id The user id.
     *
     * @return Author_Not_Built_Exception The exception.
     */
    public static function author_not_built_because_of_filter($user_id)
    {
    }
  }
  /**
   * Class Indexable_Source_Exception
   */
  class Source_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Indexable_Exception
  {
  }
  /**
   * Exception that can be thrown whenever a term is considered invalid by WordPress
   * within the context of the indexables.
   */
  class Invalid_Term_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Source_Exception
  {
    /**
     * Exception that can be thrown whenever a term is considered invalid by WordPress
     * within the context of the indexables.
     *
     * @param string $reason The reason given by WordPress why the term is invalid.
     */
    public function __construct($reason)
    {
    }
  }
  /**
   * Exception that is thrown whenever a post could not be built
   * in the context of the indexables.
   */
  class Post_Not_Built_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Not_Built_Exception
  {
    /**
     * Throws an exception if the post is not indexable.
     *
     * @param int $post_id ID of the post.
     *
     * @throws Post_Not_Built_Exception When the post is not indexable.
     */
    public static function because_not_indexable($post_id)
    {
    }
    /**
     * Throws an exception if the post type is excluded from indexing.
     *
     * @param int $post_id ID of the post.
     *
     * @throws Post_Not_Built_Exception When the post type is excluded.
     */
    public static function because_post_type_excluded($post_id)
    {
    }
  }
  /**
   * Exception that is thrown whenever a post could not be found
   * in the context of the indexables.
   */
  class Post_Not_Found_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Source_Exception
  {
    /**
     * Exception that is thrown whenever a post could not be found
     * in the context of the indexables.
     */
    public function __construct()
    {
    }
  }
  /**
   * Exception that is thrown whenever a term could not be built
   * in the context of the indexables.
   */
  class Term_Not_Built_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Not_Built_Exception
  {
    /**
     * Throws an exception if the term is not indexable.
     *
     * @param int $term_id ID of the term.
     *
     * @throws Term_Not_Built_Exception When the term is not built.
     */
    public static function because_not_indexable($term_id)
    {
    }
  }
  /**
   * Exception that is thrown whenever a term could not be found
   * in the context of the indexables.
   */
  class Term_Not_Found_Exception extends \Yoast\WP\SEO\Exceptions\Indexable\Source_Exception
  {
    /**
     * Exception that is thrown whenever a term could not be found
     * in the context of the indexables.
     */
    public function __construct()
    {
    }
  }
}

namespace Yoast\WP\SEO\Exceptions {
  /**
   * Exception to use when a method does not exist.
   */
  class Missing_Method extends \Exception
  {
    /**
     * Creates exception for a method that does not exist in a class.
     *
     * @param string $method     The method that does not exist.
     * @param string $class_name The class name.
     *
     * @return static Instance of the exception.
     */
    public static function for_class($method, $class_name)
    {
    }
  }
}

namespace Yoast\WP\SEO\Exceptions\OAuth {
  /**
   * Class Authentication_Failed_Exception
   */
  class Authentication_Failed_Exception extends \Exception
  {
    /**
     * Authentication_Failed_Exception constructor.
     *
     * @param Exception $original_exception The original exception.
     */
    public function __construct(\Exception $original_exception)
    {
    }
    /**
     * Returns a formatted response object.
     *
     * @return object The response object.
     */
    public function get_response()
    {
    }
  }
}

namespace Yoast\WP\SEO\Exceptions\OAuth\Tokens {
  /**
   * Class Empty_Property_Exception
   */
  class Empty_Property_Exception extends \Exception
  {
    /**
     * Empty_Property_Exception constructor.
     *
     * @param string $property The property that is empty.
     */
    public function __construct($property)
    {
    }
  }
  /**
   * Class Empty_Token_Exception
   */
  class Empty_Token_Exception extends \Exception
  {
    /**
     * Empty_Token_Exception constructor.
     */
    public function __construct()
    {
    }
  }
  /**
   * Class Failed_Storage_Exception
   */
  class Failed_Storage_Exception extends \Exception
  {
    const DEFAULT_MESSAGE = 'Token storing failed. Please try again.';
    /**
     * Failed_Storage_Exception constructor.
     *
     * @param string $reason The reason why token storage failed. Optional.
     */
    public function __construct($reason = '')
    {
    }
  }
}

namespace YoastSEO_Vendor\Psr\Container {
  /**
   * Describes the interface of a container that exposes methods to read its entries.
   */
  interface ContainerInterface
  {
    /**
     * Finds an entry of the container by its identifier and returns it.
     *
     * @param string $id Identifier of the entry to look for.
     *
     * @throws NotFoundExceptionInterface  No entry was found for **this** identifier.
     * @throws ContainerExceptionInterface Error while retrieving the entry.
     *
     * @return mixed Entry.
     */
    public function get($id);
    /**
     * Returns true if the container can return an entry for the given identifier.
     * Returns false otherwise.
     *
     * `has($id)` returning true does not mean that `get($id)` will not throw an exception.
     * It does however mean that `get($id)` will not throw a `NotFoundExceptionInterface`.
     *
     * @param string $id Identifier of the entry to look for.
     *
     * @return bool
     */
    public function has($id);
  }
}

namespace YoastSEO_Vendor\Symfony\Component\DependencyInjection {
  /**
   * ContainerInterface is the interface implemented by service container classes.
   *
   * @author Fabien Potencier <fabien@symfony.com>
   * @author Johannes M. Schmitt <schmittjoh@gmail.com>
   */
  interface ContainerInterface extends \YoastSEO_Vendor\Psr\Container\ContainerInterface
  {
    const EXCEPTION_ON_INVALID_REFERENCE = 1;
    const NULL_ON_INVALID_REFERENCE = 2;
    const IGNORE_ON_INVALID_REFERENCE = 3;
    const IGNORE_ON_UNINITIALIZED_REFERENCE = 4;
    /**
     * Sets a service.
     *
     * @param string      $id      The service identifier
     * @param object|null $service The service instance
     */
    public function set($id, $service);
    /**
     * Gets a service.
     *
     * @param string $id              The service identifier
     * @param int    $invalidBehavior The behavior when the service does not exist
     *
     * @return object|null The associated service
     *
     * @throws ServiceCircularReferenceException When a circular reference is detected
     * @throws ServiceNotFoundException          When the service is not defined
     *
     * @see Reference
     */
    public function get($id, $invalidBehavior = self::EXCEPTION_ON_INVALID_REFERENCE);
    /**
     * Returns true if the given service is defined.
     *
     * @param string $id The service identifier
     *
     * @return bool true if the service is defined, false otherwise
     */
    public function has($id);
    /**
     * Check for whether or not a service has been initialized.
     *
     * @param string $id
     *
     * @return bool true if the service has been initialized, false otherwise
     */
    public function initialized($id);
    /**
     * Gets a parameter.
     *
     * @param string $name The parameter name
     *
     * @return mixed The parameter value
     *
     * @throws InvalidArgumentException if the parameter is not defined
     */
    public function getParameter($name);
    /**
     * Checks if a parameter exists.
     *
     * @param string $name The parameter name
     *
     * @return bool The presence of parameter in container
     */
    public function hasParameter($name);
    /**
     * Sets a parameter.
     *
     * @param string $name  The parameter name
     * @param mixed  $value The parameter value
     */
    public function setParameter($name, $value);
  }
  /**
   * ResettableContainerInterface defines additional resetting functionality
   * for containers, allowing to release shared services when the container is
   * not needed anymore.
   *
   * @author Christophe Coevoet <stof@notk.org>
   */
  interface ResettableContainerInterface extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface
  {
    /**
     * Resets shared services from the container.
     *
     * The container is not intended to be used again after being reset in a normal workflow. This method is
     * meant as a way to release references for ref-counting.
     * A subsequent call to ContainerInterface::get will recreate a new instance of the shared service.
     */
    public function reset();
  }
  /**
   * Container is a dependency injection container.
   *
   * It gives access to object instances (services).
   * Services and parameters are simple key/pair stores.
   * The container can have four possible behaviors when a service
   * does not exist (or is not initialized for the last case):
   *
   *  * EXCEPTION_ON_INVALID_REFERENCE: Throws an exception (the default)
   *  * NULL_ON_INVALID_REFERENCE:      Returns null
   *  * IGNORE_ON_INVALID_REFERENCE:    Ignores the wrapping command asking for the reference
   *                                    (for instance, ignore a setter if the service does not exist)
   *  * IGNORE_ON_UNINITIALIZED_REFERENCE: Ignores/returns null for uninitialized services or invalid references
   *
   * @author Fabien Potencier <fabien@symfony.com>
   * @author Johannes M. Schmitt <schmittjoh@gmail.com>
   */
  class Container implements \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ResettableContainerInterface
  {
    protected $parameterBag;
    protected $services = [];
    protected $fileMap = [];
    protected $methodMap = [];
    protected $aliases = [];
    protected $loading = [];
    protected $resolving = [];
    protected $syntheticIds = [];
    /**
     * @internal
     */
    protected $privates = [];
    /**
     * @internal
     */
    protected $normalizedIds = [];
    private $underscoreMap = ['_' => '', '.' => '_', '\\' => '_'];
    private $envCache = [];
    private $compiled = \false;
    private $getEnv;
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface $parameterBag = null)
    {
    }
    /**
     * Compiles the container.
     *
     * This method does two things:
     *
     *  * Parameter values are resolved;
     *  * The parameter bag is frozen.
     */
    public function compile()
    {
    }
    /**
     * Returns true if the container is compiled.
     *
     * @return bool
     */
    public function isCompiled()
    {
    }
    /**
     * Returns true if the container parameter bag are frozen.
     *
     * @deprecated since version 3.3, to be removed in 4.0.
     *
     * @return bool true if the container parameter bag are frozen, false otherwise
     */
    public function isFrozen()
    {
    }
    /**
     * Gets the service container parameter bag.
     *
     * @return ParameterBagInterface A ParameterBagInterface instance
     */
    public function getParameterBag()
    {
    }
    /**
     * Gets a parameter.
     *
     * @param string $name The parameter name
     *
     * @return mixed The parameter value
     *
     * @throws InvalidArgumentException if the parameter is not defined
     */
    public function getParameter($name)
    {
    }
    /**
     * Checks if a parameter exists.
     *
     * @param string $name The parameter name
     *
     * @return bool The presence of parameter in container
     */
    public function hasParameter($name)
    {
    }
    /**
     * Sets a parameter.
     *
     * @param string $name  The parameter name
     * @param mixed  $value The parameter value
     */
    public function setParameter($name, $value)
    {
    }
    /**
     * Sets a service.
     *
     * Setting a synthetic service to null resets it: has() returns false and get()
     * behaves in the same way as if the service was never created.
     *
     * @param string      $id      The service identifier
     * @param object|null $service The service instance
     */
    public function set($id, $service)
    {
    }
    /**
     * Returns true if the given service is defined.
     *
     * @param string $id The service identifier
     *
     * @return bool true if the service is defined, false otherwise
     */
    public function has($id)
    {
    }
    /**
     * Gets a service.
     *
     * If a service is defined both through a set() method and
     * with a get{$id}Service() method, the former has always precedence.
     *
     * @param string $id              The service identifier
     * @param int    $invalidBehavior The behavior when the service does not exist
     *
     * @return object|null The associated service
     *
     * @throws ServiceCircularReferenceException When a circular reference is detected
     * @throws ServiceNotFoundException          When the service is not defined
     * @throws \Exception                        if an exception has been thrown when the service has been resolved
     *
     * @see Reference
     */
    public function get($id, $invalidBehavior = 1)
    {
    }
    /**
     * Returns true if the given service has actually been initialized.
     *
     * @param string $id The service identifier
     *
     * @return bool true if service has already been initialized, false otherwise
     */
    public function initialized($id)
    {
    }
    /**
     * {@inheritdoc}
     */
    public function reset()
    {
    }
    /**
     * Gets all service ids.
     *
     * @return string[] An array of all defined service ids
     */
    public function getServiceIds()
    {
    }
    /**
     * Gets service ids that existed at compile time.
     *
     * @return array
     */
    public function getRemovedIds()
    {
    }
    /**
     * Camelizes a string.
     *
     * @param string $id A string to camelize
     *
     * @return string The camelized string
     */
    public static function camelize($id)
    {
    }
    /**
     * A string to underscore.
     *
     * @param string $id The string to underscore
     *
     * @return string The underscored string
     */
    public static function underscore($id)
    {
    }
    /**
     * Creates a service by requiring its factory file.
     */
    protected function load($file)
    {
    }
    /**
     * Fetches a variable from the environment.
     *
     * @param string $name The name of the environment variable
     *
     * @return mixed The value to use for the provided environment variable name
     *
     * @throws EnvNotFoundException When the environment variable is not found and has no default value
     */
    protected function getEnv($name)
    {
    }
    /**
     * Returns the case sensitive id used at registration time.
     *
     * @param string $id
     *
     * @return string
     *
     * @internal
     */
    public function normalizeId($id)
    {
    }
    private function __clone()
    {
    }
  }
}

namespace Yoast\WP\SEO\Generated {
  /**
   * This class has been auto-generated
   * by the Symfony Dependency Injection Component.
   *
   * @final since Symfony 3.3
   */
  class Cached_Container extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Container
  {
    private $parameters = [];
    private $targetDirs = [];
    public function __construct()
    {
    }
    public function getRemovedIds()
    {
    }
    public function compile()
    {
    }
    public function isCompiled()
    {
    }
    public function isFrozen()
    {
    }
    /**
     * Gets the public 'WPSEO_Addon_Manager' shared service.
     *
     * @return \WPSEO_Addon_Manager
     */
    protected function getWPSEOAddonManagerService()
    {
    }
    /**
     * Gets the public 'WPSEO_Admin_Asset_Manager' shared service.
     *
     * @return \WPSEO_Admin_Asset_Manager
     */
    protected function getWPSEOAdminAssetManagerService()
    {
    }
    /**
     * Gets the public 'WPSEO_Breadcrumbs' shared autowired service.
     *
     * @return \WPSEO_Breadcrumbs
     */
    protected function getWPSEOBreadcrumbsService()
    {
    }
    /**
     * Gets the public 'WPSEO_Frontend' shared autowired service.
     *
     * @return \WPSEO_Frontend
     */
    protected function getWPSEOFrontendService()
    {
    }
    /**
     * Gets the public 'WPSEO_Replace_Vars' shared service.
     *
     * @return \WPSEO_Replace_Vars
     */
    protected function getWPSEOReplaceVarsService()
    {
    }
    /**
     * Gets the public 'WPSEO_Shortlinker' shared service.
     *
     * @return \WPSEO_Shortlinker
     */
    protected function getWPSEOShortlinkerService()
    {
    }
    /**
     * Gets the public 'WPSEO_Utils' shared service.
     *
     * @return \WPSEO_Utils
     */
    protected function getWPSEOUtilsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\Lib\Migrations\Adapter' shared autowired service.
     *
     * @return \Yoast\WP\Lib\Migrations\Adapter
     */
    protected function getAdapterService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Addon_Installation\Addon_Activate_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Addon_Installation\Addon_Activate_Action
     */
    protected function getAddonActivateActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Addon_Installation\Addon_Install_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Addon_Installation\Addon_Install_Action
     */
    protected function getAddonInstallActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Alert_Dismissal_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Alert_Dismissal_Action
     */
    protected function getAlertDismissalActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Configuration\First_Time_Configuration_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Configuration\First_Time_Configuration_Action
     */
    protected function getFirstTimeConfigurationActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Cleanup_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Cleanup_Action
     */
    protected function getAioseoCleanupActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Custom_Archive_Settings_Importing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Custom_Archive_Settings_Importing_Action
     */
    protected function getAioseoCustomArchiveSettingsImportingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Default_Archive_Settings_Importing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Default_Archive_Settings_Importing_Action
     */
    protected function getAioseoDefaultArchiveSettingsImportingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_General_Settings_Importing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_General_Settings_Importing_Action
     */
    protected function getAioseoGeneralSettingsImportingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Posts_Importing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Posts_Importing_Action
     */
    protected function getAioseoPostsImportingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Posttype_Defaults_Settings_Importing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Posttype_Defaults_Settings_Importing_Action
     */
    protected function getAioseoPosttypeDefaultsSettingsImportingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Taxonomy_Settings_Importing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Taxonomy_Settings_Importing_Action
     */
    protected function getAioseoTaxonomySettingsImportingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Validate_Data_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Aioseo\Aioseo_Validate_Data_Action
     */
    protected function getAioseoValidateDataActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Importing\Deactivate_Conflicting_Plugins_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Importing\Deactivate_Conflicting_Plugins_Action
     */
    protected function getDeactivateConflictingPluginsActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexables\Indexable_Head_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexables\Indexable_Head_Action
     */
    protected function getIndexableHeadActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexables_Page_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexables_Page_Action
     *
     * @deprecated Yoast\WP\SEO\Actions\Indexables_Page_Action is deprecated since version 20.4!
     */
    protected function getIndexablesPageActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Indexable_General_Indexation_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Indexable_General_Indexation_Action
     */
    protected function getIndexableGeneralIndexationActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Indexable_Indexing_Complete_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Indexable_Indexing_Complete_Action
     */
    protected function getIndexableIndexingCompleteActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Indexation_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Indexation_Action
     */
    protected function getIndexablePostIndexationActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Type_Archive_Indexation_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Type_Archive_Indexation_Action
     */
    protected function getIndexablePostTypeArchiveIndexationActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Indexable_Term_Indexation_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Indexable_Term_Indexation_Action
     */
    protected function getIndexableTermIndexationActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Indexing_Complete_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Indexing_Complete_Action
     */
    protected function getIndexingCompleteActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Indexing_Prepare_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Indexing_Prepare_Action
     */
    protected function getIndexingPrepareActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Post_Link_Indexing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Post_Link_Indexing_Action
     */
    protected function getPostLinkIndexingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Indexing\Term_Link_Indexing_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Indexing\Term_Link_Indexing_Action
     */
    protected function getTermLinkIndexingActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Integrations_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Integrations_Action
     */
    protected function getIntegrationsActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\SEMrush\SEMrush_Login_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\SEMrush\SEMrush_Login_Action
     */
    protected function getSEMrushLoginActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\SEMrush\SEMrush_Options_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\SEMrush\SEMrush_Options_Action
     */
    protected function getSEMrushOptionsActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\SEMrush\SEMrush_Phrases_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\SEMrush\SEMrush_Phrases_Action
     */
    protected function getSEMrushPhrasesActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Settings_Introduction_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Settings_Introduction_Action
     */
    protected function getSettingsIntroductionActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Wincher\Wincher_Account_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Wincher\Wincher_Account_Action
     */
    protected function getWincherAccountActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Wincher\Wincher_Keyphrases_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Wincher\Wincher_Keyphrases_Action
     */
    protected function getWincherKeyphrasesActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Actions\Wincher\Wincher_Login_Action' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Actions\Wincher\Wincher_Login_Action
     */
    protected function getWincherLoginActionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Author_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Author_Builder
     */
    protected function getIndexableAuthorBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Builder
     */
    protected function getIndexableBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Date_Archive_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Date_Archive_Builder
     */
    protected function getIndexableDateArchiveBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Hierarchy_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Hierarchy_Builder
     */
    protected function getIndexableHierarchyBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Home_Page_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Home_Page_Builder
     */
    protected function getIndexableHomePageBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Link_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Link_Builder
     */
    protected function getIndexableLinkBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Post_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Post_Builder
     */
    protected function getIndexablePostBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Post_Type_Archive_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Post_Type_Archive_Builder
     */
    protected function getIndexablePostTypeArchiveBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_System_Page_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_System_Page_Builder
     */
    protected function getIndexableSystemPageBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Indexable_Term_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Indexable_Term_Builder
     */
    protected function getIndexableTermBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Builders\Primary_Term_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Builders\Primary_Term_Builder
     */
    protected function getPrimaryTermBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Commands\Cleanup_Command' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Commands\Cleanup_Command
     */
    protected function getCleanupCommandService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Commands\Index_Command' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Commands\Index_Command
     */
    protected function getIndexCommandService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Addon_Installation_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Addon_Installation_Conditional
     */
    protected function getAddonInstallationConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Admin\Doing_Post_Quick_Edit_Save_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Admin\Doing_Post_Quick_Edit_Save_Conditional
     */
    protected function getDoingPostQuickEditSaveConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Admin\Estimated_Reading_Time_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Admin\Estimated_Reading_Time_Conditional
     */
    protected function getEstimatedReadingTimeConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Admin\Licenses_Page_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Admin\Licenses_Page_Conditional
     */
    protected function getLicensesPageConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Admin\Non_Network_Admin_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Admin\Non_Network_Admin_Conditional
     */
    protected function getNonNetworkAdminConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Admin\Post_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Admin\Post_Conditional
     */
    protected function getPostConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Admin\Posts_Overview_Or_Ajax_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Admin\Posts_Overview_Or_Ajax_Conditional
     */
    protected function getPostsOverviewOrAjaxConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Admin_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Admin_Conditional
     */
    protected function getAdminConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Attachment_Redirections_Enabled_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Attachment_Redirections_Enabled_Conditional
     */
    protected function getAttachmentRedirectionsEnabledConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Development_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Development_Conditional
     */
    protected function getDevelopmentConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Front_End_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Front_End_Conditional
     */
    protected function getFrontEndConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Front_End_Inspector_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Front_End_Inspector_Conditional
     *
     * @deprecated Yoast\WP\SEO\Conditionals\Front_End_Inspector_Conditional is deprecated since version 19.5!
     */
    protected function getFrontEndInspectorConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Get_Request_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Get_Request_Conditional
     */
    protected function getGetRequestConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Headless_Rest_Endpoints_Enabled_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Headless_Rest_Endpoints_Enabled_Conditional
     */
    protected function getHeadlessRestEndpointsEnabledConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Import_Tool_Selected_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Import_Tool_Selected_Conditional
     */
    protected function getImportToolSelectedConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Indexables_Page_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Indexables_Page_Conditional
     *
     * @deprecated Yoast\WP\SEO\Conditionals\Indexables_Page_Conditional is deprecated since version 20.4!
     */
    protected function getIndexablesPageConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Jetpack_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Jetpack_Conditional
     */
    protected function getJetpackConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Migrations_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Migrations_Conditional
     */
    protected function getMigrationsConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\New_Settings_Ui_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\New_Settings_Ui_Conditional
     */
    protected function getNewSettingsUiConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\News_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\News_Conditional
     */
    protected function getNewsConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\No_Tool_Selected_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\No_Tool_Selected_Conditional
     */
    protected function getNoToolSelectedConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Non_Multisite_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Non_Multisite_Conditional
     */
    protected function getNonMultisiteConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Not_Admin_Ajax_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Not_Admin_Ajax_Conditional
     */
    protected function getNotAdminAjaxConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Open_Graph_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Open_Graph_Conditional
     */
    protected function getOpenGraphConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Premium_Active_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Premium_Active_Conditional
     */
    protected function getPremiumActiveConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Premium_Inactive_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Premium_Inactive_Conditional
     */
    protected function getPremiumInactiveConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Primary_Category_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Primary_Category_Conditional
     */
    protected function getPrimaryCategoryConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Robots_Txt_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Robots_Txt_Conditional
     */
    protected function getRobotsTxtConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\SEMrush_Enabled_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\SEMrush_Enabled_Conditional
     */
    protected function getSEMrushEnabledConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Schema_Blocks_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Schema_Blocks_Conditional
     *
     * @deprecated Yoast\WP\SEO\Conditionals\Schema_Blocks_Conditional is deprecated since version 20.5!
     */
    protected function getSchemaBlocksConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Settings_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Settings_Conditional
     */
    protected function getSettingsConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Should_Index_Links_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Should_Index_Links_Conditional
     */
    protected function getShouldIndexLinksConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Text_Formality_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Text_Formality_Conditional
     */
    protected function getTextFormalityConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\The_Events_Calendar_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\The_Events_Calendar_Conditional
     *
     * @deprecated Yoast\WP\SEO\Conditionals\The_Events_Calendar_Conditional is deprecated since version 19.12!
     */
    protected function getTheEventsCalendarConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\CoAuthors_Plus_Activated_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\CoAuthors_Plus_Activated_Conditional
     *
     * @deprecated Yoast\WP\SEO\Conditionals\Third_Party\CoAuthors_Plus_Activated_Conditional is deprecated since version 19.12!
     */
    protected function getCoAuthorsPlusActivatedConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\CoAuthors_Plus_Flag_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\CoAuthors_Plus_Flag_Conditional
     *
     * @deprecated Yoast\WP\SEO\Conditionals\Third_Party\CoAuthors_Plus_Flag_Conditional is deprecated since version 19.12!
     */
    protected function getCoAuthorsPlusFlagConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\Elementor_Activated_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\Elementor_Activated_Conditional
     */
    protected function getElementorActivatedConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\Elementor_Edit_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\Elementor_Edit_Conditional
     */
    protected function getElementorEditConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\Jetpack_Boost_Active_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\Jetpack_Boost_Active_Conditional
     */
    protected function getJetpackBoostActiveConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\Jetpack_Boost_Not_Premium_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\Jetpack_Boost_Not_Premium_Conditional
     */
    protected function getJetpackBoostNotPremiumConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\Polylang_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\Polylang_Conditional
     */
    protected function getPolylangConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\TranslatePress_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\TranslatePress_Conditional
     */
    protected function getTranslatePressConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\W3_Total_Cache_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\W3_Total_Cache_Conditional
     */
    protected function getW3TotalCacheConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\WPML_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\WPML_Conditional
     */
    protected function getWPMLConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\WPML_WPSEO_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\WPML_WPSEO_Conditional
     */
    protected function getWPMLWPSEOConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\Wordproof_Integration_Active_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\Wordproof_Integration_Active_Conditional
     */
    protected function getWordproofIntegrationActiveConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Third_Party\Wordproof_Plugin_Inactive_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Third_Party\Wordproof_Plugin_Inactive_Conditional
     */
    protected function getWordproofPluginInactiveConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Updated_Importer_Framework_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Updated_Importer_Framework_Conditional
     */
    protected function getUpdatedImporterFrameworkConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\User_Can_Manage_Wpseo_Options_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\User_Can_Manage_Wpseo_Options_Conditional
     */
    protected function getUserCanManageWpseoOptionsConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\User_Can_Publish_Posts_And_Pages_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\User_Can_Publish_Posts_And_Pages_Conditional
     */
    protected function getUserCanPublishPostsAndPagesConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\WP_Robots_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\WP_Robots_Conditional
     */
    protected function getWPRobotsConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Web_Stories_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Web_Stories_Conditional
     */
    protected function getWebStoriesConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Wincher_Automatically_Track_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Wincher_Automatically_Track_Conditional
     */
    protected function getWincherAutomaticallyTrackConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Wincher_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Wincher_Conditional
     */
    protected function getWincherConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Wincher_Enabled_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Wincher_Enabled_Conditional
     */
    protected function getWincherEnabledConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Wincher_Token_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Wincher_Token_Conditional
     */
    protected function getWincherTokenConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\WooCommerce_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\WooCommerce_Conditional
     */
    protected function getWooCommerceConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\XMLRPC_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\XMLRPC_Conditional
     */
    protected function getXMLRPCConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Yoast_Admin_And_Dashboard_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Yoast_Admin_And_Dashboard_Conditional
     */
    protected function getYoastAdminAndDashboardConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Conditionals\Yoast_Tools_Page_Conditional' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Conditionals\Yoast_Tools_Page_Conditional
     */
    protected function getYoastToolsPageConditionalService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Badge_Group_Names' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Badge_Group_Names
     */
    protected function getBadgeGroupNamesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Conflicting_Plugins' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Conflicting_Plugins
     */
    protected function getConflictingPluginsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Indexing_Reasons' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Indexing_Reasons
     */
    protected function getIndexingReasonsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migration_Status' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migration_Status
     */
    protected function getMigrationStatusService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddCollationToTables' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddCollationToTables
     */
    protected function getAddCollationToTablesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddColumnsToIndexables' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddColumnsToIndexables
     */
    protected function getAddColumnsToIndexablesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddEstimatedReadingTime' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddEstimatedReadingTime
     */
    protected function getAddEstimatedReadingTimeService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddHasAncestorsColumn' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddHasAncestorsColumn
     */
    protected function getAddHasAncestorsColumnService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddIndexableObjectIdAndTypeIndex' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddIndexableObjectIdAndTypeIndex
     */
    protected function getAddIndexableObjectIdAndTypeIndexService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddIndexesForProminentWordsOnIndexables' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddIndexesForProminentWordsOnIndexables
     */
    protected function getAddIndexesForProminentWordsOnIndexablesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddObjectTimestamps' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddObjectTimestamps
     */
    protected function getAddObjectTimestampsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\AddVersionColumnToIndexables' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\AddVersionColumnToIndexables
     */
    protected function getAddVersionColumnToIndexablesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\BreadcrumbTitleAndHierarchyReset' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\BreadcrumbTitleAndHierarchyReset
     */
    protected function getBreadcrumbTitleAndHierarchyResetService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\ClearIndexableTables' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\ClearIndexableTables
     */
    protected function getClearIndexableTablesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\CreateIndexableSubpagesIndex' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\CreateIndexableSubpagesIndex
     */
    protected function getCreateIndexableSubpagesIndexService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\CreateSEOLinksTable' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\CreateSEOLinksTable
     */
    protected function getCreateSEOLinksTableService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\DeleteDuplicateIndexables' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\DeleteDuplicateIndexables
     */
    protected function getDeleteDuplicateIndexablesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\ExpandIndexableColumnLengths' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\ExpandIndexableColumnLengths
     */
    protected function getExpandIndexableColumnLengthsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\ExpandIndexableIDColumnLengths' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\ExpandIndexableIDColumnLengths
     */
    protected function getExpandIndexableIDColumnLengthsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\ExpandPrimaryTermIDColumnLengths' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\ExpandPrimaryTermIDColumnLengths
     */
    protected function getExpandPrimaryTermIDColumnLengthsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\ReplacePermalinkHashIndex' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\ReplacePermalinkHashIndex
     */
    protected function getReplacePermalinkHashIndexService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\ResetIndexableHierarchyTable' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\ResetIndexableHierarchyTable
     */
    protected function getResetIndexableHierarchyTableService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\TruncateIndexableTables' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\TruncateIndexableTables
     */
    protected function getTruncateIndexableTablesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\WpYoastDropIndexableMetaTableIfExists' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\WpYoastDropIndexableMetaTableIfExists
     */
    protected function getWpYoastDropIndexableMetaTableIfExistsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\WpYoastIndexable' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\WpYoastIndexable
     */
    protected function getWpYoastIndexableService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\WpYoastIndexableHierarchy' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\WpYoastIndexableHierarchy
     */
    protected function getWpYoastIndexableHierarchyService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Migrations\WpYoastPrimaryTerm' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Migrations\WpYoastPrimaryTerm
     */
    protected function getWpYoastPrimaryTermService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Researcher_Languages' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Researcher_Languages
     */
    protected function getResearcherLanguagesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\SEMrush_Client' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\SEMrush_Client
     */
    protected function getSEMrushClientService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Schema_IDs' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Schema_IDs
     */
    protected function getSchemaIDsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Schema_Types' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Schema_Types
     */
    protected function getSchemaTypesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Wincher_Client' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Wincher_Client
     */
    protected function getWincherClientService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Wordproof_App_Config' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Wordproof_App_Config
     */
    protected function getWordproofAppConfigService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Config\Wordproof_Translations' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Config\Wordproof_Translations
     */
    protected function getWordproofTranslationsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Context\Meta_Tags_Context' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Context\Meta_Tags_Context
     */
    protected function getMetaTagsContextService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Breadcrumbs_Generator' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Breadcrumbs_Generator
     */
    protected function getBreadcrumbsGeneratorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Open_Graph_Image_Generator' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Open_Graph_Image_Generator
     */
    protected function getOpenGraphImageGeneratorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Open_Graph_Locale_Generator' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Open_Graph_Locale_Generator
     */
    protected function getOpenGraphLocaleGeneratorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Article' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Article
     */
    protected function getArticleService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Author' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Author
     */
    protected function getAuthorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Breadcrumb' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Breadcrumb
     */
    protected function getBreadcrumbService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\FAQ' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\FAQ
     */
    protected function getFAQService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\HowTo' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\HowTo
     */
    protected function getHowToService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Main_Image' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Main_Image
     */
    protected function getMainImageService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Organization' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Organization
     */
    protected function getOrganizationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Person' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Person
     */
    protected function getPersonService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Third_Party\CoAuthor' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Third_Party\CoAuthor
     *
     * @deprecated Yoast\WP\SEO\Generators\Schema\Third_Party\CoAuthor is deprecated since version 19.12!
     */
    protected function getCoAuthorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Third_Party\Events_Calendar_Schema' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Third_Party\Events_Calendar_Schema
     *
     * @deprecated Yoast\WP\SEO\Generators\Schema\Third_Party\Events_Calendar_Schema is deprecated since version 19.12!
     */
    protected function getEventsCalendarSchemaService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\WebPage' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\WebPage
     */
    protected function getWebPageService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema\Website' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema\Website
     */
    protected function getWebsiteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Schema_Generator' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Schema_Generator
     */
    protected function getSchemaGeneratorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Generators\Twitter_Image_Generator' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Generators\Twitter_Image_Generator
     */
    protected function getTwitterImageGeneratorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Aioseo_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Aioseo_Helper
     */
    protected function getAioseoHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Asset_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Asset_Helper
     */
    protected function getAssetHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Attachment_Cleanup_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Attachment_Cleanup_Helper
     */
    protected function getAttachmentCleanupHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Author_Archive_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Author_Archive_Helper
     */
    protected function getAuthorArchiveHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Blocks_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Blocks_Helper
     */
    protected function getBlocksHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Capability_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Capability_Helper
     */
    protected function getCapabilityHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Crawl_Cleanup_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Crawl_Cleanup_Helper
     */
    protected function getCrawlCleanupHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Curl_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Curl_Helper
     */
    protected function getCurlHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Current_Page_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Current_Page_Helper
     */
    protected function getCurrentPageHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Date_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Date_Helper
     */
    protected function getDateHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Environment_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Environment_Helper
     */
    protected function getEnvironmentHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\First_Time_Configuration_Notice_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\First_Time_Configuration_Notice_Helper
     */
    protected function getFirstTimeConfigurationNoticeHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Home_Url_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Home_Url_Helper
     */
    protected function getHomeUrlHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Image_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Image_Helper
     */
    protected function getImageHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Import_Cursor_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Import_Cursor_Helper
     */
    protected function getImportCursorHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Import_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Import_Helper
     */
    protected function getImportHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Indexable_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Indexable_Helper
     */
    protected function getIndexableHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Indexable_To_Postmeta_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Indexable_To_Postmeta_Helper
     */
    protected function getIndexableToPostmetaHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Indexables_Page_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Indexables_Page_Helper
     *
     * @deprecated Yoast\WP\SEO\Helpers\Indexables_Page_Helper is deprecated since version 20.4!
     */
    protected function getIndexablesPageHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Indexing_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Indexing_Helper
     */
    protected function getIndexingHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Language_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Language_Helper
     */
    protected function getLanguageHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Meta_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Meta_Helper
     */
    protected function getMetaHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Notification_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Notification_Helper
     */
    protected function getNotificationHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Open_Graph\Image_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Open_Graph\Image_Helper
     */
    protected function getImageHelper2Service()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Open_Graph\Values_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Open_Graph\Values_Helper
     */
    protected function getValuesHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Options_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Options_Helper
     */
    protected function getOptionsHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Pagination_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Pagination_Helper
     */
    protected function getPaginationHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Permalink_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Permalink_Helper
     */
    protected function getPermalinkHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Post_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Post_Helper
     */
    protected function getPostHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Post_Type_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Post_Type_Helper
     */
    protected function getPostTypeHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Primary_Term_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Primary_Term_Helper
     */
    protected function getPrimaryTermHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Product_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Product_Helper
     */
    protected function getProductHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Redirect_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Redirect_Helper
     */
    protected function getRedirectHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Request_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Request_Helper
     */
    protected function getRequestHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Require_File_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Require_File_Helper
     */
    protected function getRequireFileHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Robots_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Robots_Helper
     */
    protected function getRobotsHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Robots_Txt_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Robots_Txt_Helper
     */
    protected function getRobotsTxtHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Sanitization_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Sanitization_Helper
     */
    protected function getSanitizationHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Schema\Article_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Schema\Article_Helper
     */
    protected function getArticleHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Schema\HTML_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Schema\HTML_Helper
     */
    protected function getHTMLHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Schema\ID_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Schema\ID_Helper
     */
    protected function getIDHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Schema\Image_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Schema\Image_Helper
     */
    protected function getImageHelper3Service()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Schema\Language_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Schema\Language_Helper
     */
    protected function getLanguageHelper2Service()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Schema\Replace_Vars_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Schema\Replace_Vars_Helper
     */
    protected function getReplaceVarsHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Score_Icon_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Score_Icon_Helper
     */
    protected function getScoreIconHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Short_Link_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Short_Link_Helper
     */
    protected function getShortLinkHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Site_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Site_Helper
     */
    protected function getSiteHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Social_Profiles_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Social_Profiles_Helper
     */
    protected function getSocialProfilesHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\String_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\String_Helper
     */
    protected function getStringHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Taxonomy_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Taxonomy_Helper
     */
    protected function getTaxonomyHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Twitter\Image_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Twitter\Image_Helper
     */
    protected function getImageHelper4Service()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Url_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Url_Helper
     */
    protected function getUrlHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\User_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\User_Helper
     */
    protected function getUserHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Wincher_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Wincher_Helper
     */
    protected function getWincherHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Woocommerce_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Woocommerce_Helper
     */
    protected function getWoocommerceHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Wordpress_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Wordpress_Helper
     */
    protected function getWordpressHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Wordproof_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Wordproof_Helper
     */
    protected function getWordproofHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Helpers\Wpdb_Helper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Helpers\Wpdb_Helper
     */
    protected function getWpdbHelperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Initializers\Crawl_Cleanup_Permalinks' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Initializers\Crawl_Cleanup_Permalinks
     */
    protected function getCrawlCleanupPermalinksService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Initializers\Disable_Core_Sitemaps' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Initializers\Disable_Core_Sitemaps
     */
    protected function getDisableCoreSitemapsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Initializers\Migration_Runner' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Initializers\Migration_Runner
     */
    protected function getMigrationRunnerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Initializers\Woocommerce' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Initializers\Woocommerce
     */
    protected function getWoocommerceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Activation_Cleanup_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Activation_Cleanup_Integration
     */
    protected function getActivationCleanupIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Addon_Installation\Dialog_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Addon_Installation\Dialog_Integration
     */
    protected function getDialogIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Addon_Installation\Installation_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Addon_Installation\Installation_Integration
     */
    protected function getInstallationIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Admin_Columns_Cache_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Admin_Columns_Cache_Integration
     */
    protected function getAdminColumnsCacheIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Background_Indexing_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Background_Indexing_Integration
     */
    protected function getBackgroundIndexingIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Crawl_Settings_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Crawl_Settings_Integration
     */
    protected function getCrawlSettingsIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Cron_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Cron_Integration
     */
    protected function getCronIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Deactivated_Premium_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Deactivated_Premium_Integration
     */
    protected function getDeactivatedPremiumIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Disable_Concatenate_Scripts_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Disable_Concatenate_Scripts_Integration
     */
    protected function getDisableConcatenateScriptsIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\First_Time_Configuration_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\First_Time_Configuration_Integration
     */
    protected function getFirstTimeConfigurationIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\First_Time_Configuration_Notice_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\First_Time_Configuration_Notice_Integration
     */
    protected function getFirstTimeConfigurationNoticeIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Fix_News_Dependencies_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Fix_News_Dependencies_Integration
     */
    protected function getFixNewsDependenciesIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Health_Check_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Health_Check_Integration
     */
    protected function getHealthCheckIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\HelpScout_Beacon' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\HelpScout_Beacon
     */
    protected function getHelpScoutBeaconService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Import_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Import_Integration
     */
    protected function getImportIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Indexables_Exclude_Taxonomy_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Indexables_Exclude_Taxonomy_Integration
     */
    protected function getIndexablesExcludeTaxonomyIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Indexables_Page_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Indexables_Page_Integration
     *
     * @deprecated Yoast\WP\SEO\Integrations\Admin\Indexables_Page_Integration is deprecated since version 20.4!
     */
    protected function getIndexablesPageIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Indexing_Notification_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Indexing_Notification_Integration
     */
    protected function getIndexingNotificationIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Indexing_Tool_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Indexing_Tool_Integration
     */
    protected function getIndexingToolIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Installation_Success_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Installation_Success_Integration
     */
    protected function getInstallationSuccessIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Integrations_Page' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Integrations_Page
     */
    protected function getIntegrationsPageService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Link_Count_Columns_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Link_Count_Columns_Integration
     */
    protected function getLinkCountColumnsIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Menu_Badge_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Menu_Badge_Integration
     */
    protected function getMenuBadgeIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Migration_Error_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Migration_Error_Integration
     */
    protected function getMigrationErrorIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Old_Configuration_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Old_Configuration_Integration
     */
    protected function getOldConfigurationIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Old_Premium_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Old_Premium_Integration
     */
    protected function getOldPremiumIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Redirect_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Redirect_Integration
     */
    protected function getRedirectIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Redirects_Page_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Redirects_Page_Integration
     */
    protected function getRedirectsPageIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Social_Templates_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Social_Templates_Integration
     *
     * @deprecated Yoast\WP\SEO\Integrations\Admin\Social_Templates_Integration is deprecated since version 20.3!
     */
    protected function getSocialTemplatesIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Admin\Workouts_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Admin\Workouts_Integration
     */
    protected function getWorkoutsIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Alerts\Jetpack_Boost_Pre_Publish' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Alerts\Jetpack_Boost_Pre_Publish
     */
    protected function getJetpackBoostPrePublishService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Alerts\Webinar_Promo_Notification' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Alerts\Webinar_Promo_Notification
     */
    protected function getWebinarPromoNotificationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Blocks\Breadcrumbs_Block' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Blocks\Breadcrumbs_Block
     */
    protected function getBreadcrumbsBlockService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Blocks\Internal_Linking_Category' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Blocks\Internal_Linking_Category
     */
    protected function getInternalLinkingCategoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Blocks\Structured_Data_Blocks' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Blocks\Structured_Data_Blocks
     */
    protected function getStructuredDataBlocksService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Breadcrumbs_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Breadcrumbs_Integration
     */
    protected function getBreadcrumbsIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Cleanup_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Cleanup_Integration
     */
    protected function getCleanupIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Duplicate_Post_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Duplicate_Post_Integration
     */
    protected function getDuplicatePostIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Estimated_Reading_Time' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Estimated_Reading_Time
     */
    protected function getEstimatedReadingTimeService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Exclude_Attachment_Post_Type' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Exclude_Attachment_Post_Type
     */
    protected function getExcludeAttachmentPostTypeService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Exclude_Oembed_Cache_Post_Type' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Exclude_Oembed_Cache_Post_Type
     */
    protected function getExcludeOembedCachePostTypeService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Feature_Flag_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Feature_Flag_Integration
     */
    protected function getFeatureFlagIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Backwards_Compatibility' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Backwards_Compatibility
     */
    protected function getBackwardsCompatibilityService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Category_Term_Description' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Category_Term_Description
     */
    protected function getCategoryTermDescriptionService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Comment_Link_Fixer' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Comment_Link_Fixer
     */
    protected function getCommentLinkFixerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Crawl_Cleanup_Basic' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Crawl_Cleanup_Basic
     */
    protected function getCrawlCleanupBasicService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Crawl_Cleanup_Rss' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Crawl_Cleanup_Rss
     */
    protected function getCrawlCleanupRssService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Crawl_Cleanup_Searches' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Crawl_Cleanup_Searches
     */
    protected function getCrawlCleanupSearchesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Feed_Improvements' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Feed_Improvements
     */
    protected function getFeedImprovementsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Force_Rewrite_Title' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Force_Rewrite_Title
     */
    protected function getForceRewriteTitleService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Handle_404' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Handle_404
     */
    protected function getHandle404Service()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Indexing_Controls' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Indexing_Controls
     */
    protected function getIndexingControlsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Open_Graph_OEmbed' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Open_Graph_OEmbed
     */
    protected function getOpenGraphOEmbedService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\RSS_Footer_Embed' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\RSS_Footer_Embed
     */
    protected function getRSSFooterEmbedService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Redirects' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Redirects
     */
    protected function getRedirectsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Robots_Txt_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Robots_Txt_Integration
     */
    protected function getRobotsTxtIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\Schema_Accessibility_Feature' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\Schema_Accessibility_Feature
     */
    protected function getSchemaAccessibilityFeatureService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End\WP_Robots_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End\WP_Robots_Integration
     */
    protected function getWPRobotsIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Front_End_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Front_End_Integration
     */
    protected function getFrontEndIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Primary_Category' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Primary_Category
     */
    protected function getPrimaryCategoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Schema_Blocks' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Schema_Blocks
     *
     * @deprecated Yoast\WP\SEO\Integrations\Schema_Blocks is deprecated since version 20.5!
     */
    protected function getSchemaBlocksService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Settings_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Settings_Integration
     */
    protected function getSettingsIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\AMP' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\AMP
     */
    protected function getAMPService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\BbPress' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\BbPress
     */
    protected function getBbPressService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\CoAuthors_Plus' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\CoAuthors_Plus
     *
     * @deprecated Yoast\WP\SEO\Integrations\Third_Party\CoAuthors_Plus is deprecated since version 19.12!
     */
    protected function getCoAuthorsPlusService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Elementor' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Elementor
     */
    protected function getElementorService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Exclude_Elementor_Post_Types' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Exclude_Elementor_Post_Types
     */
    protected function getExcludeElementorPostTypesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Exclude_WooCommerce_Post_Types' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Exclude_WooCommerce_Post_Types
     */
    protected function getExcludeWooCommercePostTypesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Jetpack' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Jetpack
     */
    protected function getJetpackService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\The_Events_Calendar' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\The_Events_Calendar
     *
     * @deprecated Yoast\WP\SEO\Integrations\Third_Party\The_Events_Calendar is deprecated since version 19.12!
     */
    protected function getTheEventsCalendarService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\W3_Total_Cache' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\W3_Total_Cache
     */
    protected function getW3TotalCacheService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\WPML' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\WPML
     */
    protected function getWPMLService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\WPML_WPSEO_Notification' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\WPML_WPSEO_Notification
     */
    protected function getWPMLWPSEONotificationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Web_Stories' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Web_Stories
     */
    protected function getWebStoriesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Web_Stories_Post_Edit' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Web_Stories_Post_Edit
     */
    protected function getWebStoriesPostEditService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Wincher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Wincher
     */
    protected function getWincherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Wincher_Publish' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Wincher_Publish
     */
    protected function getWincherPublishService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\WooCommerce' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\WooCommerce
     */
    protected function getWooCommerce2Service()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\WooCommerce_Post_Edit' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\WooCommerce_Post_Edit
     */
    protected function getWooCommercePostEditService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Woocommerce_Permalinks' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Woocommerce_Permalinks
     */
    protected function getWoocommercePermalinksService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Wordproof' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Wordproof
     */
    protected function getWordproofService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Third_Party\Wordproof_Integration_Toggle' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Third_Party\Wordproof_Integration_Toggle
     */
    protected function getWordproofIntegrationToggleService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Uninstall_Integration' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Uninstall_Integration
     */
    protected function getUninstallIntegrationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Addon_Update_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Addon_Update_Watcher
     */
    protected function getAddonUpdateWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Auto_Update_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Auto_Update_Watcher
     */
    protected function getAutoUpdateWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Ancestor_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Ancestor_Watcher
     */
    protected function getIndexableAncestorWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Attachment_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Attachment_Watcher
     */
    protected function getIndexableAttachmentWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Author_Archive_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Author_Archive_Watcher
     */
    protected function getIndexableAuthorArchiveWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Author_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Author_Watcher
     */
    protected function getIndexableAuthorWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Category_Permalink_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Category_Permalink_Watcher
     */
    protected function getIndexableCategoryPermalinkWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Date_Archive_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Date_Archive_Watcher
     */
    protected function getIndexableDateArchiveWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_HomeUrl_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_HomeUrl_Watcher
     */
    protected function getIndexableHomeUrlWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Home_Page_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Home_Page_Watcher
     */
    protected function getIndexableHomePageWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Permalink_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Permalink_Watcher
     */
    protected function getIndexablePermalinkWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Meta_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Meta_Watcher
     */
    protected function getIndexablePostMetaWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Type_Archive_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Type_Archive_Watcher
     */
    protected function getIndexablePostTypeArchiveWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Type_Change_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Type_Change_Watcher
     */
    protected function getIndexablePostTypeChangeWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Watcher
     */
    protected function getIndexablePostWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Static_Home_Page_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Static_Home_Page_Watcher
     */
    protected function getIndexableStaticHomePageWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_System_Page_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_System_Page_Watcher
     */
    protected function getIndexableSystemPageWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Taxonomy_Change_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Taxonomy_Change_Watcher
     */
    protected function getIndexableTaxonomyChangeWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Indexable_Term_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Indexable_Term_Watcher
     */
    protected function getIndexableTermWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Option_Titles_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Option_Titles_Watcher
     */
    protected function getOptionTitlesWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Option_Wpseo_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Option_Wpseo_Watcher
     */
    protected function getOptionWpseoWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Primary_Category_Quick_Edit_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Primary_Category_Quick_Edit_Watcher
     */
    protected function getPrimaryCategoryQuickEditWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Primary_Term_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Primary_Term_Watcher
     */
    protected function getPrimaryTermWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\Watchers\Search_Engines_Discouraged_Watcher' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\Watchers\Search_Engines_Discouraged_Watcher
     */
    protected function getSearchEnginesDiscouragedWatcherService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Integrations\XMLRPC' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Integrations\XMLRPC
     */
    protected function getXMLRPCService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Loader' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Loader
     */
    protected function getLoaderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Loggers\Logger' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Loggers\Logger
     */
    protected function getLoggerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer
     */
    protected function getMetaTagsContextMemoizerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Memoizers\Presentation_Memoizer' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Memoizers\Presentation_Memoizer
     */
    protected function getPresentationMemoizerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Abstract_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Abstract_Presentation
     */
    protected function getAbstractPresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Author_Archive_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Author_Archive_Presentation
     */
    protected function getIndexableAuthorArchivePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Date_Archive_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Date_Archive_Presentation
     */
    protected function getIndexableDateArchivePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Error_Page_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Error_Page_Presentation
     */
    protected function getIndexableErrorPagePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Home_Page_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Home_Page_Presentation
     */
    protected function getIndexableHomePagePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Post_Type_Archive_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Post_Type_Archive_Presentation
     */
    protected function getIndexablePostTypeArchivePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Post_Type_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Post_Type_Presentation
     */
    protected function getIndexablePostTypePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Presentation
     */
    protected function getIndexablePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Search_Result_Page_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Search_Result_Page_Presentation
     */
    protected function getIndexableSearchResultPagePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Static_Home_Page_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Static_Home_Page_Presentation
     */
    protected function getIndexableStaticHomePagePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Static_Posts_Page_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Static_Posts_Page_Presentation
     */
    protected function getIndexableStaticPostsPagePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Presentations\Indexable_Term_Archive_Presentation' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Presentations\Indexable_Term_Archive_Presentation
     */
    protected function getIndexableTermArchivePresentationService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Repositories\Indexable_Hierarchy_Repository' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Repositories\Indexable_Hierarchy_Repository
     */
    protected function getIndexableHierarchyRepositoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Repositories\Indexable_Repository' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Repositories\Indexable_Repository
     */
    protected function getIndexableRepositoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Repositories\Primary_Term_Repository' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Repositories\Primary_Term_Repository
     */
    protected function getPrimaryTermRepositoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Repositories\SEO_Links_Repository' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Repositories\SEO_Links_Repository
     */
    protected function getSEOLinksRepositoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Alert_Dismissal_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Alert_Dismissal_Route
     */
    protected function getAlertDismissalRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\First_Time_Configuration_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\First_Time_Configuration_Route
     */
    protected function getFirstTimeConfigurationRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Importing_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Importing_Route
     */
    protected function getImportingRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Indexables_Head_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Indexables_Head_Route
     */
    protected function getIndexablesHeadRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Indexables_Page_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Indexables_Page_Route
     *
     * @deprecated Yoast\WP\SEO\Routes\Indexables_Page_Route is deprecated since version 20.4!
     */
    protected function getIndexablesPageRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Indexing_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Indexing_Route
     */
    protected function getIndexingRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Integrations_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Integrations_Route
     */
    protected function getIntegrationsRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Meta_Search_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Meta_Search_Route
     */
    protected function getMetaSearchRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\SEMrush_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\SEMrush_Route
     */
    protected function getSEMrushRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Settings_Introduction_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Settings_Introduction_Route
     */
    protected function getSettingsIntroductionRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Supported_Features_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Supported_Features_Route
     */
    protected function getSupportedFeaturesRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Wincher_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Wincher_Route
     */
    protected function getWincherRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Workouts_Route' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Workouts_Route
     */
    protected function getWorkoutsRouteService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Routes\Yoast_Head_REST_Field' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Routes\Yoast_Head_REST_Field
     */
    protected function getYoastHeadRESTFieldService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Schema_Templates\Assets\Icons' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Schema_Templates\Assets\Icons
     *
     * @deprecated Yoast\WP\SEO\Schema_Templates\Assets\Icons is deprecated since version 20.5!
     */
    protected function getIconsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Check' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Check
     */
    protected function getDefaultTaglineCheckService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Reports' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Reports
     */
    protected function getDefaultTaglineReportsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Runner' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Runner
     */
    protected function getDefaultTaglineRunnerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Links_Table_Check' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Links_Table_Check
     */
    protected function getLinksTableCheckService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Links_Table_Reports' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Links_Table_Reports
     */
    protected function getLinksTableReportsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Links_Table_Runner' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Links_Table_Runner
     */
    protected function getLinksTableRunnerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\MyYoast_Api_Request_Factory' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\MyYoast_Api_Request_Factory
     */
    protected function getMyYoastApiRequestFactoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Page_Comments_Check' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Page_Comments_Check
     */
    protected function getPageCommentsCheckService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Page_Comments_Reports' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Page_Comments_Reports
     */
    protected function getPageCommentsReportsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Page_Comments_Runner' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Page_Comments_Runner
     */
    protected function getPageCommentsRunnerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Check' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Check
     */
    protected function getPostnamePermalinkCheckService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Reports' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Reports
     */
    protected function getPostnamePermalinkReportsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Runner' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Runner
     */
    protected function getPostnamePermalinkRunnerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Report_Builder' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Report_Builder
     */
    protected function getReportBuilderService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Health_Check\Report_Builder_Factory' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Health_Check\Report_Builder_Factory
     */
    protected function getReportBuilderFactoryService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Replacevar_Service' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Replacevar_Service
     */
    protected function getAioseoReplacevarServiceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service
     */
    protected function getAioseoRobotsProviderServiceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Transformer_Service' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Transformer_Service
     */
    protected function getAioseoRobotsTransformerServiceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Social_Images_Provider_Service' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Social_Images_Provider_Service
     */
    protected function getAioseoSocialImagesProviderServiceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Importing\Conflicting_Plugins_Service' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Importing\Conflicting_Plugins_Service
     */
    protected function getConflictingPluginsServiceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Importing\Importable_Detector_Service' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Importing\Importable_Detector_Service
     */
    protected function getImportableDetectorServiceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Services\Indexables\Indexable_Version_Manager' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Services\Indexables\Indexable_Version_Manager
     */
    protected function getIndexableVersionManagerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Surfaces\Classes_Surface' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Surfaces\Classes_Surface
     */
    protected function getClassesSurfaceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Surfaces\Helpers_Surface' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Surfaces\Helpers_Surface
     */
    protected function getHelpersSurfaceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Surfaces\Meta_Surface' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Surfaces\Meta_Surface
     */
    protected function getMetaSurfaceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Surfaces\Open_Graph_Helpers_Surface' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Surfaces\Open_Graph_Helpers_Surface
     */
    protected function getOpenGraphHelpersSurfaceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Surfaces\Schema_Helpers_Surface' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Surfaces\Schema_Helpers_Surface
     */
    protected function getSchemaHelpersSurfaceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Surfaces\Twitter_Helpers_Surface' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Surfaces\Twitter_Helpers_Surface
     */
    protected function getTwitterHelpersSurfaceService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Values\Images' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Values\Images
     */
    protected function getImagesService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions
     */
    protected function getIndexableBuilderVersionsService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Values\Open_Graph\Images' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Values\Open_Graph\Images
     */
    protected function getImages2Service()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Wrappers\WP_Query_Wrapper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Wrappers\WP_Query_Wrapper
     */
    protected function getWPQueryWrapperService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Wrappers\WP_Remote_Handler' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Wrappers\WP_Remote_Handler
     */
    protected function getWPRemoteHandlerService()
    {
    }
    /**
     * Gets the public 'Yoast\WP\SEO\Wrappers\WP_Rewrite_Wrapper' shared autowired service.
     *
     * @return \Yoast\WP\SEO\Wrappers\WP_Rewrite_Wrapper
     */
    protected function getWPRewriteWrapperService()
    {
    }
    /**
     * Gets the public 'Yoast_Notification_Center' shared service.
     *
     * @return \Yoast_Notification_Center
     */
    protected function getYoastNotificationCenterService()
    {
    }
    /**
     * Gets the private 'wpdb' shared service.
     *
     * @return \wpdb
     */
    protected function getWpdbService()
    {
    }
  }
}

namespace Yoast\WP\SEO\Generators {
  interface Generator_Interface
  {
    /**
     * Returns a string, or other Thing that the associated presenter can handle.
     *
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return mixed
     */
    public function generate(\Yoast\WP\SEO\Context\Meta_Tags_Context $context);
  }
  /**
   * Represents the generator class for the breadcrumbs.
   */
  class Breadcrumbs_Generator implements \Yoast\WP\SEO\Generators\Generator_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    private $repository;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    private $current_page_helper;
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    private $post_type_helper;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    private $url_helper;
    /**
     * The pagination helper.
     *
     * @var Pagination_Helper
     */
    private $pagination_helper;
    /**
     * Breadcrumbs_Generator constructor.
     *
     * @param Indexable_Repository $repository          The repository.
     * @param Options_Helper       $options             The options helper.
     * @param Current_Page_Helper  $current_page_helper The current page helper.
     * @param Post_Type_Helper     $post_type_helper    The post type helper.
     * @param Url_Helper           $url_helper          The URL helper.
     * @param Pagination_Helper    $pagination_helper   The pagination helper.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page_helper, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast\WP\SEO\Helpers\Url_Helper $url_helper, \Yoast\WP\SEO\Helpers\Pagination_Helper $pagination_helper)
    {
    }
    /**
     * Generates the breadcrumbs.
     *
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return array An array of associative arrays that each have a 'text' and a 'url'.
     */
    public function generate(\Yoast\WP\SEO\Context\Meta_Tags_Context $context)
    {
    }
    /**
     * Returns the modified post crumb.
     *
     * @param array     $crumb    The crumb.
     * @param Indexable $ancestor The indexable.
     *
     * @return array The crumb.
     */
    private function get_post_crumb($crumb, $ancestor)
    {
    }
    /**
     * Returns the modified post type crumb.
     *
     * @param array     $crumb    The crumb.
     * @param Indexable $ancestor The indexable.
     *
     * @return array The crumb.
     */
    private function get_post_type_archive_crumb($crumb, $ancestor)
    {
    }
    /**
     * Returns the modified term crumb.
     *
     * @param array     $crumb    The crumb.
     * @param Indexable $ancestor The indexable.
     *
     * @return array The crumb.
     */
    private function get_term_crumb($crumb, $ancestor)
    {
    }
    /**
     * Returns the modified system page crumb.
     *
     * @param array     $crumb    The crumb.
     * @param Indexable $ancestor The indexable.
     *
     * @return array The crumb.
     */
    private function get_system_page_crumb($crumb, $ancestor)
    {
    }
    /**
     * Returns the modified user crumb.
     *
     * @param array     $crumb    The crumb.
     * @param Indexable $ancestor The indexable.
     *
     * @return array The crumb.
     */
    private function get_user_crumb($crumb, $ancestor)
    {
    }
    /**
     * Returns the modified date archive crumb.
     *
     * @param array $crumb The crumb.
     *
     * @return array The crumb.
     */
    protected function get_date_archive_crumb($crumb)
    {
    }
    /**
     * Returns whether or not a blog crumb should be added.
     *
     * @param int               $page_for_posts The page for posts ID.
     * @param Meta_Tags_Context $context        The meta tags context.
     *
     * @return bool Whether or not a blog crumb should be added.
     */
    protected function should_have_blog_crumb($page_for_posts, $context)
    {
    }
    /**
     * Returns the post type parent of a given taxonomy.
     *
     * @param string $taxonomy The taxonomy.
     *
     * @return string|false The parent if it exists, false otherwise.
     */
    protected function get_taxonomy_post_type_parent($taxonomy)
    {
    }
    /**
     * Adds a crumb for the current page, if we're on an archive page or paginated post.
     *
     * @param array     $crumbs            The array of breadcrumbs.
     * @param Indexable $current_indexable The current indexable.
     *
     * @return array The breadcrumbs.
     */
    protected function add_paged_crumb(array $crumbs, $current_indexable)
    {
    }
  }
  /**
   * Represents the generator class for the Open Graph images.
   */
  class Open_Graph_Image_Generator implements \Yoast\WP\SEO\Generators\Generator_Interface
  {
    /**
     * The Open Graph image helper.
     *
     * @var Open_Graph_Image_Helper
     */
    protected $open_graph_image;
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    protected $image;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    protected $url;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Images constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Open_Graph_Image_Helper $open_graph_image Image helper for Open Graph.
     * @param Image_Helper            $image            The image helper.
     * @param Options_Helper          $options          The options helper.
     * @param Url_Helper              $url              The url helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Open_Graph\Image_Helper $open_graph_image, \Yoast\WP\SEO\Helpers\Image_Helper $image, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Url_Helper $url)
    {
    }
    /**
     * Retrieves the images for an indexable.
     *
     * For legacy reasons some plugins might expect we filter a WPSEO_Opengraph_Image object. That might cause
     * type errors. This is why we try/catch our filters.
     *
     * @param Meta_Tags_Context $context The context.
     *
     * @return array The images.
     */
    public function generate(\Yoast\WP\SEO\Context\Meta_Tags_Context $context)
    {
    }
    /**
     * Retrieves the images for an author archive indexable.
     *
     * This is a custom method to address the case of Author Archives, since they always have an Open Graph image
     * set in the indexable (even if it is an empty default Gravatar).
     *
     * @param Meta_Tags_Context $context The context.
     *
     * @return array The images.
     */
    public function generate_for_author_archive(\Yoast\WP\SEO\Context\Meta_Tags_Context $context)
    {
    }
    /**
     * Adds an image based on the given indexable.
     *
     * @param Indexable $indexable       The indexable.
     * @param Images    $image_container The image container.
     */
    protected function add_from_indexable(\Yoast\WP\SEO\Models\Indexable $indexable, \Yoast\WP\SEO\Values\Open_Graph\Images $image_container)
    {
    }
    /**
     * Retrieves the default Open Graph image.
     *
     * @param Images $image_container The image container.
     */
    protected function add_from_default(\Yoast\WP\SEO\Values\Open_Graph\Images $image_container)
    {
    }
    /**
     * Retrieves the default Open Graph image.
     *
     * @param Meta_Tags_Context $context         The context.
     * @param Images            $image_container The image container.
     */
    protected function add_from_templates(\Yoast\WP\SEO\Context\Meta_Tags_Context $context, \Yoast\WP\SEO\Values\Open_Graph\Images $image_container)
    {
    }
    /**
     * Retrieves an instance of the image container.
     *
     * @codeCoverageIgnore
     *
     * @return Images The image container.
     */
    protected function get_image_container()
    {
    }
  }
  /**
   * Class Open_Graph_Locale_Generator.
   */
  class Open_Graph_Locale_Generator implements \Yoast\WP\SEO\Generators\Generator_Interface
  {
    /**
     * Generates the OG Locale.
     *
     * @param Meta_Tags_Context $context The context.
     *
     * @return string The OG locale.
     */
    public function generate(\Yoast\WP\SEO\Context\Meta_Tags_Context $context)
    {
    }
  }
  /**
   * Class Schema_Generator.
   */
  class Schema_Generator implements \Yoast\WP\SEO\Generators\Generator_Interface
  {
    /**
     * The helpers surface.
     *
     * @var Helpers_Surface
     */
    protected $helpers;
    /**
     * The Schema replace vars helper.
     *
     * @var Replace_Vars_Helper
     */
    protected $schema_replace_vars_helper;
    /**
     * Generator constructor.
     *
     * @param Helpers_Surface     $helpers                    The helpers surface.
     * @param Replace_Vars_Helper $schema_replace_vars_helper The replace vars helper.
     */
    public function __construct(\Yoast\WP\SEO\Surfaces\Helpers_Surface $helpers, \Yoast\WP\SEO\Helpers\Schema\Replace_Vars_Helper $schema_replace_vars_helper)
    {
    }
    /**
     * Returns a Schema graph array.
     *
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return array The graph.
     */
    public function generate(\Yoast\WP\SEO\Context\Meta_Tags_Context $context)
    {
    }
    /**
     * Filters out any graph pieces that should not be generated.
     * (Using the `wpseo_schema_needs_<graph_piece_identifier>` series of filters).
     *
     * @param array $graph_pieces The current list of graph pieces that we want to generate.
     *
     * @return array The graph pieces to generate.
     */
    protected function filter_graph_pieces_to_generate($graph_pieces)
    {
    }
    /**
     * Generates the schema graph.
     *
     * @param array             $graph_piece_generators The schema graph pieces to generate.
     * @param Meta_Tags_Context $context                The meta tags context to use.
     *
     * @return array The generated schema graph.
     */
    protected function generate_graph($graph_piece_generators, $context)
    {
    }
    /**
     * Adds schema graph pieces from Gutenberg blocks on the current page to
     * the given schema graph.
     *
     * Think of blocks like the Yoast FAQ block or the How To block.
     *
     * @param array             $graph   The current schema graph.
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return array The graph with the schema blocks graph pieces added.
     */
    protected function add_schema_blocks_graph_pieces($graph, $context)
    {
    }
    /**
     * Finalizes the schema graph after all filtering is done.
     *
     * @param array             $graph   The current schema graph.
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return array The schema graph.
     */
    protected function finalize_graph($graph, $context)
    {
    }
    /**
     * Removes the breadcrumb schema if empty.
     *
     * @param array             $graph   The current schema graph.
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return array The schema graph with empty breadcrumbs taken out.
     */
    protected function remove_empty_breadcrumb($graph, $context)
    {
    }
    /**
     * Adapts the WebPage graph piece for password-protected posts.
     *
     * It should only have certain whitelisted properties.
     * The type should always be WebPage.
     *
     * @param array $graph_piece The WebPage graph piece that should be adapted for password-protected posts.
     *
     * @return array The WebPage graph piece that has been adapted for password-protected posts.
     */
    public function protected_webpage_schema($graph_piece)
    {
    }
    /**
     * Gets all the graph pieces we need.
     *
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return Abstract_Schema_Piece[] A filtered array of graph pieces.
     */
    protected function get_graph_pieces($context)
    {
    }
    /**
     * Allows filtering the graph piece by its schema type.
     *
     * Note: We removed the Abstract_Schema_Piece type-hint from the $graph_piece_generator argument, because
     *       it caused conflicts with old code, Yoast SEO Video specifically.
     *
     * @param array                   $graph_piece            The graph piece we're filtering.
     * @param string                  $identifier             The identifier of the graph piece that is being filtered.
     * @param Meta_Tags_Context       $context                The meta tags context.
     * @param Abstract_Schema_Piece   $graph_piece_generator  A value object with context variables.
     * @param Abstract_Schema_Piece[] $graph_piece_generators A value object with context variables.
     *
     * @return array The filtered graph piece.
     */
    private function type_filter($graph_piece, $identifier, \Yoast\WP\SEO\Context\Meta_Tags_Context $context, $graph_piece_generator, array $graph_piece_generators)
    {
    }
    /**
     * Retrieves the type from a graph piece.
     *
     * @param array $piece The graph piece.
     *
     * @return array An array of the piece's types.
     */
    private function get_type_from_piece($piece)
    {
    }
    /**
     * Validates a graph piece's type.
     *
     * When the type is an array:
     *   - Ensure the values are unique.
     *   - Only 1 value? Use that value without the array wrapping.
     *
     * @param array $piece The graph piece.
     *
     * @return array The graph piece.
     */
    private function validate_type($piece)
    {
    }
  }
}

namespace Yoast\WP\SEO\Generators\Schema {
  /**
   * Class Abstract_Schema_Piece.
   */
  abstract class Abstract_Schema_Piece
  {
    /**
     * The meta tags context.
     *
     * @var Meta_Tags_Context
     */
    public $context;
    /**
     * The helpers surface
     *
     * @var Helpers_Surface
     */
    public $helpers;
    /**
     * Optional identifier for this schema piece.
     *
     * Used in the `Schema_Generator::filter_graph_pieces_to_generate()` method.
     *
     * @var string
     */
    public $identifier;
    /**
     * Generates the schema piece.
     *
     * @return mixed
     */
    public abstract function generate();
    /**
     * Determines whether the schema piece is needed.
     *
     * @return bool
     */
    public abstract function is_needed();
  }
  /**
   * Returns schema Article data.
   */
  class Article extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determines whether or not a piece should be added to the graph.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Returns Article data.
     *
     * @return array Article data.
     */
    public function generate()
    {
    }
    /**
     * Adds tags as keywords, if tags are assigned.
     *
     * @param array $data Article data.
     *
     * @return array Article data.
     */
    private function add_keywords($data)
    {
    }
    /**
     * Adds categories as sections, if categories are assigned.
     *
     * @param array $data Article data.
     *
     * @return array Article data.
     */
    private function add_sections($data)
    {
    }
    /**
     * Adds a term or multiple terms, comma separated, to a field.
     *
     * @param array  $data     Article data.
     * @param string $key      The key in data to save the terms in.
     * @param string $taxonomy The taxonomy to retrieve the terms from.
     *
     * @return mixed Article data.
     */
    protected function add_terms($data, $key, $taxonomy)
    {
    }
    /**
     * Adds an image node if the post has a featured image.
     *
     * @param array $data The Article data.
     *
     * @return array The Article data.
     */
    private function add_image($data)
    {
    }
    /**
     * Adds the potential action property to the Article Schema piece.
     *
     * @param array $data The Article data.
     *
     * @return array The Article data with the potential action added.
     */
    private function add_potential_action($data)
    {
    }
    /**
     * Does a simple word count but tries to be relatively smart about it.
     *
     * @param string $post_content The post content.
     * @param string $post_title   The post title.
     *
     * @return int The number of words in the content.
     */
    private function word_count($post_content, $post_title = '')
    {
    }
  }
  /**
   * Returns schema Person data.
   */
  class Person extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Array of the social profiles we display for a Person.
     *
     * @var string[]
     */
    private $social_profiles = ['facebook', 'instagram', 'linkedin', 'pinterest', 'twitter', 'myspace', 'youtube', 'soundcloud', 'tumblr', 'wikipedia'];
    /**
     * The Schema type we use for this class.
     *
     * @var string[]
     */
    protected $type = ['Person', 'Organization'];
    /**
     * Determine whether we should return Person schema.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Returns Person Schema data.
     *
     * @return bool|array Person data on success, false on failure.
     */
    public function generate()
    {
    }
    /**
     * Determines a User ID for the Person data.
     *
     * @return bool|int User ID or false upon return.
     */
    protected function determine_user_id()
    {
    }
    /**
     * Retrieve a list of social profile URLs for Person.
     *
     * @param array $same_as_urls Array of SameAs URLs.
     * @param int   $user_id      User ID.
     *
     * @return string[] A list of SameAs URLs.
     */
    protected function get_social_profiles($same_as_urls, $user_id)
    {
    }
    /**
     * Builds our array of Schema Person data for a given user ID.
     *
     * @param int  $user_id  The user ID to use.
     * @param bool $add_hash Wether or not the person's image url hash should be added to the image id.
     *
     * @return array An array of Schema Person data.
     */
    protected function build_person_data($user_id, $add_hash = false)
    {
    }
    /**
     * Returns an ImageObject for the persons avatar.
     *
     * @param array   $data      The Person schema.
     * @param WP_User $user_data User data.
     * @param bool    $add_hash  Wether or not the person's image url hash should be added to the image id.
     *
     * @return array The Person schema.
     */
    protected function add_image($data, $user_data, $add_hash = false)
    {
    }
    /**
     * Generate the person image from our settings.
     *
     * @param array   $data      The Person schema.
     * @param string  $schema_id The string used in the `@id` for the schema.
     * @param bool    $add_hash  Whether or not the person's image url hash should be added to the image id.
     * @param WP_User $user_data User data.
     *
     * @return array The Person schema.
     */
    protected function set_image_from_options($data, $schema_id, $add_hash = false, $user_data = null)
    {
    }
    /**
     * Generate the person logo from gravatar.
     *
     * @param array   $data      The Person schema.
     * @param WP_User $user_data User data.
     * @param string  $schema_id The string used in the `@id` for the schema.
     * @param bool    $add_hash  Wether or not the person's image url hash should be added to the image id.
     *
     * @return array The Person schema.
     */
    protected function set_image_from_avatar($data, $user_data, $schema_id, $add_hash = false)
    {
    }
    /**
     * Returns an author's social site URL.
     *
     * @param string $social_site The social site to retrieve the URL for.
     * @param mixed  $user_id     The user ID to use function outside of the loop.
     *
     * @return string
     */
    protected function url_social_site($social_site, $user_id = false)
    {
    }
    /**
     * Checks the site is represented by the same person as this indexable.
     *
     * @param WP_User $user_data User data.
     *
     * @return bool True when the site is represented by the same person as this indexable.
     */
    protected function site_represents_current_author($user_data = null)
    {
    }
    /**
     * Builds our SameAs array.
     *
     * @param array   $data      The Person schema data.
     * @param WP_User $user_data The user data object.
     * @param int     $user_id   The user ID to use.
     *
     * @return array The Person schema data.
     */
    protected function add_same_as_urls($data, $user_data, $user_id)
    {
    }
  }
  /**
   * Returns schema Author data.
   */
  class Author extends \Yoast\WP\SEO\Generators\Schema\Person
  {
    /**
     * Determine whether we should return Person schema.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Returns Person Schema data.
     *
     * @return bool|array Person data on success, false on failure.
     */
    public function generate()
    {
    }
    /**
     * Determines a User ID for the Person data.
     *
     * @return bool|int User ID or false upon return.
     */
    protected function determine_user_id()
    {
    }
    /**
     * An author should not have an image from options, this only applies to persons.
     *
     * @param array   $data      The Person schema.
     * @param string  $schema_id The string used in the `@id` for the schema.
     * @param bool    $add_hash  Whether or not the person's image url hash should be added to the image id.
     * @param WP_User $user_data User data.
     *
     * @return array The Person schema.
     */
    protected function set_image_from_options($data, $schema_id, $add_hash = false, $user_data = null)
    {
    }
  }
  /**
   * Returns schema Breadcrumb data.
   */
  class Breadcrumb extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determine if we should add a breadcrumb attribute.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Returns Schema breadcrumb data to allow recognition of page's position in the site hierarchy.
     *
     * @link https://developers.google.com/search/docs/data-types/breadcrumb
     *
     * @return bool|array Array on success, false on failure.
     */
    public function generate()
    {
    }
    /**
     * Returns a breadcrumb array.
     *
     * @param int   $index      The position in the list.
     * @param array $breadcrumb The position in the list.
     *
     * @return array A breadcrumb listItem.
     */
    private function create_breadcrumb($index, $breadcrumb)
    {
    }
    /**
     * Creates the last breadcrumb in the breadcrumb list, omitting the URL per Google's spec.
     *
     * @link https://developers.google.com/search/docs/data-types/breadcrumb
     *
     * @param array $breadcrumb The position in the list.
     *
     * @return array The last of the breadcrumbs.
     */
    private function format_last_breadcrumb($breadcrumb)
    {
    }
    /**
     * Tests if the breadcrumb is broken.
     * A breadcrumb is considered broken:
     * - when it is not an array.
     * - when it has no URL or text.
     *
     * @param array $breadcrumb The breadcrumb to test.
     *
     * @return bool `true` if the breadcrumb is broken.
     */
    private function is_broken($breadcrumb)
    {
    }
    /**
     * Checks whether the breadcrumb is not set to be hidden.
     *
     * @param array $breadcrumb The breadcrumb array.
     *
     * @return bool If the breadcrumb should not be hidden.
     */
    private function not_hidden($breadcrumb)
    {
    }
    /**
     * Checks whether the breadcrumb has a not empty text.
     *
     * @param array $breadcrumb The breadcrumb array.
     *
     * @return bool If the breadcrumb has a not empty text.
     */
    private function not_empty_text($breadcrumb)
    {
    }
  }
  /**
   * Returns schema FAQ data.
   */
  class FAQ extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determines whether or not a piece should be added to the graph.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Generate the IDs so we can link to them in the main entity.
     *
     * @return array
     */
    private function generate_ids()
    {
    }
    /**
     * Render a list of questions, referencing them by ID.
     *
     * @return array Our Schema graph.
     */
    public function generate()
    {
    }
    /**
     * Generate a Question piece.
     *
     * @param array $question The question to generate schema for.
     * @param int   $position The position of the question.
     *
     * @return array Schema.org Question piece.
     */
    protected function generate_question_block($question, $position)
    {
    }
    /**
     * Adds the Questions `acceptedAnswer` property.
     *
     * @param array $question The question to add the acceptedAnswer to.
     *
     * @return array Schema.org Question piece.
     */
    protected function add_accepted_answer_property($question)
    {
    }
  }
  /**
   * Returns schema HowTo data.
   */
  class HowTo extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determines whether or not a piece should be added to the graph.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Renders a list of questions, referencing them by ID.
     *
     * @return array Our Schema graph.
     */
    public function generate()
    {
    }
    /**
     * Adds the duration of the task to the Schema.
     *
     * @param array $data       Our How-To schema data.
     * @param array $attributes The block data attributes.
     */
    private function add_duration(&$data, $attributes)
    {
    }
    /**
     * Adds the steps to our How-To output.
     *
     * @param array $data  Our How-To schema data.
     * @param array $steps Our How-To block's steps.
     */
    private function add_steps(&$data, $steps)
    {
    }
    /**
     * Checks if we have a step description, if we do, add it.
     *
     * @param array  $schema_step Our Schema output for the Step.
     * @param string $json_text   The step text.
     */
    private function add_step_description(&$schema_step, $json_text)
    {
    }
    /**
     * Checks if we have a step image, if we do, add it.
     *
     * @param array $schema_step Our Schema output for the Step.
     * @param array $step        The step block data.
     */
    private function add_step_image(&$schema_step, $step)
    {
    }
    /**
     * Generates the HowTo schema for a block.
     *
     * @param array $graph Our Schema data.
     * @param array $block The How-To block content.
     * @param int   $index The index of the current block.
     */
    protected function add_how_to(&$graph, $block, $index)
    {
    }
    /**
     * Generates the image schema from the attachment $url.
     *
     * @param string $url Attachment url.
     *
     * @return array Image schema.
     */
    protected function get_image_schema($url)
    {
    }
  }
  /**
   * Returns ImageObject schema data.
   */
  class Main_Image extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determines whether or not a piece should be added to the graph.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Adds a main image for the current URL to the schema if there is one.
     *
     * This can be either the featured image or the first image in the content of the page.
     *
     * @return false|array Image Schema.
     */
    public function generate()
    {
    }
  }
  /**
   * Returns schema Organization data.
   */
  class Organization extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determines whether an Organization graph piece should be added.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Returns the Organization Schema data.
     *
     * @return array The Organization schema.
     */
    public function generate()
    {
    }
    /**
     * Retrieve the social profiles to display in the organization schema.
     *
     * @return array An array of social profiles.
     */
    private function fetch_social_profiles()
    {
    }
  }
  /**
   * Returns schema WebPage data.
   */
  class WebPage extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determines whether or not a piece should be added to the graph.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Returns WebPage schema data.
     *
     * @return array WebPage schema data.
     */
    public function generate()
    {
    }
    /**
     * Adds an author property to the $data if the WebPage is not represented.
     *
     * @param array   $data The WebPage schema.
     * @param WP_Post $post The post the context is representing.
     *
     * @return array The WebPage schema.
     */
    public function add_author($data, $post)
    {
    }
    /**
     * If we have an image, make it the primary image of the page.
     *
     * @param array $data WebPage schema data.
     */
    public function add_image(&$data)
    {
    }
    /**
     * Determine if we should add a breadcrumb attribute.
     *
     * @return bool
     */
    private function add_breadcrumbs()
    {
    }
    /**
     * Adds the potential action property to the WebPage Schema piece.
     *
     * @param array $data The WebPage data.
     *
     * @return array The WebPage data with the potential action added.
     */
    private function add_potential_action($data)
    {
    }
    /**
     * Creates the search URL for use when if there is no canonical.
     *
     * @return string Search URL.
     */
    private function build_search_url()
    {
    }
  }
  /**
   * Returns schema Website data.
   */
  class Website extends \Yoast\WP\SEO\Generators\Schema\Abstract_Schema_Piece
  {
    /**
     * Determines whether or not a piece should be added to the graph.
     *
     * @return bool
     */
    public function is_needed()
    {
    }
    /**
     * Outputs code to allow recognition of the internal search engine.
     *
     * @return array Website data blob.
     */
    public function generate()
    {
    }
    /**
     * Returns an alternate name if one was specified in the Yoast SEO settings.
     *
     * @param array $data The website data array.
     *
     * @return array
     */
    private function add_alternate_name($data)
    {
    }
    /**
     * Adds the internal search JSON LD code to the homepage if it's not disabled.
     *
     * @link https://developers.google.com/search/docs/data-types/sitelinks-searchbox
     *
     * @param array $data The website data array.
     *
     * @return array
     */
    private function internal_search_section($data)
    {
    }
  }
}

namespace Yoast\WP\SEO\Generators {
  /**
   * Represents the generator class for the Twitter images.
   */
  class Twitter_Image_Generator implements \Yoast\WP\SEO\Generators\Generator_Interface
  {
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    protected $image;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    protected $url;
    /**
     * The Twitter image helper.
     *
     * @var Twitter_Image_Helper
     */
    protected $twitter_image;
    /**
     * Twitter_Image_Generator constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Image_Helper         $image         The image helper.
     * @param Url_Helper           $url           The url helper.
     * @param Twitter_Image_Helper $twitter_image The Twitter image helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Image_Helper $image, \Yoast\WP\SEO\Helpers\Url_Helper $url, \Yoast\WP\SEO\Helpers\Twitter\Image_Helper $twitter_image)
    {
    }
    /**
     * Retrieves the images for an indexable.
     *
     * @param Meta_Tags_Context $context The context.
     *
     * @return array The images.
     */
    public function generate(\Yoast\WP\SEO\Context\Meta_Tags_Context $context)
    {
    }
    /**
     * Adds an image based on the given indexable.
     *
     * @param Indexable $indexable       The indexable.
     * @param Images    $image_container The image container.
     */
    protected function add_from_indexable(\Yoast\WP\SEO\Models\Indexable $indexable, \Yoast\WP\SEO\Values\Images $image_container)
    {
    }
    /**
     * Retrieves an instance of the image container.
     *
     * @codeCoverageIgnore
     *
     * @return Images The image container.
     */
    protected function get_image_container()
    {
    }
  }
}

namespace Yoast\WP\SEO\Helpers {
  /**
   * The AIOSEO Helper.
   */
  class Aioseo_Helper
  {
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * The wpdb helper.
     *
     * @var Wpdb_Helper
     */
    protected $wpdb_helper;
    /**
     * Class constructor.
     *
     * @param wpdb        $wpdb        The WordPress database instance.
     * @param Wpdb_Helper $wpdb_helper The wpdb helper.
     */
    public function __construct(\wpdb $wpdb, \Yoast\WP\SEO\Helpers\Wpdb_Helper $wpdb_helper)
    {
    }
    /**
     * Retrieves the AIOSEO table name along with the db prefix.
     *
     * @return string The AIOSEO table name along with the db prefix.
     */
    public function get_table()
    {
    }
    /**
     * Determines if the AIOSEO database table exists.
     *
     * @return bool True if the table is found.
     */
    public function aioseo_exists()
    {
    }
    /**
     * Retrieves the option where the global settings exist.
     *
     * @return array The option where the global settings exist.
     */
    public function get_global_option()
    {
    }
  }
  /**
   * A helper object for author archives.
   */
  class Asset_Helper
  {
    /**
     * Recursively retrieves all dependency urls of a given handle.
     *
     * @param string $handle The handle.
     *
     * @return string[] All dependency urls of the given handle.
     */
    public function get_dependency_urls_by_handle($handle)
    {
    }
    /**
     * Recursively retrieves all dependencies of a given handle.
     *
     * @param string $handle The handle.
     *
     * @return string[]|bool All dependencies of the given handle.
     */
    public function get_dependency_handles($handle)
    {
    }
    /**
     * Gets the URL of a given asset.
     *
     * This logic is copied from WP_Scripts::do_item as unfortunately that logic is not properly isolated.
     *
     * @param string $handle The handle of the asset.
     *
     * @return string|false The URL of the asset or false if the asset does not exist.
     */
    public function get_asset_url($handle)
    {
    }
  }
  /**
   * A helper object for the cleanup of attachments.
   */
  class Attachment_Cleanup_Helper
  {
    /**
     * Removes all indexables for attachments.
     *
     * @param bool $suppress_errors Whether to suppress db errors when running the cleanup query.
     *
     * @return void
     */
    public function remove_attachment_indexables($suppress_errors)
    {
    }
    /**
     * Cleans all attachment links in the links table from target indexable ids.
     *
     * @param bool $suppress_errors Whether to suppress db errors when running the cleanup query.
     *
     * @return void
     */
    public function clean_attachment_links_from_target_indexable_ids($suppress_errors)
    {
    }
  }
  /**
   * A helper object for author archives.
   */
  class Author_Archive_Helper
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    private $post_type_helper;
    /**
     * Creates a new author archive helper.
     *
     * @param Options_Helper   $options_helper   The options helper.
     * @param Post_Type_Helper $post_type_helper The post type helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper)
    {
    }
    /**
     * Gets the array of post types that are shown on an author's archive.
     *
     * @return array The post types that are shown on an author's archive.
     */
    public function get_author_archive_post_types()
    {
    }
    /**
     * Returns whether the author has at least one public post.
     *
     * @param int $author_id The author ID.
     *
     * @return bool|null Whether the author has at least one public post.
     */
    public function author_has_public_posts($author_id)
    {
    }
    /**
     * Returns whether the author has at least one public post.
     *
     * **Note**: It uses WP_Query to determine the number of posts,
     * not the indexables table.
     *
     * @param string $user_id The user ID.
     *
     * @return bool Whether the author has at least one public post.
     */
    public function author_has_public_posts_wp($user_id)
    {
    }
    /**
     * Checks whether author archives are disabled.
     *
     * @return bool `true` if author archives are disabled, `false` if not.
     */
    public function are_disabled()
    {
    }
    /**
     * Returns whether the author has at least one public post.
     *
     * @codeCoverageIgnore It looks for the first ID through the ORM and converts it to a boolean.
     *
     * @param int $author_id The author ID.
     *
     * @return bool Whether the author has at least one public post.
     */
    protected function author_has_a_public_post($author_id)
    {
    }
    /**
     * Returns whether the author has at least one post with the is public null.
     *
     * @codeCoverageIgnore It looks for the first ID through the ORM and converts it to a boolean.
     *
     * @param int $author_id The author ID.
     *
     * @return bool Whether the author has at least one post with the is public null.
     */
    protected function author_has_a_post_with_is_public_null($author_id)
    {
    }
  }
  /**
   * A helper object for blocks.
   */
  class Blocks_Helper
  {
    /**
     * Holds the Post_Helper instance.
     *
     * @var Post_Helper
     */
    private $post;
    /**
     * Constructs a Blocks_Helper instance.
     *
     * @codeCoverageIgnore It handles dependencies.
     *
     * @param Post_Helper $post The post helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Helper $post)
    {
    }
    /**
     * Returns all blocks in a given post.
     *
     * @param int $post_id The post id.
     *
     * @return array The blocks in a block-type => WP_Block_Parser_Block[] format.
     */
    public function get_all_blocks_from_post($post_id)
    {
    }
    /**
     * Returns all blocks in a given content.
     *
     * @param string $content The content.
     *
     * @return array The blocks in a block-type => WP_Block_Parser_Block[] format.
     */
    public function get_all_blocks_from_content($content)
    {
    }
    /**
     * Checks if the installation has blocks support.
     *
     * @codeCoverageIgnore It only checks if a WordPress function exists.
     *
     * @return bool True when function parse_blocks exists.
     */
    protected function has_blocks_support()
    {
    }
    /**
     * Collects an array of blocks into an organised collection.
     *
     * @param WP_Block_Parser_Block[] $blocks     The blocks.
     * @param array                   $collection The collection.
     *
     * @return array The blocks in a block-type => WP_Block_Parser_Block[] format.
     */
    private function collect_blocks($blocks, $collection)
    {
    }
  }
  /**
   * A helper object for user capabilities.
   */
  class Capability_Helper
  {
    /**
     * Checks if the user has at least one of the proper capabilities.
     *
     * @param string $capability Capability to check.
     *
     * @return bool True if the user has at least one of the proper rights.
     */
    public function current_user_can($capability)
    {
    }
    /**
     * Retrieves the users that have the specified capability.
     *
     * @param string $capability The name of the capability.
     *
     * @return array The users that have the capability.
     */
    public function get_applicable_users($capability)
    {
    }
    /**
     * Retrieves the roles that have the specified capability.
     *
     * @param string $capability The name of the capability.
     *
     * @return array The names of the roles that have the capability.
     */
    public function get_applicable_roles($capability)
    {
    }
    /**
     * Checks if the current user has at least one of the supplied capabilities.
     *
     * @param array $capabilities Capabilities to check against.
     *
     * @return bool True if the user has at least one capability.
     */
    private function has_any(array $capabilities)
    {
    }
  }
  /**
   * Class Crawl_Cleanup_Helper.
   *
   * Used by the Crawl_Cleanup_Permalinks class.
   */
  class Crawl_Cleanup_Helper
  {
    /**
     * The current page helper
     *
     * @var Current_Page_Helper
     */
    private $current_page_helper;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    private $url_helper;
    /**
     * The Redirect Helper.
     *
     * @var Redirect_Helper
     */
    private $redirect_helper;
    /**
     * Crawl Cleanup Basic integration constructor.
     *
     * @param Current_Page_Helper $current_page_helper The current page helper.
     * @param Options_Helper      $options_helper      The option helper.
     * @param Url_Helper          $url_helper          The URL helper.
     * @param Redirect_Helper     $redirect_helper     The Redirect Helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page_helper, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Url_Helper $url_helper, \Yoast\WP\SEO\Helpers\Redirect_Helper $redirect_helper)
    {
    }
    /**
     * Checks if the current URL is not robots, sitemap, empty or user is logged in.
     *
     * @return bool True if the current URL is a valid URL.
     */
    public function should_avoid_redirect()
    {
    }
    /**
     * Returns the list of the allowed extra vars.
     *
     * @return array The list of the allowed extra vars.
     */
    public function get_allowed_extravars()
    {
    }
    /**
     * Gets the allowed query vars from the current URL.
     *
     * @param string $current_url The current URL.
     * @return array is_allowed and allowed_query.
     */
    public function allowed_params($current_url)
    {
    }
    /**
     * Returns the proper URL for singular pages.
     *
     * @return string The proper URL.
     */
    public function singular_url()
    {
    }
    /**
     * Returns the proper URL for front page.
     *
     * @return string The proper URL.
     */
    public function front_page_url()
    {
    }
    /**
     * Returns the proper URL for 404 page.
     *
     * @param string $current_url The current URL.
     * @return string The proper URL.
     */
    public function page_not_found_url($current_url)
    {
    }
    /**
     * Returns the proper URL for taxonomy page.
     *
     * @return string The proper URL.
     */
    public function taxonomy_url()
    {
    }
    /**
     * Returns the proper URL for search page.
     *
     * @return string The proper URL.
     */
    public function search_url()
    {
    }
    /**
     * Returns the proper URL for url with page param.
     *
     * @param string $proper_url The proper URL.
     * @return string The proper URL.
     */
    public function query_var_page_url($proper_url)
    {
    }
    /**
     * Returns true if query is with page param.
     *
     * @param string $proper_url The proper URL.
     * @return bool is query with page param.
     */
    public function is_query_var_page($proper_url)
    {
    }
    /**
     * Redirects clean permalink.
     *
     * @param string $proper_url The proper URL.
     * @return void.
     */
    public function do_clean_redirect($proper_url)
    {
    }
    /**
     * Gets the type of URL.
     *
     * @return string The type of URL.
     */
    public function get_url_type()
    {
    }
    /**
     * Returns the proper URL for posts page.
     *
     * @return string The proper URL.
     */
    public function page_for_posts_url()
    {
    }
  }
  /**
   * Helper class for getting information about the installed cURL version.
   */
  class Curl_Helper
  {
    /**
     * Checks is cURL is installed.
     *
     * @return bool Returns true if cURL is installed.
     */
    public function is_installed()
    {
    }
    /**
     * Returns the currently installed cURL version.
     *
     * @return string|null Returns a string containing the cURL version, or null if cURL is not installed.
     */
    public function get_version()
    {
    }
  }
  /**
   * A helper object for WordPress posts.
   */
  class Current_Page_Helper
  {
    /**
     * The WP Query wrapper.
     *
     * @var WP_Query_Wrapper
     */
    private $wp_query_wrapper;
    /**
     * Current_Page_Helper constructor.
     *
     * @codeCoverageIgnore It only sets dependencies.
     *
     * @param WP_Query_Wrapper $wp_query_wrapper The wrapper for WP_Query.
     */
    public function __construct(\Yoast\WP\SEO\Wrappers\WP_Query_Wrapper $wp_query_wrapper)
    {
    }
    /**
     * Returns the page type for the current request.
     *
     * @codeCoverageIgnore It just depends on other functions for its result.
     *
     * @return string Page type.
     */
    public function get_page_type()
    {
    }
    /**
     * Checks if the currently opened page is a simple page.
     *
     * @return bool Whether the currently opened page is a simple page.
     */
    public function is_simple_page()
    {
    }
    /**
     * Returns the id of the currently opened page.
     *
     * @return int The id of the currently opened page.
     */
    public function get_simple_page_id()
    {
    }
    /**
     * Returns the id of the currently opened author archive.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return int The id of the currently opened author archive.
     */
    public function get_author_id()
    {
    }
    /**
     * Returns the id of the front page.
     *
     * @return int The id of the front page. 0 if the front page is not a static page.
     */
    public function get_front_page_id()
    {
    }
    /**
     * Returns the id of the currently opened term archive.
     *
     * @return int The id of the currently opened term archive.
     */
    public function get_term_id()
    {
    }
    /**
     * Returns the post type of the main query.
     *
     * @return string The post type of the main query.
     */
    public function get_queried_post_type()
    {
    }
    /**
     * Returns the permalink of the currently opened date archive.
     * If the permalink was cached, it returns this permalink.
     * If not, we call another function to get the permalink through wp_query.
     *
     * @return string The permalink of the currently opened date archive.
     */
    public function get_date_archive_permalink()
    {
    }
    /**
     * Determine whether this is the homepage and shows posts.
     *
     * @return bool Whether or not the current page is the homepage that displays posts.
     */
    public function is_home_posts_page()
    {
    }
    /**
     * Determine whether this is the static frontpage.
     *
     * @return bool Whether or not the current page is a static frontpage.
     */
    public function is_home_static_page()
    {
    }
    /**
     * Determine whether this is the static posts page.
     *
     * @return bool Whether or not the current page is a static posts page.
     */
    public function is_static_posts_page()
    {
    }
    /**
     * Determine whether this is the statically set posts page, when it's not the frontpage.
     *
     * @return bool Whether or not it's a non-frontpage, statically set posts page.
     */
    public function is_posts_page()
    {
    }
    /**
     * Determine whether this is a post type archive.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether nor not the current page is a post type archive.
     */
    public function is_post_type_archive()
    {
    }
    /**
     * Determine whether this is a term archive.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether nor not the current page is a term archive.
     */
    public function is_term_archive()
    {
    }
    /**
     * Determine whether this is an attachment page.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether nor not the current page is an attachment page.
     */
    public function is_attachment()
    {
    }
    /**
     * Determine whether this is an author archive.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether nor not the current page is an author archive.
     */
    public function is_author_archive()
    {
    }
    /**
     * Determine whether this is an date archive.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether nor not the current page is an date archive.
     */
    public function is_date_archive()
    {
    }
    /**
     * Determine whether this is a search result.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether nor not the current page is a search result.
     */
    public function is_search_result()
    {
    }
    /**
     * Determine whether this is a 404 page.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether nor not the current page is a 404 page.
     */
    public function is_404()
    {
    }
    /**
     * Checks if the current page is the post format archive.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether or not the current page is the post format archive.
     */
    public function is_post_format_archive()
    {
    }
    /**
     * Determine whether this page is an taxonomy archive page for multiple terms (url: /term-1,term2/).
     *
     * @return bool Whether or not the current page is an archive page for multiple terms.
     */
    public function is_multiple_terms_page()
    {
    }
    /**
     * Checks whether the current page is paged.
     *
     * @codeCoverageIgnore This method only calls a WordPress function.
     *
     * @return bool Whether the current page is paged.
     */
    public function is_paged()
    {
    }
    /**
     * Checks if the current page is the front page.
     *
     * @codeCoverageIgnore It wraps WordPress functionality.
     *
     * @return bool Whether or not the current page is the front page.
     */
    public function is_front_page()
    {
    }
    /**
     * Retrieves the current admin page.
     *
     * @codeCoverageIgnore It only wraps a global WordPress variable.
     *
     * @return string The current page.
     */
    public function get_current_admin_page()
    {
    }
    /**
     * Check if the current opened page is a Yoast SEO page.
     *
     * @return bool True when current page is a yoast seo plugin page.
     */
    public function is_yoast_seo_page()
    {
    }
    /**
     * Returns the current Yoast SEO page.
     * (E.g. the `page` query variable in the URL).
     *
     * @return string The current Yoast SEO page.
     */
    public function get_current_yoast_seo_page()
    {
    }
    /**
     * Checks if the current global post is the privacy policy page.
     *
     * @return bool current global post is set as privacy page
     */
    public function current_post_is_privacy_policy()
    {
    }
    /**
     * Returns the permalink of the currently opened date archive.
     *
     * @return string The permalink of the currently opened date archive.
     */
    protected function get_non_cached_date_archive_permalink()
    {
    }
    /**
     * Counts the total amount of queried terms.
     *
     * @codeCoverageIgnore This relies too much on WordPress dependencies.
     *
     * @return int The amoumt of queried terms.
     */
    protected function count_queried_terms()
    {
    }
  }
  /**
   * A helper object for dates.
   */
  class Date_Helper
  {
    /**
     * Convert given date string to the W3C format.
     *
     * If $translate is true then the given date and format string will
     * be passed to date_i18n() for translation.
     *
     * @param string $date      Date string to convert.
     * @param bool   $translate Whether the return date should be translated. Default false.
     *
     * @return string Formatted date string.
     */
    public function mysql_date_to_w3c_format($date, $translate = false)
    {
    }
    /**
     * Formats a given date in UTC TimeZone format.
     *
     * @param string $date   String representing the date / time.
     * @param string $format The format that the passed date should be in.
     *
     * @return string The formatted date.
     */
    public function format($date, $format = \DATE_W3C)
    {
    }
    /**
     * Formats the given timestamp to the needed format.
     *
     * @param int    $timestamp The timestamp to use for the formatting.
     * @param string $format    The format that the passed date should be in.
     *
     * @return string The formatted date.
     */
    public function format_timestamp($timestamp, $format = \DATE_W3C)
    {
    }
    /**
     * Formats a given date in UTC TimeZone format and translate it to the set language.
     *
     * @param string $date   String representing the date / time.
     * @param string $format The format that the passed date should be in.
     *
     * @return string The formatted and translated date.
     */
    public function format_translated($date, $format = \DATE_W3C)
    {
    }
    /**
     * Returns the current time measured in the number of seconds since the Unix Epoch (January 1 1970 00:00:00 GMT).
     *
     * @return int The current time measured in the number of seconds since the Unix Epoch (January 1 1970 00:00:00 GMT).
     */
    public function current_time()
    {
    }
    /**
     * Check if a string is a valid datetime.
     *
     * @param string $datetime String input to check as valid input for DateTime class.
     *
     * @return bool True when datetime is valid.
     */
    public function is_valid_datetime($datetime)
    {
    }
  }
  /**
   * A helper object for site environment.
   */
  class Environment_Helper
  {
    /**
     * Determines if the site is running on production.
     *
     * @return bool True if WordPress is currently running on production, false for all other environments.
     */
    public function is_production_mode()
    {
    }
    /**
     * Determines on which environment WordPress is running.
     *
     * @return string The current WordPress environment.
     */
    public function get_wp_environment()
    {
    }
  }
  /**
   * A helper to determine the status of ftc and front-end related configuration.
   */
  class First_Time_Configuration_Notice_Helper
  {
    /**
     * The options' helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    private $indexing_helper;
    /**
     * Whether we show the alternate mesage.
     *
     * @var bool
     */
    private $show_alternate_message;
    /**
     * First_Time_Configuration_Notice_Integration constructor.
     *
     * @param Options_Helper  $options_helper  The options helper.
     * @param Indexing_Helper $indexing_helper The indexing helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper)
    {
    }
    /**
     * Determines whether and where the "First-time SEO Configuration" admin notice should be displayed.
     *
     * @return bool Whether the "First-time SEO Configuration" admin notice should be displayed.
     */
    public function should_display_first_time_configuration_notice()
    {
    }
    /**
     * Gets the first time configuration title based on the show_alternate_message boolean
     *
     * @return string
     */
    public function get_first_time_configuration_title()
    {
    }
    /**
     * Determines if the first time configuration is completely finished.
     *
     * @return bool
     */
    public function first_time_configuration_not_finished()
    {
    }
    /**
     * Whether the user can do the first-time configuration.
     *
     * @return bool Whether the current user can do the first-time configuration.
     */
    private function user_can_do_first_time_configuration()
    {
    }
    /**
     * Whether the user is currently visiting one of our admin pages or the WordPress dashboard.
     *
     * @return bool Whether the current page is a Yoast SEO admin page
     */
    private function on_wpseo_admin_page_or_dashboard()
    {
    }
    /**
     * Whether all steps of the first-time configuration have been finished.
     *
     * @return bool Whether the first-time configuration has been finished.
     */
    private function is_first_time_configuration_finished()
    {
    }
    /**
     * Whether the site representation name and logo have been set.
     *
     * @return bool  Whether the site representation name and logo have been set.
     */
    private function are_site_representation_name_and_logo_set()
    {
    }
    /**
     * Getter for the show alternate message boolean.
     *
     * @return bool
     */
    public function should_show_alternate_message()
    {
    }
  }
  /**
   * A helper object for the home URL.
   */
  class Home_Url_Helper
  {
    /**
     * The home url.
     *
     * @var string
     */
    protected static $home_url;
    /**
     * The parsed home url.
     *
     * @var array
     */
    protected static $parsed_home_url;
    /**
     * Retrieves the home url.
     *
     * @return string The home url.
     */
    public function get()
    {
    }
    /**
     * Retrieves the home url that has been parsed.
     *
     * @return array The parsed url.
     */
    public function get_parsed()
    {
    }
  }
  /**
   * A helper object for images.
   */
  class Image_Helper
  {
    /**
     * Image types that are supported by Open Graph.
     *
     * @var array
     */
    protected static $valid_image_types = ['image/jpeg', 'image/gif', 'image/png', 'image/webp'];
    /**
     * Image extensions that are supported by Open Graph.
     *
     * @var array
     */
    protected static $valid_image_extensions = ['jpeg', 'jpg', 'gif', 'png', 'webp'];
    /**
     * Represents the indexables repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Represents the SEO Links repository.
     *
     * @var SEO_Links_Repository
     */
    protected $seo_links_repository;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    private $url_helper;
    /**
     * Image_Helper constructor.
     *
     * @param Indexable_Repository $indexable_repository The indexable repository.
     * @param SEO_Links_Repository $seo_links_repository The SEO Links repository.
     * @param Options_Helper       $options              The options helper.
     * @param Url_Helper           $url_helper           The URL helper.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository, \Yoast\WP\SEO\Repositories\SEO_Links_Repository $seo_links_repository, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Url_Helper $url_helper)
    {
    }
    /**
     * Determines whether or not the wanted attachment is considered valid.
     *
     * @param int $attachment_id The attachment ID to get the attachment by.
     *
     * @return bool Whether or not the attachment is valid.
     */
    public function is_valid_attachment($attachment_id)
    {
    }
    /**
     * Checks if the given extension is a valid extension
     *
     * @param string $image_extension The image extension.
     *
     * @return bool True when valid.
     */
    public function is_extension_valid($image_extension)
    {
    }
    /**
     * Determines whether the passed mime type is a valid image type.
     *
     * @param string $mime_type The detected mime type.
     *
     * @return bool Whether or not the attachment is a valid image type.
     */
    public function is_valid_image_type($mime_type)
    {
    }
    /**
     * Retrieves the image source for an attachment.
     *
     * @param int    $attachment_id The attachment.
     * @param string $image_size    The image size to retrieve.
     *
     * @return string The image url or an empty string when not found.
     */
    public function get_attachment_image_source($attachment_id, $image_size = 'full')
    {
    }
    /**
     * Retrieves the ID of the featured image.
     *
     * @param int $post_id The post id to get featured image id for.
     *
     * @return int|bool ID when found, false when not.
     */
    public function get_featured_image_id($post_id)
    {
    }
    /**
     * Gets the image url from the content.
     *
     * @param int $post_id The post id to extract the images from.
     *
     * @return string The image url or an empty string when not found.
     */
    public function get_post_content_image($post_id)
    {
    }
    /**
     * Gets the first image url of a gallery.
     *
     * @param int $post_id Post ID to use.
     *
     * @return string The image url or an empty string when not found.
     */
    public function get_gallery_image($post_id)
    {
    }
    /**
     * Gets the image url from the term content.
     *
     * @param int $term_id The term id to extract the images from.
     *
     * @return string The image url or an empty string when not found.
     */
    public function get_term_content_image($term_id)
    {
    }
    /**
     * Retrieves the caption for an attachment.
     *
     * @param int $attachment_id Attachment ID.
     *
     * @return string The caption when found, empty string when no caption is found.
     */
    public function get_caption($attachment_id)
    {
    }
    /**
     * Retrieves the attachment metadata.
     *
     * @param int $attachment_id Attachment ID.
     *
     * @return array The metadata, empty array when no metadata is found.
     */
    public function get_metadata($attachment_id)
    {
    }
    /**
     * Retrieves the attachment image url.
     *
     * @param int    $attachment_id Attachment ID.
     * @param string $size          The size to get.
     *
     * @return string The url when found, empty string otherwise.
     */
    public function get_attachment_image_url($attachment_id, $size)
    {
    }
    /**
     * Find the right version of an image based on size.
     *
     * @codeCoverageIgnore - We have to write test when this method contains own code.
     *
     * @param int    $attachment_id Attachment ID.
     * @param string $size          Size name.
     *
     * @return array|false Returns an array with image data on success, false on failure.
     */
    public function get_image($attachment_id, $size)
    {
    }
    /**
     * Retrieves the best attachment variation for the given attachment.
     *
     * @codeCoverageIgnore - We have to write test when this method contains own code.
     *
     * @param int $attachment_id The attachment id.
     *
     * @return bool|string The attachment url or false when no variations found.
     */
    public function get_best_attachment_variation($attachment_id)
    {
    }
    /**
     * Find an attachment ID for a given URL.
     *
     * @param string $url             The URL to find the attachment for.
     * @param bool   $use_link_table  Whether the SEO Links table will be used to retrieve the id.
     *
     * @return int The found attachment ID, or 0 if none was found.
     */
    public function get_attachment_by_url($url, $use_link_table = true)
    {
    }
    /**
     * Retrieves an attachment ID for an image uploaded in the settings.
     *
     * Due to self::get_attachment_by_url returning 0 instead of false.
     * 0 is also a possibility when no ID is available.
     *
     * @codeCoverageIgnore - We have to write test when this method contains own code.
     *
     * @param string $setting The setting the image is stored in.
     *
     * @return int|bool The attachment id, or false or 0 if no ID is available.
     */
    public function get_attachment_id_from_settings($setting)
    {
    }
    /**
     * Based on and image ID return array with the best variation of that image. If it's not saved to the DB,  save it to an option.
     *
     * @param string $setting The setting name. Should be company or person.
     *
     * @return array|bool Array with image details when the image is found, boolean when it's not found.
     */
    public function get_attachment_meta_from_settings($setting)
    {
    }
    /**
     * Retrieves the first usable content image for a post.
     *
     * @codeCoverageIgnore - We have to write test when this method contains own code.
     *
     * @param int $post_id The post id to extract the images from.
     *
     * @return string|null
     */
    protected function get_first_usable_content_image_for_post($post_id)
    {
    }
    /**
     * Gets the term's first usable content image. Null if none is available.
     *
     * @codeCoverageIgnore - We have to write test when this method contains own code.
     *
     * @param int $term_id The term id.
     *
     * @return string|null The image URL.
     */
    protected function get_first_content_image_for_term($term_id)
    {
    }
  }
  /**
   * The Import Cursor Helper.
   */
  class Import_Cursor_Helper
  {
    /**
     * The Options_Helper.
     *
     * @var Options_Helper
     */
    public $options;
    /**
     * Class constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Returns the stored cursor value.
     *
     * @param string $cursor_id     The cursor id.
     * @param mixed  $default_value The default value if no cursor has been set yet.
     *
     * @return int The stored cursor value.
     */
    public function get_cursor($cursor_id, $default_value = 0)
    {
    }
    /**
     * Stores the current cursor value.
     *
     * @param string $cursor_id        The cursor id.
     * @param int    $last_imported_id The id of the lastly imported entry.
     *
     * @return void
     */
    public function set_cursor($cursor_id, $last_imported_id)
    {
    }
  }
  /**
   * The Import Helper.
   */
  class Import_Helper
  {
    /**
     * Flattens a multidimensional array of settings. Recursive.
     *
     * @param array  $array_to_flatten The array to be flattened.
     * @param string $key_prefix       The key to be used as a prefix.
     *
     * @return array The flattened array.
     */
    public function flatten_settings($array_to_flatten, $key_prefix = '')
    {
    }
  }
  /**
   * A helper object for indexables.
   */
  class Indexable_Helper
  {
    /**
     * Represents the indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * Represents the options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Represents the environment helper.
     *
     * @var Environment_Helper
     */
    protected $environment_helper;
    /**
     * Represents the indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * Default values of certain columns.
     *
     * @var array
     */
    protected $default_values = ['title' => ['default_value' => null], 'description' => ['default_value' => null], 'open_graph_title' => ['default_value' => null], 'open_graph_description' => ['default_value' => null], 'twitter_title' => ['default_value' => null], 'twitter_description' => ['default_value' => null], 'canonical' => ['default_value' => null], 'primary_focus_keyword' => ['default_value' => null], 'is_robots_noindex' => ['default_value' => null], 'is_robots_nofollow' => ['default_value' => false], 'is_robots_noarchive' => ['default_value' => null], 'is_robots_noimageindex' => ['default_value' => null], 'is_robots_nosnippet' => ['default_value' => null]];
    /**
     * Indexable_Helper constructor.
     *
     * @param Options_Helper     $options_helper     The options helper.
     * @param Environment_Helper $environment_helper The environment helper.
     * @param Indexing_Helper    $indexing_helper    The indexing helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Environment_Helper $environment_helper, \Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper)
    {
    }
    /**
     * Sets the indexable repository. Done to avoid circular dependencies.
     *
     * @required
     *
     * @param Indexable_Repository $repository The indexable repository.
     */
    public function set_indexable_repository(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository)
    {
    }
    /**
     * Returns the page type of an indexable.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return string|false The page type. False if it could not be determined.
     */
    public function get_page_type_for_indexable($indexable)
    {
    }
    /**
     * Resets the permalinks of the indexables.
     *
     * @param string|null $type    The type of the indexable.
     * @param string|null $subtype The subtype. Can be null.
     * @param string      $reason  The reason that the permalink has been changed.
     */
    public function reset_permalink_indexables($type = null, $subtype = null, $reason = \Yoast\WP\SEO\Config\Indexing_Reasons::REASON_PERMALINK_SETTINGS)
    {
    }
    /**
     * Determines whether indexing indexables is appropriate at this time.
     *
     * @return bool Whether the indexables should be indexed.
     */
    public function should_index_indexables()
    {
    }
    /**
     * Returns whether or not dynamic permalinks should be used.
     *
     * @return bool Whether or not the dynamic permalinks should be used.
     */
    public function dynamic_permalinks_enabled()
    {
    }
    /**
     * Sets a boolean to indicate that the indexing of the indexables has completed.
     *
     * @return void
     */
    public function finish_indexing()
    {
    }
    /**
     * Checks whether the indexable has default values in given fields.
     *
     * @param Indexable $indexable The Yoast indexable that we're checking.
     * @param array     $fields    The Yoast indexable fields that we're checking against.
     *
     * @return bool Whether the indexable has default values.
     */
    public function check_if_default_indexable($indexable, $fields)
    {
    }
    /**
     * Checks if an indexable field contains the default value.
     *
     * @param Indexable $indexable The Yoast indexable that we're checking.
     * @param string    $field     The field that we're checking.
     *
     * @return bool True if default value.
     */
    public function check_if_default_field($indexable, $field)
    {
    }
  }
  /**
   * A helper object to map indexable data to postmeta.
   */
  class Indexable_To_Postmeta_Helper
  {
    /**
     * The Meta helper.
     *
     * @var Meta_Helper
     */
    public $meta;
    /**
     * The map of yoast to post meta.
     *
     * @var array
     */
    protected $yoast_to_postmeta = ['title' => ['post_meta_key' => 'title', 'map_method' => 'simple_map'], 'description' => ['post_meta_key' => 'metadesc', 'map_method' => 'simple_map'], 'open_graph_title' => ['post_meta_key' => 'opengraph-title', 'map_method' => 'simple_map'], 'open_graph_description' => ['post_meta_key' => 'opengraph-description', 'map_method' => 'simple_map'], 'twitter_title' => ['post_meta_key' => 'twitter-title', 'map_method' => 'simple_map'], 'twitter_description' => ['post_meta_key' => 'twitter-description', 'map_method' => 'simple_map'], 'canonical' => ['post_meta_key' => 'canonical', 'map_method' => 'simple_map'], 'primary_focus_keyword' => ['post_meta_key' => 'focuskw', 'map_method' => 'simple_map'], 'open_graph_image' => ['post_meta_key' => 'opengraph-image', 'map_method' => 'social_image_map'], 'open_graph_image_id' => ['post_meta_key' => 'opengraph-image-id', 'map_method' => 'social_image_map'], 'twitter_image' => ['post_meta_key' => 'twitter-image', 'map_method' => 'social_image_map'], 'twitter_image_id' => ['post_meta_key' => 'twitter-image-id', 'map_method' => 'social_image_map'], 'is_robots_noindex' => ['post_meta_key' => 'meta-robots-noindex', 'map_method' => 'noindex_map'], 'is_robots_nofollow' => ['post_meta_key' => 'meta-robots-nofollow', 'map_method' => 'nofollow_map'], 'meta_robots_adv' => ['post_meta_key' => 'meta-robots-adv', 'map_method' => 'robots_adv_map']];
    /**
     * Indexable_To_Postmeta_Helper constructor.
     *
     * @param Meta_Helper $meta The Meta helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Meta_Helper $meta)
    {
    }
    /**
     * Creates postmeta from a Yoast indexable.
     *
     * @param Indexable $indexable The Yoast indexable.
     *
     * @return void
     */
    public function map_to_postmeta($indexable)
    {
    }
    /**
     * Uses a simple set_value for non-empty data.
     *
     * @param Indexable $indexable        The Yoast indexable.
     * @param string    $post_meta_key    The post_meta key that will be populated.
     * @param string    $indexable_column The indexable data that will be mapped to post_meta.
     *
     * @return void
     */
    public function simple_map($indexable, $post_meta_key, $indexable_column)
    {
    }
    /**
     * Map social image data only if social image is explicitly set.
     *
     * @param Indexable $indexable        The Yoast indexable.
     * @param string    $post_meta_key    The post_meta key that will be populated.
     * @param string    $indexable_column The indexable data that will be mapped to post_meta.
     *
     * @return void
     */
    public function social_image_map($indexable, $post_meta_key, $indexable_column)
    {
    }
    /**
     * Deletes the noindex post_meta key if no noindex in the indexable. Populates the post_meta key appropriately if there is noindex in the indexable.
     *
     * @param Indexable $indexable     The Yoast indexable.
     * @param string    $post_meta_key The post_meta key that will be populated.
     *
     * @return void
     */
    public function noindex_map($indexable, $post_meta_key)
    {
    }
    /**
     * Deletes the nofollow post_meta key if no nofollow in the indexable or if nofollow is false. Populates the post_meta key appropriately if there is a true nofollow in the indexable.
     *
     * @param Indexable $indexable     The Yoast indexable.
     * @param string    $post_meta_key The post_meta key that will be populated.
     *
     * @return void
     */
    public function nofollow_map($indexable, $post_meta_key)
    {
    }
    /**
     * Deletes the nofollow post_meta key if no nofollow in the indexable or if nofollow is false. Populates the post_meta key appropriately if there is a true nofollow in the indexable.
     *
     * @param Indexable $indexable     The Yoast indexable.
     * @param string    $post_meta_key The post_meta key that will be populated.
     *
     * @return void
     */
    public function robots_adv_map($indexable, $post_meta_key)
    {
    }
  }
  /**
   * A helper object for indexing.
   */
  class Indexing_Helper
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The date helper.
     *
     * @var Date_Helper
     */
    protected $date_helper;
    /**
     * The notification center.
     *
     * @var Yoast_Notification_Center
     */
    protected $notification_center;
    /**
     * The indexation actions.
     *
     * @var Indexation_Action_Interface[]|Limited_Indexing_Action_Interface[]
     */
    protected $indexing_actions;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Indexing_Helper constructor.
     *
     * @param Options_Helper            $options_helper      The options helper.
     * @param Date_Helper               $date_helper         The date helper.
     * @param Yoast_Notification_Center $notification_center The notification center.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Date_Helper $date_helper, \Yoast_Notification_Center $notification_center)
    {
    }
    /**
     * Sets the actions.
     *
     * @required
     *
     * @param Indexable_Post_Indexation_Action              $post_indexation              The post indexing action.
     * @param Indexable_Term_Indexation_Action              $term_indexation              The term indexing action.
     * @param Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation The posttype indexing action.
     * @param Indexable_General_Indexation_Action           $general_indexation           The general indexing (homepage etc) action.
     * @param Post_Link_Indexing_Action                     $post_link_indexing_action    The post crosslink indexing action.
     * @param Term_Link_Indexing_Action                     $term_link_indexing_action    The term crossling indexing action.
     */
    public function set_indexing_actions(\Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Indexation_Action $post_indexation, \Yoast\WP\SEO\Actions\Indexing\Indexable_Term_Indexation_Action $term_indexation, \Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation, \Yoast\WP\SEO\Actions\Indexing\Indexable_General_Indexation_Action $general_indexation, \Yoast\WP\SEO\Actions\Indexing\Post_Link_Indexing_Action $post_link_indexing_action, \Yoast\WP\SEO\Actions\Indexing\Term_Link_Indexing_Action $term_link_indexing_action)
    {
    }
    /**
     * Sets the indexable repository for the indexing helper class.
     *
     * @required
     *
     * @param Indexable_Repository $indexable_repository The indexable repository.
     */
    public function set_indexable_repository(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Prepares the indexing process by setting several database options and removing the indexing notification.
     *
     * @return void
     */
    public function prepare()
    {
    }
    /**
     * Sets several database options when the indexing process is finished.
     *
     * @return void
     */
    public function complete()
    {
    }
    /**
     * Sets appropriate flags when the indexing process fails.
     *
     * @return void
     */
    public function indexing_failed()
    {
    }
    /**
     * Sets the indexing reason.
     *
     * @param string $reason The indexing reason.
     *
     * @return void
     */
    public function set_reason($reason)
    {
    }
    /**
     * Removes any pre-existing notification, so that a new notification (with a possible new reason) can be added.
     */
    protected function remove_indexing_notification()
    {
    }
    /**
     * Determines whether an indexing reason has been set in the options.
     *
     * @return bool Whether an indexing reason has been set in the options.
     */
    public function has_reason()
    {
    }
    /**
     * Returns the indexing reason. The reason why the site-wide indexing process should be run.
     *
     * @return string The indexing reason, defaults to the empty string if no reason has been set.
     */
    public function get_reason()
    {
    }
    /**
     * Sets the start time when the indexing process has started but not completed.
     *
     * @param int|bool $timestamp The start time when the indexing process has started but not completed, false otherwise.
     *
     * @return void
     */
    public function set_started($timestamp)
    {
    }
    /**
     * Gets the start time when the indexing process has started but not completed.
     *
     * @return int|bool The start time when the indexing process has started but not completed, false otherwise.
     */
    public function get_started()
    {
    }
    /**
     * Sets a boolean that indicates whether or not a site still has to be indexed for the first time.
     *
     * @param bool $is_first_time_indexing Whether or not a site still has to be indexed for the first time.
     *
     * @return void
     */
    public function set_first_time($is_first_time_indexing)
    {
    }
    /**
     * Gets a boolean that indicates whether or not the site still has to be indexed for the first time.
     *
     * @return bool Whether the site still has to be indexed for the first time.
     */
    public function is_initial_indexing()
    {
    }
    /**
     * Gets a boolean that indicates whether or not the indexing of the indexables has completed.
     *
     * @return bool Whether the indexing of the indexables has completed.
     */
    public function is_finished_indexables_indexing()
    {
    }
    /**
     * Returns the total number of unindexed objects.
     *
     * @return int The total number of unindexed objects.
     */
    public function get_unindexed_count()
    {
    }
    /**
     * Returns the amount of un-indexed posts expressed in percentage, which will be needed to set a threshold.
     *
     * @param int $unindexed_count The number of unindexed objects.
     *
     * @return int The amount of unindexed posts expressed in percentage.
     */
    public function get_unindexed_percentage($unindexed_count)
    {
    }
    /**
     * Returns whether the SEO optimization button should show.
     *
     * @return bool Whether the SEO optimization button should show.
     */
    public function should_show_optimization_button()
    {
    }
    /**
     * Returns the total number of unindexed objects and applies a filter for third party integrations.
     *
     * @return int The total number of unindexed objects.
     */
    public function get_filtered_unindexed_count()
    {
    }
    /**
     * Returns a limited number of unindexed objects.
     *
     * @param int $limit Limit the number of unindexed objects that are counted.
     *
     * @return int The total number of unindexed objects.
     */
    public function get_limited_unindexed_count($limit)
    {
    }
    /**
     * Returns the total number of unindexed objects and applies a filter for third party integrations.
     *
     * @param int $limit Limit the number of unindexed objects that are counted.
     *
     * @return int The total number of unindexed objects.
     */
    public function get_limited_filtered_unindexed_count($limit)
    {
    }
  }
  /**
   * A helper object for language features.
   */
  class Language_Helper
  {
    /**
     * The languages with inclusive language analysis support.
     *
     * @var string[]
     */
    public static $languages_with_inclusive_language_support = ['en'];
    /**
     * Checks whether word form recognition is active for the used language.
     *
     * @param string $language The used language.
     *
     * @return bool Whether word form recognition is active for the used language.
     */
    public function is_word_form_recognition_active($language)
    {
    }
    /**
     * Checks whether the given language has function word support.
     * (E.g. function words are used or filtered out for this language when doing some SEO and readability assessments).
     *
     * @param string $language The language to check.
     *
     * @return bool Whether the language has function word support.
     */
    public function has_function_word_support($language)
    {
    }
    /**
     * Checks whether the given language has inclusive language support.
     *
     * @param string $language The language to check if inclusive language is supported.
     *
     * @return bool Whether the language has inclusive language support.
     */
    public function has_inclusive_language_support($language)
    {
    }
    /**
     * Checks whether we have a specific researcher for the current locale and returns that language.
     * If there is no researcher for the current locale, returns default as the researcher.
     *
     * @return string The language to use to select a researcher.
     */
    public function get_researcher_language()
    {
    }
    /**
     * Returns The site language code without region
     * (e.g. 'en' for 'en_US' or 'en_GB').
     *
     * @return string The site language code without region.
     */
    public function get_language()
    {
    }
  }
  /**
   * A helper object for meta.
   */
  class Meta_Helper
  {
    /**
     * Get a custom post meta value.
     *
     * Returns the default value if the meta value has not been set.
     *
     * {@internal Unfortunately there isn't a filter available to hook into before returning
     *            the results for get_post_meta(), get_post_custom() and the likes. That
     *            would have been the preferred solution.}}
     *
     * @codeCoverageIgnore We have to write test when this method contains own code.
     *
     * @param string $key    Internal key of the value to get (without prefix).
     * @param int    $postid Post ID of the post to get the value for.
     *
     * @return string All 'normal' values returned from get_post_meta() are strings.
     *                Objects and arrays are possible, but not used by this plugin
     *                and therefore discarted (except when the special 'serialized' field def
     *                value is set to true - only used by add-on plugins for now).
     *                Will return the default value if no value was found.
     *                Will return empty string if no default was found (not one of our keys) or
     *                if the post does not exist.
     */
    public function get_value($key, $postid = 0)
    {
    }
    /**
     * Retrieve a taxonomy term's meta value(s).
     *
     * @param mixed       $term     Term to get the meta value for
     *                              either (string) term name, (int) term id or (object) term.
     * @param string      $taxonomy Name of the taxonomy to which the term is attached.
     * @param string|null $meta     Optional. Meta value to get (without prefix).
     *
     * @return mixed|bool Value for the $meta if one is given, might be the default.
     *                    If no meta is given, an array of all the meta data for the term.
     *                    False if the term does not exist or the $meta provided is invalid.
     */
    public function get_term_value($term, $taxonomy, $meta = null)
    {
    }
    /**
     * Set a custom post meta value.
     *
     * @param string $key        Internal key of the value to set (without prefix).
     * @param mixed  $meta_value The value to set the meta value to.
     * @param int    $post_id    Post ID of the post to set the value for.
     *
     * @return bool Whether the value was changed.
     */
    public function set_value($key, $meta_value, $post_id)
    {
    }
    /**
     * Deletes a meta value for a post.
     *
     * @param string $key     The internal key of the meta value to change (without prefix).
     * @param int    $post_id The ID of the post to delete the meta for.
     *
     * @return bool Whether the delete was successful or not.
     */
    public function delete($key, $post_id)
    {
    }
  }
  /**
   * A helper object for notifications.
   */
  class Notification_Helper
  {
    /**
     * Restores a notification (wrapper function).
     *
     * @codeCoverageIgnore
     *
     * @param Yoast_Notification $notification The notification to restore.
     *
     * @return bool True if restored, false otherwise.
     */
    public function restore_notification(\Yoast_Notification $notification)
    {
    }
  }
}

namespace Yoast\WP\SEO\Helpers\Open_Graph {
  /**
   * A helper object for Open Graph images.
   */
  class Image_Helper
  {
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    private $url;
    /**
     * The base image helper.
     *
     * @var Base_Image_Helper
     */
    private $image;
    /**
     * Image_Helper constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Url_Helper        $url   The url helper.
     * @param Base_Image_Helper $image The image helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Url_Helper $url, \Yoast\WP\SEO\Helpers\Image_Helper $image)
    {
    }
    /**
     * Determines whether the passed URL is considered valid.
     *
     * @param array $image The image array.
     *
     * @return bool Whether or not the URL is a valid image.
     */
    public function is_image_url_valid(array $image)
    {
    }
    /**
     * Retrieves the overridden image size value.
     *
     * @return string|null The image size when overriden by filter or null when not.
     */
    public function get_override_image_size()
    {
    }
    /**
     * Retrieves the image data by a given attachment id.
     *
     * @param int $attachment_id The attachment id.
     *
     * @return array|false The image data when found, `false` when not.
     */
    public function get_image_by_id($attachment_id)
    {
    }
  }
  /**
   * A helper object for the filtering of values.
   */
  class Values_Helper
  {
    /**
     * Filters the Open Graph title.
     *
     * @param string $title          The default title.
     * @param string $object_type    The object type.
     * @param string $object_subtype The object subtype.
     *
     * @return string The open graph title.
     */
    public function get_open_graph_title($title, $object_type, $object_subtype)
    {
    }
    /**
     * Filters the Open Graph description.
     *
     * @param string $description    The default description.
     * @param string $object_type    The object type.
     * @param string $object_subtype The object subtype.
     *
     * @return string The open graph description.
     */
    public function get_open_graph_description($description, $object_type, $object_subtype)
    {
    }
    /**
     * Filters the Open Graph image ID.
     *
     * @param int    $image_id       The default image ID.
     * @param string $object_type    The object type.
     * @param string $object_subtype The object subtype.
     *
     * @return string The open graph image ID.
     */
    public function get_open_graph_image_id($image_id, $object_type, $object_subtype)
    {
    }
    /**
     * Filters the Open Graph image URL.
     *
     * @param string $image          The default image URL.
     * @param string $object_type    The object type.
     * @param string $object_subtype The object subtype.
     *
     * @return string The open graph image URL.
     */
    public function get_open_graph_image($image, $object_type, $object_subtype)
    {
    }
  }
}

namespace Yoast\WP\SEO\Helpers {
  /**
   * A helper object for options.
   */
  class Options_Helper
  {
    /**
     * Retrieves a single field from any option for the SEO plugin. Keys are always unique.
     *
     * @codeCoverageIgnore We have to write test when this method contains own code.
     *
     * @param string $key           The key it should return.
     * @param mixed  $default_value The default value that should be returned if the key isn't set.
     *
     * @return mixed|null Returns value if found, $default_value if not.
     */
    public function get($key, $default_value = null)
    {
    }
    /**
     * Sets a single field to the options.
     *
     * @param string $key   The key to set.
     * @param mixed  $value The value to set.
     *
     * @return mixed|null Returns value if found.
     */
    public function set($key, $value)
    {
    }
    /**
     * Get a specific default value for an option.
     *
     * @param string $option_name The option for which you want to retrieve a default.
     * @param string $key         The key within the option who's default you want.
     *
     * @return mixed The default value.
     */
    public function get_default($option_name, $key)
    {
    }
    /**
     * Retrieves the title separator.
     *
     * @return string The title separator.
     */
    public function get_title_separator()
    {
    }
    /**
     * Retrieves a default value from the option titles.
     *
     * @param string $option_titles_key The key of the option title you wish to get.
     *
     * @return string The option title.
     */
    public function get_title_default($option_titles_key)
    {
    }
    /**
     * Retrieves the default option titles.
     *
     * @codeCoverageIgnore We have to write test when this method contains own code.
     *
     * @return array The title defaults.
     */
    protected function get_title_defaults()
    {
    }
    /**
     * Get the available separator options.
     *
     * @return array
     */
    protected function get_separator_options()
    {
    }
    /**
     * Checks whether a social URL is valid, with empty strings being valid social URLs.
     *
     * @param string $url The url to be checked.
     *
     * @return bool Whether the URL is valid.
     */
    public function is_social_url_valid($url)
    {
    }
    /**
     * Checks whether a twitter id is valid, with empty strings being valid twitter id.
     *
     * @param string $twitter_id The twitter id to be checked.
     *
     * @return bool Whether the twitter id is valid.
     */
    public function is_twitter_id_valid($twitter_id)
    {
    }
  }
  /**
   * A helper object for pagination.
   *
   * Used for the canonical URL and the rel "next" and "prev" meta tags.
   */
  class Pagination_Helper
  {
    /**
     * Holds the WP rewrite wrapper instance.
     *
     * @var WP_Rewrite_Wrapper WP_Rewrite wrapper.
     */
    protected $wp_rewrite_wrapper;
    /**
     * Holds the WP query wrapper instance.
     *
     * @var WP_Query_Wrapper WP_Query wrapper.
     */
    protected $wp_query_wrapper;
    /**
     * Pagination_Helper constructor.
     *
     * @param WP_Rewrite_Wrapper $wp_rewrite_wrapper The rewrite wrapper.
     * @param WP_Query_Wrapper   $wp_query_wrapper   The query wrapper.
     */
    public function __construct(\Yoast\WP\SEO\Wrappers\WP_Rewrite_Wrapper $wp_rewrite_wrapper, \Yoast\WP\SEO\Wrappers\WP_Query_Wrapper $wp_query_wrapper)
    {
    }
    /**
     * Checks whether adjacent rel links are disabled.
     *
     * @return bool Whether adjacent rel links are disabled or not.
     */
    public function is_rel_adjacent_disabled()
    {
    }
    /**
     * Builds a paginated URL.
     *
     * @param string $url                   The un-paginated URL of the current archive.
     * @param string $page                  The page number to add on to $url for the $link tag.
     * @param bool   $add_pagination_base   Optional. Whether to add the pagination base (`page`) to the url.
     * @param string $pagination_query_name Optional. The name of the query argument that holds the current page.
     *
     * @return string The paginated URL.
     */
    public function get_paginated_url($url, $page, $add_pagination_base = true, $pagination_query_name = 'page')
    {
    }
    /**
     * Gets the number of archive pages.
     *
     * @return int The number of archive pages.
     */
    public function get_number_of_archive_pages()
    {
    }
    /**
     * Returns the current page for paged archives.
     *
     * @return int The current archive page.
     */
    public function get_current_archive_page_number()
    {
    }
    /**
     * Returns the current page for paged post types.
     *
     * @return int The current post page.
     */
    public function get_current_post_page_number()
    {
    }
    /**
     * Returns the current page number.
     *
     * @return int The current page number.
     */
    public function get_current_page_number()
    {
    }
  }
  /**
   * A helper object for permalinks.
   */
  class Permalink_Helper
  {
    /**
     * Retrieves the permalink for an indexable.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return string|null The permalink.
     */
    public function get_permalink_for_indexable($indexable)
    {
    }
  }
  /**
   * A helper object for post related things.
   */
  class Post_Helper
  {
    /**
     * Holds the String_Helper instance.
     *
     * @var String_Helper
     */
    private $string;
    /**
     * Holds the Post_Type_Helper instance.
     *
     * @var Post_Type_Helper
     */
    private $post_type;
    /**
     * Represents the indexables repository.
     *
     * @var Indexable_Repository
     */
    private $repository;
    /**
     * Post_Helper constructor.
     *
     * @codeCoverageIgnore It only sets dependencies.
     *
     * @param String_Helper    $string_helper    The string helper.
     * @param Post_Type_Helper $post_type_helper The string helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\String_Helper $string_helper, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper)
    {
    }
    /**
     * Sets the indexable repository. Done to avoid circular dependencies.
     *
     * @required
     *
     * @param Indexable_Repository $repository The indexable repository.
     */
    public function set_indexable_repository(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository)
    {
    }
    /**
     * Removes all shortcode tags from the given content.
     *
     * @codeCoverageIgnore It only wraps a WordPress function.
     *
     * @param string $content Content to remove all the shortcode tags from.
     *
     * @return string Content without shortcode tags.
     */
    public function strip_shortcodes($content)
    {
    }
    /**
     * Retrieves the post excerpt (without tags).
     *
     * @codeCoverageIgnore It only wraps another helper method.
     *
     * @param int $post_id Post ID.
     *
     * @return string Post excerpt (without tags).
     */
    public function get_the_excerpt($post_id)
    {
    }
    /**
     * Retrieves the post type of the current post.
     *
     * @codeCoverageIgnore It only wraps a WordPress function.
     *
     * @param WP_Post|null $post The post.
     *
     * @return string|false Post type on success, false on failure.
     */
    public function get_post_type($post = null)
    {
    }
    /**
     * Retrieves the post title with fallback to `No title`.
     *
     * @param int $post_id Optional. Post ID.
     *
     * @return string The post title with fallback to `No title`.
     */
    public function get_post_title_with_fallback($post_id = 0)
    {
    }
    /**
     * Retrieves post data given a post ID.
     *
     * @codeCoverageIgnore It wraps a WordPress function.
     *
     * @param int $post_id Post ID.
     *
     * @return WP_Post|null The post.
     */
    public function get_post($post_id)
    {
    }
    /**
     * Updates the has_public_posts field on attachments for a post_parent.
     *
     * An attachment is represented by their post parent when:
     * - The attachment has a post parent.
     * - The attachment inherits the post status.
     *
     * @codeCoverageIgnore It relies too much on dependencies.
     *
     * @param int $post_parent      Post ID.
     * @param int $has_public_posts Whether the parent is public.
     *
     * @return bool Whether the update was successful.
     */
    public function update_has_public_posts_on_attachments($post_parent, $has_public_posts)
    {
    }
    /**
     * Determines if the post can be indexed.
     *
     * @param int $post_id Post ID to check.
     *
     * @return bool True if the post can be indexed.
     */
    public function is_post_indexable($post_id)
    {
    }
    /**
     * Retrieves the list of excluded post statuses.
     *
     * @return array The excluded post statuses.
     */
    public function get_excluded_post_statuses()
    {
    }
    /**
     * Retrieves the list of public posts statuses.
     *
     * @return array The public post statuses.
     */
    public function get_public_post_statuses()
    {
    }
  }
  /**
   * A helper object for post types.
   */
  class Post_Type_Helper
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Post_Type_Helper constructor.
     *
     * @param Options_Helper $options_helper The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Checks if the request post type is public and indexable.
     *
     * @codeCoverageIgnore We have to write test when this method contains own code.
     *
     * @param string $post_type_name The name of the post type to lookup.
     *
     * @return bool True when post type is set to index.
     */
    public function is_indexable($post_type_name)
    {
    }
    /**
     * Checks if the request post type has the Yoast Metabox enabled.
     *
     * @param string $post_type_name The name of the post type to lookup.
     *
     * @return bool True if metabox is enabled.
     */
    public function has_metabox($post_type_name)
    {
    }
    /**
     * Returns an array with the public post types.
     *
     * @codeCoverageIgnore It only wraps a WordPress function.
     *
     * @param string $output The output type to use.
     *
     * @return array Array with all the public post_types.
     */
    public function get_public_post_types($output = 'names')
    {
    }
    /**
     * Returns an array with the accessible post types.
     *
     * An accessible post type is a post type that is public and isn't set as no-index (robots).
     *
     * @return array Array with all the accessible post_types.
     */
    public function get_accessible_post_types()
    {
    }
    /**
     * Returns an array of post types that are excluded from being indexed for the
     * indexables.
     *
     * @return array The excluded post types.
     */
    public function get_excluded_post_types_for_indexables()
    {
    }
    /**
     * Checks if the post type is excluded.
     *
     * @param string $post_type The post type to check.
     *
     * @return bool If the post type is exclude.
     */
    public function is_excluded($post_type)
    {
    }
    /**
     * Checks if the post type with the given name has an archive page.
     *
     * @param WP_Post_Type|string $post_type The name of the post type to check.
     *
     * @return bool True when the post type has an archive page.
     */
    public function has_archive($post_type)
    {
    }
    /**
     * Returns the post types that should be indexed.
     *
     * @return array The post types that should be indexed.
     */
    public function get_indexable_post_types()
    {
    }
    /**
     * Filters the post types that are included to be indexed.
     *
     * @param array $included_post_types The post types that are included to be indexed.
     *
     * @return array The filtered post types that are included to be indexed.
     */
    protected function filter_included_post_types($included_post_types)
    {
    }
    /**
     * Returns an array of complete post type objects for all indexable post types.
     *
     * @return array List of indexable post type objects.
     */
    public function get_indexable_post_type_objects()
    {
    }
  }
  /**
   * A helper object for primary terms.
   */
  class Primary_Term_Helper
  {
    /**
     * Generate the primary term taxonomies.
     *
     * @param int $post_id ID of the post.
     *
     * @return array The taxonomies.
     */
    public function get_primary_term_taxonomies($post_id)
    {
    }
    /**
     * Returns whether or not a taxonomy is hierarchical.
     *
     * @param stdClass $taxonomy Taxonomy object.
     *
     * @return bool True for hierarchical taxonomy.
     */
    protected function filter_hierarchical_taxonomies($taxonomy)
    {
    }
  }
  /**
   * A helper object for the Yoast products.
   */
  class Product_Helper
  {
    /**
     * Gets the product name.
     *
     * @return string
     */
    public function get_product_name()
    {
    }
    /**
     * Gets the product name in the head section.
     *
     * @return string
     */
    public function get_name()
    {
    }
    /**
     * Checks if the installed version is Yoast SEO Premium.
     *
     * @return bool True when is premium.
     */
    public function is_premium()
    {
    }
    /**
     * Gets the Premium version if defined, returns null otherwise.
     *
     * @return string|null The Premium version or null when premium version is not defined.
     */
    public function get_premium_version()
    {
    }
  }
  /**
   * A helper object for redirects.
   */
  class Redirect_Helper
  {
    /**
     * Wraps wp_redirect to allow testing for redirects.
     *
     * @codeCoverageIgnore It only wraps a WordPress function.
     *
     * @param string $location The path to redirect to.
     * @param int    $status   The status code to use.
     * @param string $reason   The reason for the redirect.
     */
    public function do_unsafe_redirect($location, $status = 302, $reason = 'Yoast SEO')
    {
    }
    /**
     * Wraps wp_safe_redirect to allow testing for safe redirects.
     *
     * @codeCoverageIgnore It only wraps a WordPress function.
     *
     * @param string $location The path to redirect to.
     * @param int    $status   The status code to use.
     * @param string $reason   The reason for the redirect.
     */
    public function do_safe_redirect($location, $status = 302, $reason = 'Yoast SEO')
    {
    }
    /**
     * Sets a header.
     * This is a tiny helper function to enable better testing.
     *
     * @codeCoverageIgnore It only wraps a WordPress function.
     *
     * @param string $header The header to set.
     */
    public function set_header($header)
    {
    }
    /**
     * Removes a header.
     * This is a tiny helper function to enable better testing.
     *
     * @codeCoverageIgnore It only wraps a WordPress function.
     *
     * @param string $header The header to remove.
     */
    public function remove_header($header)
    {
    }
  }
  /**
   * A helper object for the request state.
   */
  class Request_Helper
  {
    /**
     * Checks if the current request is a REST request.
     *
     * @return bool True when the current request is a REST request.
     */
    public function is_rest_request()
    {
    }
  }
  /**
   * Represents a file helper.
   */
  class Require_File_Helper
  {
    /**
     * Activates the plugin based on the given plugin file.
     *
     * @param string $path The path to the required file.
     */
    public function require_file_once($path)
    {
    }
  }
  /**
   * A helper object for the robots meta tag.
   */
  class Robots_Helper
  {
    /**
     * Holds the Post_Type_Helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * Holds the Taxonomy_Helper.
     *
     * @var Taxonomy_Helper
     */
    protected $taxonomy_helper;
    /**
     * Constructs a Score_Helper.
     *
     * @param Post_Type_Helper $post_type_helper The Post_Type_Helper.
     * @param Taxonomy_Helper  $taxonomy_helper  The Taxonomy_Helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy_helper)
    {
    }
    /**
     * Retrieves whether the Indexable is indexable.
     *
     * @param Indexable $indexable The Indexable.
     *
     * @return bool Whether the Indexable is indexable.
     */
    public function is_indexable(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Sets the robots index to noindex.
     *
     * @param array $robots The current robots value.
     *
     * @return array The altered robots string.
     */
    public function set_robots_no_index($robots)
    {
    }
  }
  /**
   * A helper object for the robots txt file.
   */
  class Robots_Txt_Helper
  {
    /**
     * Holds a list of user agents with directives.
     *
     * @var User_Agent_List
     */
    protected $robots_txt_user_agents;
    /**
     * Holds an array with absolute URLs of sitemaps.
     *
     * @var array
     */
    protected $robots_txt_sitemaps;
    /**
     * Constructor for Robots_Txt_Helper.
     */
    public function __construct()
    {
    }
    /**
     * Add a disallow rule for a specific user agent if it does not exist yet.
     *
     * @param string $user_agent The user agent to add the disallow rule to.
     * @param string $path       The path to add as a disallow rule.
     *
     * @return void
     */
    public function add_disallow($user_agent, $path)
    {
    }
    /**
     * Add an allow rule for a specific user agent if it does not exist yet.
     *
     * @param string $user_agent The user agent to add the allow rule to.
     * @param string $path       The path to add as a allow rule.
     *
     * @return void
     */
    public function add_allow($user_agent, $path)
    {
    }
    /**
     * Add sitemap to robots.txt if it does not exist yet.
     *
     * @param string $absolute_path The absolute path to the sitemap to add.
     *
     * @return void
     */
    public function add_sitemap($absolute_path)
    {
    }
    /**
     * Get all registered disallow directives per user agent.
     *
     * @return array The registered disallow directives per user agent.
     */
    public function get_disallow_directives()
    {
    }
    /**
     * Get all registered allow directives per user agent.
     *
     * @return array The registered allow directives per user agent.
     */
    public function get_allow_directives()
    {
    }
    /**
     * Get all registered sitemap rules.
     *
     * @return array The registered sitemap rules.
     */
    public function get_sitemap_rules()
    {
    }
    /**
     * Get all registered user agents
     *
     * @return array The registered user agents.
     */
    public function get_robots_txt_user_agents()
    {
    }
  }
  /**
   * A helper object for sanitization.
   */
  class Sanitization_Helper
  {
    /**
     * Emulate the WP native sanitize_text_field function in a %%variable%% safe way.
     *
     * @codeCoverageIgnore We have to write test when this method contains own code.
     *
     * @param string $value String value to sanitize.
     *
     * @return string The sanitized string.
     */
    public function sanitize_text_field($value)
    {
    }
    /**
     * Sanitize a url for saving to the database.
     * Not to be confused with the old native WP function.
     *
     * @codeCoverageIgnore We have to write test when this method contains own code.
     *
     * @param string $value             String URL value to sanitize.
     * @param array  $allowed_protocols Optional set of allowed protocols.
     *
     * @return string The sanitized URL.
     */
    public function sanitize_url($value, $allowed_protocols = ['http', 'https'])
    {
    }
  }
}

namespace Yoast\WP\SEO\Helpers\Schema {
  /**
   * Class Article_Helper.
   */
  class Article_Helper
  {
    /**
     * Determines whether a given post type should have Article schema.
     *
     * @param string|null $post_type Post type to check.
     *
     * @return bool True if it has Article schema, false if not.
     */
    public function is_article_post_type($post_type = null)
    {
    }
    /**
     * Checks whether author is supported for the passed object sub type.
     *
     * @param string $object_sub_type The sub type of the object to check author support for.
     *
     * @return bool True if author is supported for the passed object sub type.
     */
    public function is_author_supported($object_sub_type)
    {
    }
  }
  /**
   * Class HTML_Helper.
   */
  class HTML_Helper
  {
    /**
     * Sanitizes a HTML string by stripping all tags except headings, breaks, lists, links, paragraphs and formatting.
     *
     * @param string $html The original HTML.
     *
     * @return string The sanitized HTML.
     */
    public function sanitize($html)
    {
    }
    /**
     * Strips the tags in a smart way.
     *
     * @param string $html The original HTML.
     *
     * @return string The sanitized HTML.
     */
    public function smart_strip_tags($html)
    {
    }
    /**
     * Verifies that the received input is either a string or stringable object.
     *
     * @param string $html The original HTML.
     *
     * @return bool
     */
    private function is_non_empty_string_or_stringable($html)
    {
    }
  }
  /**
   * Schema utility functions.
   */
  class ID_Helper
  {
    /**
     * Retrieve a users Schema ID.
     *
     * @param int               $user_id The ID of the User you need a Schema ID for.
     * @param Meta_Tags_Context $context A value object with context variables.
     *
     * @return string The user's schema ID.
     */
    public function get_user_schema_id($user_id, $context)
    {
    }
  }
  /**
   * Class Image_Helper.
   */
  class Image_Helper
  {
    /**
     * The HTML helper.
     *
     * @var HTML_Helper
     */
    private $html;
    /**
     * The language helper.
     *
     * @var Language_Helper
     */
    private $language;
    /**
     * Represents the main image helper.
     *
     * @var Main_Image_Helper
     */
    private $image;
    /**
     * Image_Helper constructor.
     *
     * @codeCoverageIgnore It handles dependencies.
     *
     * @param HTML_Helper       $html     The HTML helper.
     * @param Language_Helper   $language The language helper.
     * @param Main_Image_Helper $image    The 'main' image helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Schema\HTML_Helper $html, \Yoast\WP\SEO\Helpers\Schema\Language_Helper $language, \Yoast\WP\SEO\Helpers\Image_Helper $image)
    {
    }
    /**
     * Find an image based on its URL and generate a Schema object for it.
     *
     * @param string $schema_id       The `@id` to use for the returned image.
     * @param string $url             The image URL to base our object on.
     * @param string $caption         An optional caption.
     * @param bool   $add_hash        Whether a hash will be added as a suffix in the @id.
     * @param bool   $use_link_table  Whether the SEO Links table will be used to retrieve the id.
     *
     * @return array Schema ImageObject array.
     */
    public function generate_from_url($schema_id, $url, $caption = '', $add_hash = false, $use_link_table = true)
    {
    }
    /**
     * Retrieve data about an image from the database and use it to generate a Schema object.
     *
     * @param string $schema_id     The `@id` to use for the returned image.
     * @param int    $attachment_id The attachment to retrieve data from.
     * @param string $caption       The caption string, if there is one.
     * @param bool   $add_hash      Whether a hash will be added as a suffix in the @id.
     *
     * @return array Schema ImageObject array.
     */
    public function generate_from_attachment_id($schema_id, $attachment_id, $caption = '', $add_hash = false)
    {
    }
    /**
     * Retrieve data about an image from the database and use it to generate a Schema object.
     *
     * @param string $schema_id       The `@id` to use for the returned image.
     * @param array  $attachment_meta The attachment metadata.
     * @param string $caption         The caption string, if there is one.
     * @param bool   $add_hash        Whether a hash will be added as a suffix in the @id.
     *
     * @return array Schema ImageObject array.
     */
    public function generate_from_attachment_meta($schema_id, $attachment_meta, $caption = '', $add_hash = false)
    {
    }
    /**
     * If we can't find $url in our database, we output a simple ImageObject.
     *
     * @param string $schema_id The `@id` to use for the returned image.
     * @param string $url       The image URL.
     * @param string $caption   A caption, if set.
     * @param bool   $add_hash  Whether a hash will be added as a suffix in the @id.
     *
     * @return array Schema ImageObject array.
     */
    public function simple_image_object($schema_id, $url, $caption = '', $add_hash = false)
    {
    }
    /**
     * Retrieves an image's caption if set, or uses the alt tag if that's set.
     *
     * @param array  $data          An ImageObject Schema array.
     * @param int    $attachment_id Attachment ID.
     * @param string $caption       The caption string, if there is one.
     *
     * @return array An imageObject with width and height set if available.
     */
    private function add_caption($data, $attachment_id, $caption = '')
    {
    }
    /**
     * Generates our bare bone ImageObject.
     *
     * @return array an empty ImageObject
     */
    private function generate_object()
    {
    }
    /**
     * Adds image's width and height.
     *
     * @param array $data          An ImageObject Schema array.
     * @param int   $attachment_id Attachment ID.
     *
     * @return array An imageObject with width and height set if available.
     */
    private function add_image_size($data, $attachment_id)
    {
    }
  }
  /**
   * Class Language_Helper.
   */
  class Language_Helper
  {
    /**
     * Adds the `inLanguage` property to a Schema piece.
     *
     * Must use one of the language codes from the IETF BCP 47 standard. The
     * language tag syntax is made of one or more subtags separated by a hyphen
     * e.g. "en", "en-US", "zh-Hant-CN".
     *
     * @param array $data The Schema piece data.
     *
     * @return array The Schema piece data with added language property
     */
    public function add_piece_language($data)
    {
    }
  }
  /**
   * Registers the Schema replace variables and exposes a method to replace variables on a Schema graph.
   */
  class Replace_Vars_Helper
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The replace vars.
     *
     * @var WPSEO_Replace_Vars
     */
    protected $replace_vars;
    /**
     * The Schema ID helper.
     *
     * @var ID_Helper
     */
    protected $id_helper;
    /**
     * The date helper.
     *
     * @var Date_Helper
     */
    protected $date_helper;
    /**
     * Replace_Vars_Helper constructor.
     *
     * @param WPSEO_Replace_Vars $replace_vars The replace vars.
     * @param ID_Helper          $id_helper    The Schema ID helper.
     * @param Date_Helper        $date_helper  The date helper.
     */
    public function __construct(\WPSEO_Replace_Vars $replace_vars, \Yoast\WP\SEO\Helpers\Schema\ID_Helper $id_helper, \Yoast\WP\SEO\Helpers\Date_Helper $date_helper)
    {
    }
    /**
     * Replaces the variables.
     *
     * @param array                  $schema_data  The Schema data.
     * @param Indexable_Presentation $presentation The indexable presentation.
     *
     * @return array The array with replaced vars.
     */
    public function replace(array $schema_data, \Yoast\WP\SEO\Presentations\Indexable_Presentation $presentation)
    {
    }
    /**
     * Registers the Schema-related replace vars.
     *
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return void
     */
    public function register_replace_vars($context)
    {
    }
    /**
     * Registers a replace var and its value.
     *
     * @param string $variable The replace variable.
     * @param string $value    The value that the variable should be replaced with.
     */
    protected function register_replacement($variable, $value)
    {
    }
    /**
     * Returns an anonymous function that in turn just returns the given value.
     *
     * @param mixed $value The value that the function should return.
     *
     * @return Closure A function that returns the given value.
     */
    protected function get_identity_function($value)
    {
    }
  }
}

namespace Yoast\WP\SEO\Helpers {
  /**
   * A helper object for score icons.
   */
  class Score_Icon_Helper
  {
    /**
     * Holds the Robots_Helper.
     *
     * @var Robots_Helper
     */
    protected $robots_helper;
    /**
     * Constructs a Score_Helper.
     *
     * @param Robots_Helper $robots_helper The Robots_Helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Robots_Helper $robots_helper)
    {
    }
    /**
     * Creates a Score_Icon_Presenter for the readability analysis.
     *
     * @param int    $score       The readability analysis score.
     * @param string $extra_class Optional. Any extra class.
     *
     * @return Score_Icon_Presenter The Score_Icon_Presenter.
     */
    public function for_readability($score, $extra_class = '')
    {
    }
    /**
     * Creates a Score_Icon_Presenter for the SEO analysis from an indexable.
     *
     * @param Indexable|false $indexable      The Indexable.
     * @param string          $extra_class    Optional. Any extra class.
     * @param string          $no_index_title Optional. Override the title when not indexable.
     *
     * @return Score_Icon_Presenter The Score_Icon_Presenter.
     */
    public function for_seo($indexable, $extra_class = '', $no_index_title = '')
    {
    }
  }
  /**
   * Helper to get shortlinks for Yoast SEO.
   */
  class Short_Link_Helper
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * Short_Link_Helper constructor.
     *
     * @param Options_Helper $options_helper The options helper.
     * @param Product_Helper $product_helper The product helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper)
    {
    }
    /**
     * Builds a URL to use in the plugin as shortlink.
     *
     * @param string $url The URL to build upon.
     *
     * @return string The final URL.
     */
    public function build($url)
    {
    }
    /**
     * Returns a version of the URL with a utm_content with the current version.
     *
     * @param string $url The URL to build upon.
     *
     * @return string The final URL.
     */
    public function get($url)
    {
    }
    /**
     * Echoes a version of the URL with a utm_content with the current version.
     *
     * @param string $url The URL to build upon.
     */
    public function show($url)
    {
    }
    /**
     * Gets the shortlink's query params.
     *
     * @return array The shortlink's query params.
     */
    public function get_query_params()
    {
    }
    /**
     * Gets the current site's PHP version, without the extra info.
     *
     * @return string The PHP version.
     */
    private function get_php_version()
    {
    }
    /**
     * Gets the current site's platform version.
     *
     * @return string The wp_version.
     */
    protected function get_platform_version()
    {
    }
    /**
     * Collects the additional data necessary for the shortlink.
     *
     * @return array The shortlink data.
     */
    protected function collect_additional_shortlink_data()
    {
    }
    /**
     * Get our software and whether it's active or not.
     *
     * @return string The software name.
     */
    protected function get_software()
    {
    }
    /**
     * Gets the number of days the plugin has been active.
     *
     * @return int The number of days the plugin is active.
     */
    protected function get_days_active()
    {
    }
  }
  /**
   * A helper object for site options.
   */
  class Site_Helper
  {
    /**
     * Retrieves the site name.
     *
     * @return string
     */
    public function get_site_name()
    {
    }
    /**
     * Checks if the current installation is a multisite and there has been a switch
     * between the set multisites.
     *
     * @return bool True when there was a switch between the multisites.
     */
    public function is_multisite_and_switched()
    {
    }
  }
  /**
   * Class Social_Profiles_Helper.
   */
  class Social_Profiles_Helper
  {
    /**
     * The fields for the person social profiles payload.
     *
     * @var array
     */
    private $person_social_profile_fields = ['facebook' => 'get_non_valid_url', 'instagram' => 'get_non_valid_url', 'linkedin' => 'get_non_valid_url', 'myspace' => 'get_non_valid_url', 'pinterest' => 'get_non_valid_url', 'soundcloud' => 'get_non_valid_url', 'tumblr' => 'get_non_valid_url', 'twitter' => 'get_non_valid_twitter', 'youtube' => 'get_non_valid_url', 'wikipedia' => 'get_non_valid_url'];
    /**
     * The fields for the organization social profiles payload.
     *
     * @var array
     */
    private $organization_social_profile_fields = ['facebook_site' => 'get_non_valid_url', 'twitter_site' => 'get_non_valid_twitter', 'other_social_urls' => 'get_non_valid_url_array'];
    /**
     * The Options_Helper instance.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Social_Profiles_Helper constructor.
     *
     * @param Options_Helper $options_helper The WPSEO options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Gets the person social profile fields supported by us.
     *
     * @return array The social profile fields.
     */
    public function get_person_social_profile_fields()
    {
    }
    /**
     * Gets the organization social profile fields supported by us.
     *
     * @return array The organization profile fields.
     */
    public function get_organization_social_profile_fields()
    {
    }
    /**
     * Gets the person social profiles stored in the database.
     *
     * @param int $person_id The id of the person.
     *
     * @return array The person's social profiles.
     */
    public function get_person_social_profiles($person_id)
    {
    }
    /**
     * Gets the organization social profiles stored in the database.
     *
     * @return array The social profiles for the organization.
     */
    public function get_organization_social_profiles()
    {
    }
    /**
     * Stores the values for the person's social profiles.
     *
     * @param int   $person_id       The id of the person to edit.
     * @param array $social_profiles The array of the person's social profiles to be set.
     *
     * @return string[] An array of field names which failed to be saved in the db.
     */
    public function set_person_social_profiles($person_id, $social_profiles)
    {
    }
    /**
     * Stores the values for the organization's social profiles.
     *
     * @param array $social_profiles An array with the social profiles values to be saved in the db.
     *
     * @return string[] An array of field names which failed to be saved in the db.
     */
    public function set_organization_social_profiles($social_profiles)
    {
    }
    /**
     * Returns a sanitized social field.
     *
     * @param string|array $social_field The social field to sanitize.
     *
     * @return string|array The sanitized social field.
     */
    protected function sanitize_social_field($social_field)
    {
    }
    /**
     * Checks if url is not valid and returns the name of the setting if it's not.
     *
     * @param string $url         The url to be validated.
     * @param string $url_setting The name of the setting to be updated with the url.
     *
     * @return array An array with the setting that the non-valid url is about to update.
     */
    protected function get_non_valid_url($url, $url_setting)
    {
    }
    /**
     * Checks if urls in an array are not valid and return the name of the setting if one of them is not, including the non-valid url's index in the array
     *
     * @param array  $urls         The urls to be validated.
     * @param string $urls_setting The name of the setting to be updated with the urls.
     *
     * @return array An array with the settings that the non-valid urls are about to update, suffixed with a dash-separated index of the positions of those settings, eg. other_social_urls-2.
     */
    protected function get_non_valid_url_array($urls, $urls_setting)
    {
    }
    /**
     * Checks if the twitter value is not valid and returns the name of the setting if it's not.
     *
     * @param array  $twitter_site    The twitter value to be validated.
     * @param string $twitter_setting The name of the twitter setting to be updated with the value.
     *
     * @return array An array with the setting that the non-valid twitter value is about to update.
     */
    protected function get_non_valid_twitter($twitter_site, $twitter_setting)
    {
    }
    /*** DEPRECATED METHODS ***/
    /**
     * Gets the person social profile fields supported by us after WP filtering.
     *
     * @deprecated 20.1
     * @codeCoverageIgnore
     *
     * @return array The supported social profile fields.
     */
    public function get_supported_person_social_profile_fields()
    {
    }
    /**
     * Checks if the current user has the capability to edit a specific user.
     *
     * @deprecated 20.2
     * @codeCoverageIgnore
     *
     * @param int $person_id The id of the person to edit.
     *
     * @return bool
     */
    public function can_edit_profile($person_id)
    {
    }
  }
  /**
   * A helper object for string operations.
   */
  class String_Helper
  {
    /**
     * Strips all HTML tags including script and style.
     *
     * @param string $text The text to strip the tags from.
     *
     * @return string The processed string.
     */
    public function strip_all_tags($text)
    {
    }
    /**
     * Standardize whitespace in a string.
     *
     * Replace line breaks, carriage returns, tabs with a space, then remove double spaces.
     *
     * @param string $text Text input to standardize.
     *
     * @return string
     */
    public function standardize_whitespace($text)
    {
    }
    /**
     * First strip out registered and enclosing shortcodes using native WordPress strip_shortcodes function.
     * Then strip out the shortcodes with a filthy regex, because people don't properly register their shortcodes.
     *
     * @param string $text Input string that might contain shortcodes.
     *
     * @return string String without shortcodes.
     */
    public function strip_shortcode($text)
    {
    }
  }
  /**
   * A helper object for terms.
   */
  class Taxonomy_Helper
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * The string helper.
     *
     * @var String_Helper
     */
    private $string;
    /**
     * Taxonomy_Helper constructor.
     *
     * @codeCoverageIgnore It only sets dependencies.
     *
     * @param Options_Helper $options       The options helper.
     * @param String_Helper  $string_helper The string helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\String_Helper $string_helper)
    {
    }
    /**
     * Checks if the requested term is indexable.
     *
     * @param string $taxonomy The taxonomy slug.
     *
     * @return bool True when taxonomy is set to index.
     */
    public function is_indexable($taxonomy)
    {
    }
    /**
     * Returns an array with the public taxonomies.
     *
     * @param string $output The output type to use.
     *
     * @return string[]|WP_Taxonomy[] Array with all the public taxonomies.
     *                                The type depends on the specified output variable.
     */
    public function get_public_taxonomies($output = 'names')
    {
    }
    /**
     * Retrieves the term description (without tags).
     *
     * @param int $term_id Term ID.
     *
     * @return string Term description (without tags).
     */
    public function get_term_description($term_id)
    {
    }
    /**
     * Retrieves the taxonomy term's meta values.
     *
     * @codeCoverageIgnore We have to write test when this method contains own code.
     *
     * @param WP_Term $term Term to get the meta value for.
     *
     * @return array|bool Array of all the meta data for the term.
     *                    False if the term does not exist or the $meta provided is invalid.
     */
    public function get_term_meta($term)
    {
    }
    /**
     * Gets the passed taxonomy's slug.
     *
     * @param string $taxonomy The name of the taxonomy.
     *
     * @return string The slug for the taxonomy. Returns the taxonomy's name if no slug could be found.
     */
    public function get_taxonomy_slug($taxonomy)
    {
    }
    /**
     * Returns an array with the custom taxonomies.
     *
     * @param string $output The output type to use.
     *
     * @return string[]|WP_Taxonomy[] Array with all the custom taxonomies.
     *                                The type depends on the specified output variable.
     */
    public function get_custom_taxonomies($output = 'names')
    {
    }
    /**
     * Returns an array of taxonomies that are excluded from being indexed for the
     * indexables.
     *
     * @return array The excluded taxonomies.
     */
    public function get_excluded_taxonomies_for_indexables()
    {
    }
    /**
     * Checks if the taxonomy is excluded.
     *
     * @param string $taxonomy The taxonomy to check.
     *
     * @return bool If the taxonomy is excluded.
     */
    public function is_excluded($taxonomy)
    {
    }
    /**
     * This builds a list of indexable taxonomies.
     *
     * @return array The indexable taxonomies.
     */
    public function get_indexable_taxonomies()
    {
    }
    /**
     * Returns an array of complete taxonomy objects for all indexable taxonomies.
     *
     * @return array List of indexable indexables objects.
     */
    public function get_indexable_taxonomy_objects()
    {
    }
  }
}

namespace Yoast\WP\SEO\Helpers\Twitter {
  /**
   * A helper object for Twitter images.
   */
  class Image_Helper
  {
    /**
     * The base image helper.
     *
     * @var Base_Image_Helper
     */
    private $image;
    /**
     * Image_Helper constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Base_Image_Helper $image The image helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Image_Helper $image)
    {
    }
    /**
     * The image size to use for Twitter.
     *
     * @return string Image size string.
     */
    public function get_image_size()
    {
    }
    /**
     * Retrieves an image url by its id.
     *
     * @codeCoverageIgnore It is a wrapper method.
     *
     * @param int $image_id The image id.
     *
     * @return string The image url.
     */
    public function get_by_id($image_id)
    {
    }
  }
}

namespace Yoast\WP\SEO\Helpers {
  /**
   * A helper object for URLs.
   */
  class Url_Helper
  {
    /**
     * Retrieve home URL with proper trailing slash.
     *
     * @param string      $path   Path relative to home URL.
     * @param string|null $scheme Scheme to apply.
     *
     * @return string Home URL with optional path, appropriately slashed if not.
     */
    public function home($path = '', $scheme = null)
    {
    }
    /**
     * Determines whether the plugin is active for the entire network.
     *
     * @return bool Whether or not the plugin is network-active.
     */
    public function is_plugin_network_active()
    {
    }
    /**
     * Retrieve network home URL if plugin is network-activated, or home url otherwise.
     *
     * @return string Home URL with optional path, appropriately slashed if not.
     */
    public function network_safe_home_url()
    {
    }
    /**
     * Check whether a url is relative.
     *
     * @param string $url URL string to check.
     *
     * @return bool True when url is relative.
     */
    public function is_relative($url)
    {
    }
    /**
     * Gets the path from the passed URL.
     *
     * @param string $url The URL to get the path from.
     *
     * @return string The path of the URL. Returns an empty string if URL parsing fails.
     */
    public function get_url_path($url)
    {
    }
    /**
     * Gets the host from the passed URL.
     *
     * @param string $url The URL to get the host from.
     *
     * @return string The host of the URL. Returns an empty string if URL parsing fails.
     */
    public function get_url_host($url)
    {
    }
    /**
     * Determines the file extension of the given url.
     *
     * @param string $url The URL.
     *
     * @return string The extension.
     */
    public function get_extension_from_url($url)
    {
    }
    /**
     * Ensures that the given url is an absolute url.
     *
     * @param string $url The url that needs to be absolute.
     *
     * @return string The absolute url.
     */
    public function ensure_absolute_url($url)
    {
    }
    /**
     * Parse the home URL setting to find the base URL for relative URLs.
     *
     * @param string|null $path Optional path string.
     *
     * @return string
     */
    public function build_absolute_url($path = null)
    {
    }
    /**
     * Returns the link type.
     *
     * @param array      $url      The URL, as parsed by wp_parse_url.
     * @param array|null $home_url Optional. The home URL, as parsed by wp_parse_url. Used to avoid reparsing the home_url.
     * @param bool       $is_image Whether or not the link is an image.
     *
     * @return string The link type.
     */
    public function get_link_type($url, $home_url = null, $is_image = false)
    {
    }
    /**
     * Recreate current URL.
     *
     * @param bool $with_request_uri Whether we want the REQUEST_URI appended.
     *
     * @return string
     */
    public function recreate_current_url($with_request_uri = true)
    {
    }
    /**
     * Parses a URL and returns its components, this wrapper function was created to support unit tests.
     *
     * @param string $parsed_url The URL to parse.
     * @return array The parsed components of the URL.
     */
    public function parse_str_params($parsed_url)
    {
    }
  }
  /**
   * A helper object for the user.
   */
  class User_Helper
  {
    /**
     * Retrieves user meta field for a user.
     *
     * @param int    $user_id User ID.
     * @param string $key     Optional. The meta key to retrieve. By default, returns data for all keys.
     * @param bool   $single  Whether to return a single value.
     *
     * @return mixed Will be an array if $single is false. Will be value of meta data field if $single is true.
     */
    public function get_meta($user_id, $key = '', $single = false)
    {
    }
    /**
     * Counts the number of posts the user has written in this post type.
     *
     * @param int          $user_id   User ID.
     * @param array|string $post_type Optional. Single post type or array of post types to count the number of posts
     *                                for. Default 'post'.
     *
     * @return int The number of posts the user has written in this post type.
     */
    public function count_posts($user_id, $post_type = 'post')
    {
    }
    /**
     * Retrieves the requested data of the author.
     *
     * @param string    $field   The user field to retrieve.
     * @param int|false $user_id User ID.
     *
     * @return string The author's field from the current author's DB object.
     */
    public function get_the_author_meta($field, $user_id)
    {
    }
    /**
     * Retrieves the archive url of the user.
     *
     * @param int|false $user_id User ID.
     *
     * @return string The author's archive url.
     */
    public function get_the_author_posts_url($user_id)
    {
    }
    /**
     * Retrieves the current user ID.
     *
     * @return int The current user's ID, or 0 if no user is logged in.
     */
    public function get_current_user_id()
    {
    }
    /**
     * Updates user meta field for a user.
     *
     * Use the $prev_value parameter to differentiate between meta fields with the
     * same key and user ID.
     *
     * If the meta field for the user does not exist, it will be added.
     *
     * @param int    $user_id    User ID.
     * @param string $meta_key   Metadata key.
     * @param mixed  $meta_value Metadata value. Must be serializable if non-scalar.
     * @param mixed  $prev_value Optional. Previous value to check before updating.
     *                           If specified, only update existing metadata entries with
     *                           this value. Otherwise, update all entries. Default empty.
     *
     * @return int|bool Meta ID if the key didn't exist, true on successful update,
     *                  false on failure or if the value passed to the function
     *                  is the same as the one that is already in the database.
     */
    public function update_meta($user_id, $meta_key, $meta_value, $prev_value = '')
    {
    }
    /**
     * Removes metadata matching criteria from a user.
     *
     * You can match based on the key, or key and value. Removing based on key and
     * value, will keep from removing duplicate metadata with the same key. It also
     * allows removing all metadata matching key, if needed.
     *
     * @param int    $user_id    User ID.
     * @param string $meta_key   Metadata name.
     * @param mixed  $meta_value Optional. Metadata value. If provided,
     *                           rows will only be removed that match the value.
     *                           Must be serializable if non-scalar. Default empty.
     *
     * @return bool True on success, false on failure.
     */
    public function delete_meta($user_id, $meta_key, $meta_value = '')
    {
    }
  }
  /**
   * A helper object for Wincher matters.
   */
  class Wincher_Helper
  {
    /**
     * Holds the Options Page helper instance.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * Options_Helper constructor.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Checks if the integration should be active for the current user.
     *
     * @return bool Whether the integration is active.
     */
    public function is_active()
    {
    }
    /**
     * Checks if the user is logged in to Wincher.
     *
     * @return bool The Wincher login status.
     */
    public function login_status()
    {
    }
    /**
     * Returns the Wincher links that can be used to localize the global admin
     * script. Mainly exists to avoid duplicating these links in multiple places
     * around the code base.
     *
     * @return string[]
     */
    public function get_admin_global_links()
    {
    }
  }
  /**
   * Represents helper methods for WooCommerce.
   */
  class Woocommerce_Helper
  {
    /**
     * Checks if WooCommerce is active.
     *
     * @return bool Is WooCommerce active.
     */
    public function is_active()
    {
    }
    /**
     * Returns the id of the set WooCommerce shop page.
     *
     * @return int The ID of the set page.
     */
    public function get_shop_page_id()
    {
    }
    /**
     * Checks if the current page is a WooCommerce shop page.
     *
     * @return bool True when the page is a shop page.
     */
    public function is_shop_page()
    {
    }
    /**
     * Checks if the current page is a WooCommerce shop page.
     *
     * @return bool True when the page is a shop page.
     */
    public function current_post_is_terms_and_conditions_page()
    {
    }
  }
  // phpcs:disable WordPress.WP.CapitalPDangit.MisspelledClassName -- It is spelled like `Wordpress_Helper` because of Yoast's naming conventions for classes, which would otherwise break dependency injection in some cases.
  /**
   * A helper object for WordPress matters.
   */
  class Wordpress_Helper
  {
    /**
     * Returns the WordPress version.
     *
     * @return string The version.
     */
    public function get_wordpress_version()
    {
    }
  }
  /**
   * A helper object for WordProof integration.
   */
  class Wordproof_Helper
  {
    /**
     * Holds the Current Page helper instance.
     *
     * @var Current_Page_Helper
     */
    protected $current_page;
    /**
     * Holds the WooCommerce helper instance.
     *
     * @var Woocommerce_Helper
     */
    protected $woocommerce;
    /**
     * Holds the Options Page helper instance.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * WordProof_Helper constructor.
     *
     * @param Current_Page_Helper $current_page The current page helper.
     * @param Woocommerce_Helper  $woocommerce  The woocommerce helper.
     * @param Options_Helper      $options      The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page, \Yoast\WP\SEO\Helpers\Woocommerce_Helper $woocommerce, \Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Remove site options after disabling the integration.
     *
     * @return bool Returns if the options are deleted
     */
    public function remove_site_options()
    {
    }
    /**
     * Returns if conditionals are met. If not, the integration should be disabled.
     *
     * @param bool $return_conditional If the conditional class name that was unmet should be returned.
     *
     * @return bool|string Returns if the integration should be disabled.
     */
    public function integration_is_disabled($return_conditional = false)
    {
    }
    /**
     * Returns if the WordProof integration toggle is turned on.
     *
     * @return bool Returns if the integration toggle is set to true if conditionals are met.
     */
    public function integration_is_active()
    {
    }
    /**
     * Return if WordProof should be active for this post editor page.
     *
     * @return bool Returns if WordProof should be active for this page.
     */
    public function is_active()
    {
    }
  }
  /**
   * A helper object for the wpdb.
   */
  class Wpdb_Helper
  {
    /**
     * The WordPress database instance.
     *
     * @var wpdb
     */
    private $wpdb;
    /**
     * Constructs a Wpdb_Helper instance.
     *
     * @param wpdb $wpdb The WordPress database instance.
     */
    public function __construct(\wpdb $wpdb)
    {
    }
    /**
     * Check if table exists.
     *
     * @param string $table The table to be checked.
     *
     * @return bool Whether the table exists.
     */
    public function table_exists($table)
    {
    }
  }
}

namespace Yoast\WP\SEO {
  /**
   * An interface for registering integrations with WordPress
   */
  interface Loadable_Interface
  {
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals();
  }
}

namespace Yoast\WP\SEO\Initializers {
  /**
   * Integration interface definition.
   *
   * An interface for registering integrations with WordPress.
   */
  interface Initializer_Interface extends \Yoast\WP\SEO\Loadable_Interface
  {
    /**
     * Runs this initializer.
     *
     * @return void
     */
    public function initialize();
  }
  /**
   * Class Crawl_Cleanup_Permalinks.
   */
  class Crawl_Cleanup_Permalinks implements \Yoast\WP\SEO\Initializers\Initializer_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    private $url_helper;
    /**
     * The Redirect_Helper.
     *
     * @var Redirect_Helper
     */
    private $redirect_helper;
    /**
     * The Crawl_Cleanup_Helper.
     *
     * @var Crawl_Cleanup_Helper
     */
    private $crawl_cleanup_helper;
    /**
     * Crawl Cleanup Basic integration constructor.
     *
     * @param Options_Helper       $options_helper      The option helper.
     * @param Url_Helper           $url_helper          The URL helper.
     * @param Redirect_Helper      $redirect_helper     The Redirect Helper.
     * @param Crawl_Cleanup_Helper $crawl_cleanup_helper The Crawl_Cleanup_Helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Url_Helper $url_helper, \Yoast\WP\SEO\Helpers\Redirect_Helper $redirect_helper, \Yoast\WP\SEO\Helpers\Crawl_Cleanup_Helper $crawl_cleanup_helper)
    {
    }
    /**
     * Initializes the integration.
     *
     * @return void
     */
    public function initialize()
    {
    }
    /**
     * Hooks our required hooks.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Redirect utm variables away.
     */
    public function utm_redirect()
    {
    }
    /**
     * Removes unneeded query variables from the URL.
     *
     * @return void
     */
    public function clean_permalinks()
    {
    }
  }
  /**
   * Disables the WP core sitemaps.
   */
  class Disable_Core_Sitemaps implements \Yoast\WP\SEO\Initializers\Initializer_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * The redirect helper.
     *
     * @var Redirect_Helper
     */
    private $redirect;
    /**
     * Sitemaps_Enabled_Conditional constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Options_Helper  $options  The options helper.
     * @param Redirect_Helper $redirect The redirect helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Redirect_Helper $redirect)
    {
    }
    /**
     * Disable the WP core XML sitemaps.
     */
    public function initialize()
    {
    }
    /**
     * Disables the core sitemaps if Yoast SEO sitemaps are enabled.
     *
     * @return void
     */
    public function maybe_disable_core_sitemaps()
    {
    }
    /**
     * Redirects requests to the WordPress sitemap to the Yoast sitemap.
     *
     * @return void
     */
    public function template_redirect()
    {
    }
    /**
     * Returns the relative sitemap URL to redirect to.
     *
     * @param string $path The original path.
     *
     * @return string|false The path to redirct to. False if no redirect should be done.
     */
    private function get_redirect_url($path)
    {
    }
  }
  /**
   * Triggers database migrations and handles results.
   */
  class Migration_Runner implements \Yoast\WP\SEO\Initializers\Initializer_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The migrations adapter.
     *
     * @var Adapter
     */
    protected $adapter;
    /**
     * The loader.
     *
     * @var Loader
     */
    protected $loader;
    /**
     * The migration status.
     *
     * @var Migration_Status
     */
    protected $migration_status;
    /**
     * Retrieves the conditionals for the migrations.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Migrations constructor.
     *
     * @param Migration_Status $migration_status The migration status.
     * @param Loader           $loader           The loader.
     * @param Adapter          $adapter          The migrations adapter.
     */
    public function __construct(\Yoast\WP\SEO\Config\Migration_Status $migration_status, \Yoast\WP\SEO\Loader $loader, \Yoast\WP\Lib\Migrations\Adapter $adapter)
    {
    }
    /**
     * Runs this initializer.
     *
     * @return void
     *
     * @throws Exception When a migration errored.
     */
    public function initialize()
    {
    }
    /**
     * Runs the free migrations.
     *
     * @return void
     *
     * @throws Exception When a migration errored.
     */
    public function run_free_migrations()
    {
    }
    /**
     * Initializes the migrations.
     *
     * @param string $name    The name of the migration.
     * @param string $version The current version.
     *
     * @return bool True on success, false on failure.
     *
     * @throws Exception If the migration fails and YOAST_ENVIRONMENT is not production.
     */
    public function run_migrations($name, $version = \WPSEO_VERSION)
    {
    }
    /**
     * Runs a single migration.
     *
     * @param string $version         The version.
     * @param string $migration_class The migration class.
     *
     * @return void
     *
     * @throws Exception If the migration failed. Caught by the run_migrations function.
     */
    protected function run_migration($version, $migration_class)
    {
    }
  }
  /**
   * Declares compatibility with the WooCommerce HPOS feature.
   */
  class Woocommerce implements \Yoast\WP\SEO\Initializers\Initializer_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Hooks into WooCommerce.
     */
    public function initialize()
    {
    }
    /**
     * Declares compatibility with the WooCommerce HPOS feature.
     */
    public function declare_custom_order_tables_compatibility()
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations {
  /**
   * An interface for registering integrations with WordPress.
   *
   * @codeCoverageIgnore It represents an interface.
   */
  interface Integration_Interface extends \Yoast\WP\SEO\Loadable_Interface
  {
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks();
  }
  /**
   * Abstract class for excluding certain post types from being indexed.
   */
  abstract class Abstract_Exclude_Post_Type implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Initializes the integration.
     */
    public function register_hooks()
    {
    }
    /**
     * Exclude the post type from the indexable table.
     *
     * @param array $excluded_post_types The excluded post types.
     *
     * @return array The excluded post types, including the specific post type.
     */
    public function exclude_post_types($excluded_post_types)
    {
    }
    /**
     * This integration is only active when the child class's conditionals are met.
     *
     * @return array|string[] The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Returns the names of the post types to be excluded.
     * To be used in the wpseo_indexable_excluded_post_types filter.
     *
     * @return array The names of the post types.
     */
    public abstract function get_post_type();
  }
}

namespace Yoast\WP\SEO\Integrations\Admin {
  /**
   * This integration registers a run of the cleanup routine whenever the plugin is activated.
   */
  class Activation_Cleanup_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * Activation_Cleanup_Integration constructor.
     *
     * @param Options_Helper $options_helper The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Registers the action to register a cleanup routine run after the plugin is activated.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers a run of the cleanup routine if this has not happened yet.
     *
     * @return void
     */
    public function register_cleanup_routine()
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations\Admin\Addon_Installation {
  /**
   * Represents the Addon installation feature.
   */
  class Dialog_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $addon_manager;
    /**
     * The addons.
     *
     * @var array
     */
    protected $owned_addons;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Addon_Installation constructor.
     *
     * @param WPSEO_Addon_Manager $addon_manager The addon manager.
     */
    public function __construct(\WPSEO_Addon_Manager $addon_manager)
    {
    }
    /**
     * Registers all hooks to WordPress.
     */
    public function register_hooks()
    {
    }
    /**
     * Starts the addon installation flow.
     *
     * @return void
     */
    public function start_addon_installation()
    {
    }
    /**
     * Throws a no owned addons warning.
     *
     * @return void
     */
    public function throw_no_owned_addons_warning()
    {
    }
    /**
     * Shows the modal.
     *
     * @return void
     */
    public function show_modal()
    {
    }
    /**
     * Retrieves a list of owned addons for the site in MyYoast.
     *
     * @return array List of owned addons with slug as key and name as value.
     */
    protected function get_owned_addons()
    {
    }
    /**
     * Bust the site information transients to have fresh data.
     *
     * @return void
     */
    protected function bust_myyoast_addon_information_cache()
    {
    }
  }
  /**
   * Represents the Addon installation feature.
   */
  class Installation_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The installation action.
     *
     * @var Addon_Install_Action
     */
    protected $addon_install_action;
    /**
     * The activation action.
     *
     * @var Addon_Activate_Action
     */
    protected $addon_activate_action;
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $addon_manager;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Addon_Installation constructor.
     *
     * @param WPSEO_Addon_Manager   $addon_manager         The addon manager.
     * @param Addon_Activate_Action $addon_activate_action The addon activate action.
     * @param Addon_Install_Action  $addon_install_action  The addon install action.
     */
    public function __construct(\WPSEO_Addon_Manager $addon_manager, \Yoast\WP\SEO\Actions\Addon_Installation\Addon_Activate_Action $addon_activate_action, \Yoast\WP\SEO\Actions\Addon_Installation\Addon_Install_Action $addon_install_action)
    {
    }
    /**
     * Registers all hooks to WordPress.
     */
    public function register_hooks()
    {
    }
    /**
     * Installs and activates missing addons.
     *
     * @return void
     */
    public function install_and_activate_addons()
    {
    }
    /**
     * Activates an addon.
     *
     * @param string $addon_slug The addon to activate.
     *
     * @return array The output of the activation.
     */
    public function activate_addon($addon_slug)
    {
    }
    /**
     * Installs an addon.
     *
     * @param string $addon_slug     The slug of the addon to install.
     * @param string $addon_download The download URL of the addon.
     *
     * @return array The installation success state and the output of the installation.
     */
    public function install_addon($addon_slug, $addon_download)
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations\Admin {
  /**
   * Admin_Columns_Cache_Integration class.
   */
  class Admin_Columns_Cache_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Cache of indexables.
     *
     * @var Indexable[]
     */
    protected $indexable_cache = [];
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * In this case: only when on an admin page.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Admin_Columns_Cache_Integration constructor.
     *
     * @param Indexable_Repository $indexable_repository The indexable repository.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Registers the appropriate actions and filters to fill the cache with
     * indexables on admin pages.
     *
     * This cache is used in showing the Yoast SEO columns on the posts overview
     * page (e.g. keyword score, incoming link count, etc.)
     */
    public function register_hooks()
    {
    }
    /**
     * Makes sure we calculate all values in one query by filling our cache beforehand.
     *
     * @param string $target Extra table navigation location which is triggered.
     */
    public function maybe_fill_cache($target)
    {
    }
    /**
     * Fills the cache of indexables for all known post IDs.
     */
    public function fill_cache()
    {
    }
    /**
     * Returns the indexable for a given post ID.
     *
     * @param int $post_id The post ID.
     *
     * @return Indexable|false The indexable. False if none could be found.
     */
    public function get_indexable($post_id)
    {
    }
    /**
     * Gets all the page IDs set to be shown on the current page.
     * This is copied over with some changes from WP_Posts_List_Table::_display_rows_hierarchical.
     *
     * @param array $pages The pages, each containing an ID and post_parent.
     *
     * @return array The IDs of all pages shown on the current page.
     */
    private function get_current_page_page_ids($pages)
    {
    }
    /**
     * Adds all child pages due to be shown on the current page to the $to_display array.
     * Copied over with some changes from WP_Posts_List_Table::_page_rows.
     *
     * @param array $children_pages The full map of child pages.
     * @param int   $count          The number of pages already processed.
     * @param int   $parent_id      The id of the parent that's currently being processed.
     * @param int   $start          The number at which the current overview starts.
     * @param int   $end            The number at which the current overview ends.
     * @param int   $to_display     The page IDs to be shown.
     * @param int   $pages_map      A map of page ID to an object with ID and post_parent.
     *
     * @return void
     */
    private function get_child_page_ids(&$children_pages, &$count, $parent_id, $start, $end, &$to_display, &$pages_map)
    {
    }
  }
  /**
   * Class Background_Indexing_Integration.
   *
   * @package Yoast\WP\SEO\Integrations\Admin
   */
  class Background_Indexing_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The post indexing action.
     *
     * @var Indexable_Post_Indexation_Action
     */
    protected $post_indexation;
    /**
     * The term indexing action.
     *
     * @var Indexable_Term_Indexation_Action
     */
    protected $term_indexation;
    /**
     * The post type archive indexing action.
     *
     * @var Indexable_Post_Type_Archive_Indexation_Action
     */
    protected $post_type_archive_indexation;
    /**
     * Represents the general indexing.
     *
     * @var Indexable_General_Indexation_Action
     */
    protected $general_indexation;
    /**
     * Represents the indexing completed action.
     *
     * @var Indexable_Indexing_Complete_Action
     */
    protected $complete_indexation_action;
    /**
     * The post link indexing action.
     *
     * @var Post_Link_Indexing_Action
     */
    protected $post_link_indexing_action;
    /**
     * The term link indexing action.
     *
     * @var Term_Link_Indexing_Action
     */
    protected $term_link_indexing_action;
    /**
     * Represents the indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * Returns the conditionals based on which this integration should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Shutdown_Indexing_Integration constructor.
     *
     * @param Indexable_Post_Indexation_Action              $post_indexation              The post indexing action.
     * @param Indexable_Term_Indexation_Action              $term_indexation              The term indexing action.
     * @param Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation The post type archive indexing action.
     * @param Indexable_General_Indexation_Action           $general_indexation           The general indexing action.
     * @param Indexable_Indexing_Complete_Action            $complete_indexation_action   The complete indexing action.
     * @param Post_Link_Indexing_Action                     $post_link_indexing_action    The post indexing action.
     * @param Term_Link_Indexing_Action                     $term_link_indexing_action    The term indexing action.
     * @param Indexing_Helper                               $indexing_helper              The indexing helper.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Indexation_Action $post_indexation, \Yoast\WP\SEO\Actions\Indexing\Indexable_Term_Indexation_Action $term_indexation, \Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation, \Yoast\WP\SEO\Actions\Indexing\Indexable_General_Indexation_Action $general_indexation, \Yoast\WP\SEO\Actions\Indexing\Indexable_Indexing_Complete_Action $complete_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Post_Link_Indexing_Action $post_link_indexing_action, \Yoast\WP\SEO\Actions\Indexing\Term_Link_Indexing_Action $term_link_indexing_action, \Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper)
    {
    }
    /**
     * Register hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Enqueues the required scripts.
     *
     * @return void
     */
    public function register_shutdown_indexing()
    {
    }
    /**
     * Run a single indexing pass of each indexing action. Intended for use as a shutdown function.
     *
     * @return void
     */
    public function index()
    {
    }
    /**
     * Retrieves the shutdown limit. This limit is the amount of indexables that is generated in the background.
     *
     * @return int The shutdown limit.
     */
    protected function get_shutdown_limit()
    {
    }
    /**
     * Determine whether background indexation should be performed.
     *
     * @param int $shutdown_limit The shutdown limit used to determine whether indexation should be run.
     *
     * @return bool Should background indexation be performed.
     */
    public function should_index_on_shutdown($shutdown_limit)
    {
    }
  }
  /**
   * Crawl_Settings_Integration class
   */
  class Crawl_Settings_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $admin_asset_manager;
    /**
     * Holds the settings + labels for the head clean up piece.
     *
     * @var array
     */
    private $basic_settings;
    /**
     * Holds the settings + labels for the feeds clean up.
     *
     * @var array
     */
    private $feed_settings;
    /**
     * Holds the settings + labels for permalink cleanup settings.
     *
     * @var array
     */
    private $permalink_cleanup_settings;
    /**
     * Holds the settings + labels for search cleanup settings.
     *
     * @var array
     */
    private $search_cleanup_settings;
    /**
     * Holds the settings + labels for unused resources settings.
     *
     * @var array
     */
    private $unused_resources_settings;
    /**
     * The shortlinker.
     *
     * @var WPSEO_Shortlinker
     */
    private $shortlinker;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * In this case: when on an admin page.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Crawl_Settings_Integration constructor.
     *
     * @param WPSEO_Admin_Asset_Manager $admin_asset_manager The admin asset manager.
     * @param WPSEO_Shortlinker         $shortlinker         The shortlinker.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $admin_asset_manager, \WPSEO_Shortlinker $shortlinker)
    {
    }
    /**
     * Registers an action to add a new tab to the General page.
     */
    public function register_hooks()
    {
    }
    /**
     * Enqueue the workouts app.
     */
    public function enqueue_assets()
    {
    }
    /**
     * Connects the settings to their labels.
     *
     * @return void
     */
    private function register_setting_labels()
    {
    }
    /**
     * Adds content to the Crawl Cleanup tab.
     *
     * @deprecated 20.4
     * @codeCoverageIgnore
     *
     * @param Yoast_Form $yform The yoast form object.
     */
    public function add_crawl_settings_tab_content($yform)
    {
    }
    /**
     * Adds content to the Crawl Cleanup network tab.
     *
     * @param Yoast_Form $yform The yoast form object.
     */
    public function add_crawl_settings_tab_content_network($yform)
    {
    }
    /**
     * Print the settings sections.
     *
     * @param Yoast_Form $yform      The Yoast form class.
     *
     * @return void
     */
    private function add_crawl_settings($yform)
    {
    }
    /**
     * Prints a list of toggles for an array of settings with labels.
     *
     * @param array      $settings    The settings being displayed.
     * @param Yoast_Form $yform       The Yoast form class.
     * @param string     $title       Optional title for the settings being displayed.
     * @param array      $toggles     Optional naming of the toggle buttons.
     * @param string     $warning     Optional warning to be displayed above the toggles.
     *
     * @return void
     */
    private function print_toggles(array $settings, \Yoast_Form $yform, $title = '', $toggles = [], $warning = '')
    {
    }
    /**
     * Checks if the feature should be disabled due to non-pretty permalinks.
     *
     * @param string $setting The setting to be displayed.
     *
     * @return bool
     */
    protected function should_feature_be_disabled_permalink($setting)
    {
    }
    /**
     * Checks if the feature should be disabled due to the site being a multisite.
     *
     * @param string $setting The setting to be displayed.
     *
     * @return bool
     */
    protected function should_feature_be_disabled_multisite($setting)
    {
    }
  }
  /**
   * Cron_Integration class.
   */
  class Cron_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexing notification integration.
     *
     * @var Date_Helper
     */
    protected $date_helper;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Cron_Integration constructor
     *
     * @param Date_Helper $date_helper The date helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Date_Helper $date_helper)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
  }
  /**
   * Deactivated_Premium_Integration class
   */
  class Deactivated_Premium_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options' helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $admin_asset_manager;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * First_Time_Configuration_Notice_Integration constructor.
     *
     * @param Options_Helper            $options_helper      The options helper.
     * @param WPSEO_Admin_Asset_Manager $admin_asset_manager The admin asset manager.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \WPSEO_Admin_Asset_Manager $admin_asset_manager)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Shows a notice if premium is installed but not activated.
     *
     * @return void
     */
    public function premium_deactivated_notice()
    {
    }
    /**
     * Dismisses the premium deactivated notice.
     *
     * @return bool
     */
    public function dismiss_premium_deactivated_notice()
    {
    }
    /**
     * Returns whether or not premium is installed and not activated.
     *
     * @param string $premium_file The premium file.
     *
     * @return bool Whether or not premium is installed and not activated.
     */
    protected function premium_is_installed_not_activated($premium_file)
    {
    }
  }
  /**
   * Disable_Concatenate_Scripts_Integration class.
   */
  class Disable_Concatenate_Scripts_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * In this case: when on an admin page.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Registers an action to disable script concatenation.
     */
    public function register_hooks()
    {
    }
    /**
     * Due to bugs in the 5.5 core release concatenate scripts is causing errors.
     *
     * Because of this we disable it.
     *
     * @return void
     */
    public function disable_concatenate_scripts()
    {
    }
  }
  /**
   * First_Time_Configuration_Integration class
   */
  class First_Time_Configuration_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $admin_asset_manager;
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    private $addon_manager;
    /**
     * The shortlinker.
     *
     * @var WPSEO_Shortlinker
     */
    private $shortlinker;
    /**
     * The options' helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The social profiles helper.
     *
     * @var Social_Profiles_Helper
     */
    private $social_profiles_helper;
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    private $product_helper;
    /**
     * The meta tags context helper.
     *
     * @var Meta_Tags_Context
     */
    private $meta_tags_context;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * First_Time_Configuration_Integration constructor.
     *
     * @param WPSEO_Admin_Asset_Manager $admin_asset_manager    The admin asset manager.
     * @param WPSEO_Addon_Manager       $addon_manager          The addon manager.
     * @param WPSEO_Shortlinker         $shortlinker            The shortlinker.
     * @param Options_Helper            $options_helper         The options helper.
     * @param Social_Profiles_Helper    $social_profiles_helper The social profile helper.
     * @param Product_Helper            $product_helper         The product helper.
     * @param Meta_Tags_Context         $meta_tags_context      The meta tags context helper.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $admin_asset_manager, \WPSEO_Addon_Manager $addon_manager, \WPSEO_Shortlinker $shortlinker, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Social_Profiles_Helper $social_profiles_helper, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper, \Yoast\WP\SEO\Context\Meta_Tags_Context $meta_tags_context)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Adds a dedicated tab in the General sub-page.
     *
     * @param WPSEO_Options_Tabs $dashboard_tabs Object representing the tabs of the General sub-page.
     */
    public function add_first_time_configuration_tab($dashboard_tabs)
    {
    }
    /**
     * Adds the data for the first-time configuration to the wpseoFirstTimeConfigurationData object.
     */
    public function enqueue_assets()
    {
    }
    /**
     * Retrieves a list of the endpoints to use.
     *
     * @return array The endpoints.
     */
    protected function get_endpoints()
    {
    }
    // ** Private functions ** //
    /**
     * Returns the finished steps array.
     *
     * @return array An array with the finished steps.
     */
    private function get_finished_steps()
    {
    }
    /**
     * Returns the entity represented by the site.
     *
     * @return string The entity represented by the site.
     */
    private function is_company_or_person()
    {
    }
    /**
     * Gets the company name from the option in the database.
     *
     * @return string The company name.
     */
    private function get_company_name()
    {
    }
    /**
     * Gets the fallback company name from the option in the database if there is no company name.
     *
     * @param string $company_name The given company name by the user, default empty string.
     *
     * @return string|false The company name.
     */
    private function get_fallback_company_name($company_name)
    {
    }
    /**
     * Gets the website name from the option in the database.
     *
     * @return string The website name.
     */
    private function get_website_name()
    {
    }
    /**
     * Gets the fallback website name from the option in the database if there is no website name.
     *
     * @param string $website_name The given website name by the user, default empty string.
     *
     * @return string|false The website name.
     */
    private function get_fallback_website_name($website_name)
    {
    }
    /**
     * Gets the company logo from the option in the database.
     *
     * @return string The company logo.
     */
    private function get_company_logo()
    {
    }
    /**
     * Gets the company logo id from the option in the database.
     *
     * @return string The company logo id.
     */
    private function get_company_logo_id()
    {
    }
    /**
     * Gets the company logo url from the option in the database.
     *
     * @param string $company_logo The given company logo by the user, default empty.
     *
     * @return string|false The company logo URL.
     */
    private function get_company_fallback_logo($company_logo)
    {
    }
    /**
     * Gets the person id from the option in the database.
     *
     * @return int|null The person id, null if empty.
     */
    private function get_person_id()
    {
    }
    /**
     * Gets the person id from the option in the database.
     *
     * @return int|null The person id, null if empty.
     */
    private function get_person_name()
    {
    }
    /**
     * Gets the person avatar from the option in the database.
     *
     * @return string The person logo.
     */
    private function get_person_logo()
    {
    }
    /**
     * Gets the person logo url from the option in the database.
     *
     * @param string $person_logo The given person logo by the user, default empty.
     *
     * @return string|false The person logo URL.
     */
    private function get_person_fallback_logo($person_logo)
    {
    }
    /**
     * Gets the person logo id from the option in the database.
     *
     * @return string The person logo id.
     */
    private function get_person_logo_id()
    {
    }
    /**
     * Gets the site tagline.
     *
     * @return string The site tagline.
     */
    private function get_site_tagline()
    {
    }
    /**
     * Gets the social profiles stored in the database.
     *
     * @return string[] The social profiles.
     */
    private function get_social_profiles()
    {
    }
    /**
     * Checks whether tracking is enabled.
     *
     * @return bool True if tracking is enabled, false otherwise, null if in Free and conf. workout step not finished.
     */
    private function has_tracking_enabled()
    {
    }
    /**
     * Checks whether tracking option is allowed at network level.
     *
     * @return bool True if option change is allowed, false otherwise.
     */
    private function is_tracking_enabled_multisite()
    {
    }
    /**
     * Checks whether we are in a main site.
     *
     * @return bool True if it's the main site or a single site, false if it's a subsite.
     */
    private function is_main_site()
    {
    }
    /**
     * Gets the options for the Company or Person select.
     * Returns only the company option if it is forced (by Local SEO), otherwise returns company and person option.
     *
     * @return array The options for the company-or-person select.
     */
    private function get_company_or_person_options()
    {
    }
    /**
     * Checks whether we should force "Organization".
     *
     * @return bool
     */
    private function should_force_company()
    {
    }
    /**
     * Checks if the current user has the capability to edit a specific user.
     *
     * @param int $person_id The id of the person to edit.
     *
     * @return bool
     */
    private function can_edit_profile($person_id)
    {
    }
  }
  /**
   * First_Time_Configuration_Notice_Integration class
   */
  class First_Time_Configuration_Notice_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options' helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $admin_asset_manager;
    /**
     * The first time configuration notice helper.
     *
     * @var \Yoast\WP\SEO\Helpers\First_Time_Configuration_Notice_Helper
     */
    private $first_time_configuration_notice_helper;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * First_Time_Configuration_Notice_Integration constructor.
     *
     * @param Options_Helper                         $options_helper      The options helper.
     * @param First_Time_Configuration_Notice_Helper $first_time_configuration_notice_helper      The first time configuration notice helper.
     * @param WPSEO_Admin_Asset_Manager              $admin_asset_manager The admin asset manager.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\First_Time_Configuration_Notice_Helper $first_time_configuration_notice_helper, \WPSEO_Admin_Asset_Manager $admin_asset_manager)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Dismisses the First-time configuration notice.
     *
     * @return bool
     */
    public function dismiss_first_time_configuration_notice()
    {
    }
    /**
     * Determines whether and where the "First-time SEO Configuration" admin notice should be displayed.
     *
     * @return bool Whether the "First-time SEO Configuration" admin notice should be displayed.
     */
    public function should_display_first_time_configuration_notice()
    {
    }
    /**
     * Displays an admin notice when the first-time configuration has not been finished yet.
     *
     * @return void
     */
    public function first_time_configuration_notice()
    {
    }
  }
  /**
   * Fix_News_Dependencies_Integration class.
   */
  class Fix_News_Dependencies_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * In this case: when on an admin page.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Registers an action to disable script concatenation.
     */
    public function register_hooks()
    {
    }
    /**
     * Fixes the news script dependency.
     *
     * @return void
     */
    public function add_news_script_dependency()
    {
    }
  }
  /**
   * Integrates health checks with WordPress' Site Health.
   */
  class Health_Check_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Contains all the health check implementations.
     *
     * @var Health_Check[]
     */
    private $health_checks = [];
    /**
     * Uses the dependency injection container to obtain all available implementations of the Health_Check interface.
     *
     * @param  Health_Check ...$health_checks The available health checks implementations.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Health_Check ...$health_checks)
    {
    }
    /**
     * Hooks the health checks into WordPress' site status tests.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * In this case: only when on an admin page.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Checks if the input is a WordPress site status tests array, and adds Yoast's health checks if it is.
     *
     * @param  string[] $tests Array containing WordPress site status tests.
     * @return string[] Array containing WordPress site status tests with Yoast's health checks.
     */
    public function add_health_checks($tests)
    {
    }
    /**
     * Checks if the input array is a WordPress site status tests array.
     *
     * @param  mixed $tests Array to check.
     * @return bool Returns true if the input array is a WordPress site status tests array.
     */
    private function is_valid_site_status_tests_array($tests)
    {
    }
    /**
     * Adds the health checks to WordPress' site status tests.
     *
     * @param  string[] $tests Array containing WordPress site status tests.
     * @return string[] Array containing WordPress site status tests with Yoast's health checks.
     */
    private function add_health_checks_to_site_status_tests($tests)
    {
    }
  }
  /**
   * Class WPSEO_HelpScout
   */
  class HelpScout_Beacon implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The id for the beacon.
     *
     * @var string
     */
    protected $beacon_id = '2496aba6-0292-489c-8f5d-1c0fba417c2f';
    /**
     * The id for the beacon for users that have tracking on.
     *
     * @var string
     */
    protected $beacon_id_tracking_users = '6b8e74c5-aa81-4295-b97b-c2a62a13ea7f';
    /**
     * The products the beacon is loaded for.
     *
     * @var array
     */
    protected $products = [];
    /**
     * Whether to ask the user's consent before loading in HelpScout.
     *
     * @var bool
     */
    protected $ask_consent = true;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * The array of pages we need to show the beacon on with their respective beacon IDs.
     *
     * @var array
     */
    protected $pages_ids;
    /**
     * The array of pages we need to show the beacon on.
     *
     * @var array
     */
    protected $base_pages = ['wpseo_dashboard', \Yoast\WP\SEO\Integrations\Settings_Integration::PAGE, 'wpseo_search_console', 'wpseo_tools', 'wpseo_licenses', 'wpseo_workouts'];
    /**
     * The current admin page
     *
     * @var string|null
     */
    protected $page;
    /**
     * The asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * The migration status object.
     *
     * @var Migration_Status
     */
    protected $migration_status;
    /**
     * Headless_Rest_Endpoints_Enabled_Conditional constructor.
     *
     * @param Options_Helper            $options          The options helper.
     * @param WPSEO_Admin_Asset_Manager $asset_manager    The asset manager.
     * @param Migration_Status          $migration_status The migrations status.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \WPSEO_Admin_Asset_Manager $asset_manager, \Yoast\WP\SEO\Config\Migration_Status $migration_status)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Enqueues the HelpScout script.
     */
    public function enqueue_help_scout_script()
    {
    }
    /**
     * Outputs a small piece of javascript for the beacon.
     */
    public function output_beacon_js()
    {
    }
    /**
     * Checks if the current page is a page containing the beacon.
     *
     * @return bool
     */
    private function is_beacon_page()
    {
    }
    /**
     * Retrieves the identifying data.
     *
     * @return string The data to pass as identifying data.
     */
    protected function get_session_data()
    {
    }
    /**
     * Returns basic info about the server software.
     *
     * @return array
     */
    private function get_server_info()
    {
    }
    /**
     * Returns info about the Yoast SEO plugin version and license.
     *
     * @param object $plugin The plugin.
     *
     * @return string The product info.
     */
    private function get_product_info($plugin)
    {
    }
    /**
     * Returns the WordPress version + a suffix about the multisite status.
     *
     * @return string The WordPress version string.
     */
    private function get_wordpress_version()
    {
    }
    /**
     * Returns information about the current theme.
     *
     * @return string The theme info as string.
     */
    private function get_theme_info()
    {
    }
    /**
     * Returns a stringified list of all active plugins, separated by a pipe.
     *
     * @return string The active plugins.
     */
    private function get_active_plugins()
    {
    }
    /**
     * Returns a CSV list of all must-use and drop-in plugins.
     *
     * @return string The active plugins.
     */
    private function get_mustuse_and_dropins()
    {
    }
    /**
     * Return the indexables status details.
     *
     * @return string The indexables status in a string.
     */
    private function get_indexables_status()
    {
    }
    /**
     * Returns language settings for the website and the current user.
     *
     * @return string The locale settings of the site and user.
     */
    private function get_language_settings()
    {
    }
    /**
     * Returns the conditionals based on which this integration should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Allows filtering of the HelpScout settings. Hooked to admin_head to prevent timing issues, not too early, not too late.
     */
    protected function filter_settings()
    {
    }
  }
  /**
   * Loads import script when on the Tool's page.
   */
  class Import_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Contains the asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * The Importable Detector service.
     *
     * @var Importable_Detector_Service
     */
    protected $importable_detector;
    /**
     * The Importing Route class.
     *
     * @var Importing_Route
     */
    protected $importing_route;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Import Integration constructor.
     *
     * @param WPSEO_Admin_Asset_Manager   $asset_manager       The asset manager.
     * @param Importable_Detector_Service $importable_detector The importable detector.
     * @param Importing_Route             $importing_route     The importing route.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $asset_manager, \Yoast\WP\SEO\Services\Importing\Importable_Detector_Service $importable_detector, \Yoast\WP\SEO\Routes\Importing_Route $importing_route)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Enqueues the Import script.
     */
    public function enqueue_import_script()
    {
    }
    /**
     * Retrieves a list of the importing endpoints to use.
     *
     * @return array The endpoints.
     */
    protected function get_importing_endpoints()
    {
    }
    /**
     * Sorts the array of importing actions, by moving any validating actions to the start for every plugin.
     *
     * @param array $available_actions The array of actions that we want to sort.
     *
     * @return array The sorted array of actions.
     */
    protected function sort_actions($available_actions)
    {
    }
    /**
     * Retrieves a list of the importing endpoints to use.
     *
     * @return array The endpoints.
     */
    protected function get_cleanup_endpoints()
    {
    }
    /**
     * Gets the validation failure alert using the Alert_Presenter.
     *
     * @return string The validation failure alert.
     */
    protected function get_validation_failure_alert()
    {
    }
    /**
     * Gets the import failure alert using the Alert_Presenter.
     *
     * @param bool $is_import Wether it's an import or not.
     *
     * @return string The import failure alert.
     */
    protected function get_import_failure_alert($is_import)
    {
    }
  }
  /**
   * Indexables_Exclude_Taxonomy_Integration class
   */
  class Indexables_Exclude_Taxonomy_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * Indexables_Exclude_Taxonomy_Integration constructor.
     *
     * @param Options_Helper $options_helper The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Exclude the taxonomy from the indexable table.
     *
     * @param array $excluded_taxonomies The excluded taxonomies.
     *
     * @return array The excluded post types, including the specific post type.
     */
    public function exclude_taxonomies_for_indexation($excluded_taxonomies)
    {
    }
  }
  /**
   * Class Indexing_Notification_Integration.
   *
   * @package Yoast\WP\SEO\Integrations\Admin
   */
  class Indexing_Notification_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The notification ID.
     */
    const NOTIFICATION_ID = 'wpseo-reindex';
    /**
     * The Yoast notification center.
     *
     * @var Yoast_Notification_Center
     */
    protected $notification_center;
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    protected $page_helper;
    /**
     * The short link helper.
     *
     * @var Short_Link_Helper
     */
    protected $short_link_helper;
    /**
     * The notification helper.
     *
     * @var Notification_Helper
     */
    protected $notification_helper;
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * The Addon Manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $addon_manager;
    /**
     * The Environment Helper.
     *
     * @var Environment_Helper
     */
    protected $environment_helper;
    /**
     * Indexing_Notification_Integration constructor.
     *
     * @param Yoast_Notification_Center $notification_center The notification center.
     * @param Product_Helper            $product_helper      The product helper.
     * @param Current_Page_Helper       $page_helper         The current page helper.
     * @param Short_Link_Helper         $short_link_helper   The short link helper.
     * @param Notification_Helper       $notification_helper The notification helper.
     * @param Indexing_Helper           $indexing_helper     The indexing helper.
     * @param WPSEO_Addon_Manager       $addon_manager       The addon manager.
     * @param Environment_Helper        $environment_helper  The environment helper.
     */
    public function __construct(\Yoast_Notification_Center $notification_center, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper, \Yoast\WP\SEO\Helpers\Current_Page_Helper $page_helper, \Yoast\WP\SEO\Helpers\Short_Link_Helper $short_link_helper, \Yoast\WP\SEO\Helpers\Notification_Helper $notification_helper, \Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper, \WPSEO_Addon_Manager $addon_manager, \Yoast\WP\SEO\Helpers\Environment_Helper $environment_helper)
    {
    }
    /**
     * Initializes the integration.
     *
     * Adds hooks and jobs to cleanup or add the notification when necessary.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Checks whether the notification should be shown and adds
     * it to the notification center if this is the case.
     */
    public function maybe_create_notification()
    {
    }
    /**
     * Checks whether the notification should not be shown anymore and removes
     * it from the notification center if this is the case.
     */
    public function maybe_cleanup_notification()
    {
    }
    /**
     * Checks whether the notification should be shown.
     *
     * @return bool If the notification should be shown.
     */
    protected function should_show_notification()
    {
    }
    /**
     * Returns an instance of the notification.
     *
     * @return Yoast_Notification The notification to show.
     */
    protected function notification()
    {
    }
    /**
     * Gets the presenter to use to show the notification.
     *
     * @param string $reason The reason for the notification.
     *
     * @return Indexing_Failed_Notification_Presenter|Indexing_Notification_Presenter
     */
    protected function get_presenter($reason)
    {
    }
  }
  /**
   * Class Indexing_Tool_Integration. Bridge to the Javascript indexing tool on Yoast SEO Tools page.
   *
   * @package Yoast\WP\SEO\Integrations\Admin
   */
  class Indexing_Tool_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Represents the admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * Represents the indexables helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * The short link helper.
     *
     * @var Short_Link_Helper
     */
    protected $short_link_helper;
    /**
     * Represents the indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $addon_manager;
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * The Importable Detector service.
     *
     * @var Importable_Detector_Service
     */
    protected $importable_detector;
    /**
     * The Importing Route class.
     *
     * @var Importing_Route
     */
    protected $importing_route;
    /**
     * Returns the conditionals based on which this integration should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexing_Integration constructor.
     *
     * @param WPSEO_Admin_Asset_Manager   $asset_manager       The admin asset manager.
     * @param Indexable_Helper            $indexable_helper    The indexable helper.
     * @param Short_Link_Helper           $short_link_helper   The short link helper.
     * @param Indexing_Helper             $indexing_helper     The indexing helper.
     * @param WPSEO_Addon_Manager         $addon_manager       The addon manager.
     * @param Product_Helper              $product_helper      The product helper.
     * @param Importable_Detector_Service $importable_detector The importable detector.
     * @param Importing_Route             $importing_route     The importing route.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $asset_manager, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable_helper, \Yoast\WP\SEO\Helpers\Short_Link_Helper $short_link_helper, \Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper, \WPSEO_Addon_Manager $addon_manager, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper, \Yoast\WP\SEO\Services\Importing\Importable_Detector_Service $importable_detector, \Yoast\WP\SEO\Routes\Importing_Route $importing_route)
    {
    }
    /**
     * Register hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Enqueues the required scripts.
     *
     * @return void
     */
    public function enqueue_scripts()
    {
    }
    /**
     * The error to show if optimization failed.
     *
     * @return string The error to show if optimization failed.
     */
    protected function render_indexing_error()
    {
    }
    /**
     * Determines if the site has a valid Premium subscription.
     *
     * @return bool If the site has a valid Premium subscription.
     */
    protected function has_valid_premium_subscription()
    {
    }
    /**
     * Renders the indexing list item.
     *
     * @return void
     */
    public function render_indexing_list_item()
    {
    }
    /**
     * Retrieves a list of the indexing endpoints to use.
     *
     * @return array The endpoints.
     */
    protected function get_indexing_endpoints()
    {
    }
    /**
     * Retrieves a list of the importing endpoints to use.
     *
     * @return array The endpoints.
     */
    protected function get_importing_endpoints()
    {
    }
  }
  /**
   * Installation_Success_Integration class
   */
  class Installation_Success_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Installation_Success_Integration constructor.
     *
     * @param Options_Helper $options_helper The options helper.
     * @param Product_Helper $product_helper The product helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Redirects to the installation success page if an installation has just occurred.
     *
     * @return void
     */
    public function maybe_redirect()
    {
    }
    /**
     * Adds the installation success submenu page.
     *
     * @param array $submenu_pages The Yoast SEO submenu pages.
     *
     * @return array the filtered submenu pages.
     */
    public function add_submenu_page($submenu_pages)
    {
    }
    /**
     * Enqueue assets on the Installation success page.
     */
    public function enqueue_assets()
    {
    }
    /**
     * Renders the installation success page.
     */
    public function render_page()
    {
    }
    /**
     * Wrap the `exit` function to make unit testing easier.
     */
    public function terminate_execution()
    {
    }
  }
  /**
   * Integrations_Page class
   */
  class Integrations_Page implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $admin_asset_manager;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Workouts_Integration constructor.
     *
     * @param WPSEO_Admin_Asset_Manager $admin_asset_manager The admin asset manager.
     * @param Options_Helper            $options_helper      The options helper.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $admin_asset_manager, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the integrations submenu page.
     *
     * @param array $submenu_pages The Yoast SEO submenu pages.
     *
     * @return array The filtered submenu pages.
     */
    public function add_submenu_page($submenu_pages)
    {
    }
    /**
     * Enqueue the integrations app.
     */
    public function enqueue_assets()
    {
    }
    /**
     * Renders the target for the React to mount to.
     */
    public function render_target()
    {
    }
    /**
     * Checks whether the Mastodon profile field has been filled in.
     *
     * @return bool
     */
    private function is_mastodon_active()
    {
    }
  }
  /**
   * Link_Count_Columns_Integration class.
   */
  class Link_Count_Columns_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Partial column name.
     *
     * @var string
     */
    const COLUMN_LINKED = 'linked';
    /**
     * Partial column name.
     *
     * @var string
     */
    const COLUMN_LINKS = 'links';
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * The database object.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * The post link builder.
     *
     * @var Post_Link_Indexing_Action
     */
    protected $post_link_indexing_action;
    /**
     * The admin columns cache.
     *
     * @var Admin_Columns_Cache_Integration
     */
    protected $admin_columns_cache;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Link_Count_Columns_Integration constructor
     *
     * @param Post_Type_Helper                $post_type_helper          The post type helper.
     * @param wpdb                            $wpdb                      The wpdb object.
     * @param Post_Link_Indexing_Action       $post_link_indexing_action The post link indexing action.
     * @param Admin_Columns_Cache_Integration $admin_columns_cache       The admin columns cache.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \wpdb $wpdb, \Yoast\WP\SEO\Actions\Indexing\Post_Link_Indexing_Action $post_link_indexing_action, \Yoast\WP\SEO\Integrations\Admin\Admin_Columns_Cache_Integration $admin_columns_cache)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Register hooks that need to be registered after `init` due to all post types not yet being registered.
     */
    public function register_init_hooks()
    {
    }
    /**
     * Adds the columns for the post overview.
     *
     * @param array $columns Array with columns.
     *
     * @return array The extended array with columns.
     */
    public function add_post_columns($columns)
    {
    }
    /**
     * Modifies the query pieces to allow ordering column by links to post.
     *
     * @param array    $pieces Array of Query pieces.
     * @param WP_Query $query  The Query on which to apply.
     *
     * @return array
     */
    public function order_by_linked($pieces, $query)
    {
    }
    /**
     * Modifies the query pieces to allow ordering column by links to post.
     *
     * @param array    $pieces Array of Query pieces.
     * @param WP_Query $query  The Query on which to apply.
     *
     * @return array
     */
    public function order_by_links($pieces, $query)
    {
    }
    /**
     * Builds the pieces for a sorting query.
     *
     * @param array    $pieces Array of Query pieces.
     * @param WP_Query $query  The Query on which to apply.
     * @param string   $field  The field in the table to JOIN on.
     *
     * @return array Modified Query pieces.
     */
    protected function build_sort_query_pieces($pieces, $query, $field)
    {
    }
    /**
     * Displays the column content for the given column.
     *
     * @param string $column_name Column to display the content for.
     * @param int    $post_id     Post to display the column content for.
     */
    public function column_content($column_name, $post_id)
    {
    }
    /**
     * Sets the sortable columns.
     *
     * @param array $columns Array with sortable columns.
     *
     * @return array The extended array with sortable columns.
     */
    public function column_sort(array $columns)
    {
    }
  }
  /**
   * Menu_Badge_Integration class.
   */
  class Menu_Badge_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Renders the migration error.
     *
     * @return void
     */
    public function add_inline_styles()
    {
    }
  }
  /**
   * Migration_Error_Integration class.
   */
  class Migration_Error_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The migration status object.
     *
     * @var Migration_Status
     */
    protected $migration_status;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Migration_Error_Integration constructor.
     *
     * @param Migration_Status $migration_status The migration status object.
     */
    public function __construct(\Yoast\WP\SEO\Config\Migration_Status $migration_status)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Renders the migration error.
     *
     * @return void
     */
    public function render_migration_error()
    {
    }
  }
  /**
   * Old_Configuration_Integration class
   */
  class Old_Configuration_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the old configuration submenu page.
     *
     * @param array $submenu_pages The Yoast SEO submenu pages.
     *
     * @return array the filtered submenu pages.
     */
    public function add_submenu_page($submenu_pages)
    {
    }
    /**
     * Renders the old configuration page.
     */
    public function render_page()
    {
    }
    /**
     * Redirects from the old configuration page to the new configuration page.
     */
    public function redirect_to_new_configuration()
    {
    }
  }
  /**
   * Old_Premium_Integration class
   */
  class Old_Premium_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The minimum Premium version.
     */
    const MINIMUM_PREMIUM_VERSION = '20.1-RC0';
    /**
     * The options' helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    private $product_helper;
    /**
     * The capability helper.
     *
     * @var Capability_Helper
     */
    private $capability_helper;
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $admin_asset_manager;
    /**
     * The Current_Page_Helper.
     *
     * @var Current_Page_Helper
     */
    private $current_page_helper;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Old_Premium_Integration constructor.
     *
     * @param Options_Helper            $options_helper      The options helper.
     * @param Product_Helper            $product_helper      The product helper.
     * @param Capability_Helper         $capability_helper   The capability helper.
     * @param WPSEO_Admin_Asset_Manager $admin_asset_manager The admin asset manager.
     * @param Current_Page_Helper       $current_page_helper The Current_Page_Helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper, \Yoast\WP\SEO\Helpers\Capability_Helper $capability_helper, \WPSEO_Admin_Asset_Manager $admin_asset_manager, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page_helper)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Shows a notice if Premium is older than 20.0-RC1 so Settings might be missing from the UI.
     *
     * @return void
     */
    public function old_premium_notice()
    {
    }
    /**
     * Dismisses the old premium notice.
     *
     * @return bool
     */
    public function dismiss_old_premium_notice()
    {
    }
    /**
     * Returns whether Premium is installed but older than the minimum premium version.
     *
     * @return bool Whether premium is installed but older than minimum premium version.
     */
    protected function premium_is_old()
    {
    }
    /**
     * Returns whether the notification was dismissed in a version later than the minimum premium version.
     *
     * @return bool Whether the notification was dismissed in a version later than the minimum premium version.
     */
    protected function notice_was_dismissed_after_current_min_premium_version()
    {
    }
  }
  /**
   * Class Redirect_Integration.
   */
  class Redirect_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The redirect helper.
     *
     * @var Redirect_Helper
     */
    private $redirect;
    /**
     * Sets the helpers.
     *
     * @param Redirect_Helper $redirect The redirect helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Redirect_Helper $redirect)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Redirect to new settings URLs. We're adding this, so that not-updated add-ons don't point to non-existent pages.
     *
     * @return void
     */
    public function old_settings_redirect()
    {
    }
  }
  /**
   * Redirects_Page_Integration class.
   */
  class Redirects_Page_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Sets up the hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * In this case: only when on an admin page and Premium is not active.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Adds the redirects submenu page.
     *
     * @param array $submenu_pages The Yoast SEO submenu pages.
     *
     * @return array The filtered submenu pages.
     */
    public function add_submenu_page($submenu_pages)
    {
    }
    /**
     * Displays the redirects page.
     *
     * @return void
     */
    public function display()
    {
    }
  }
  /**
   * WorkoutsIntegration class
   */
  class Workouts_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $admin_asset_manager;
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    private $addon_manager;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    private $product_helper;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Workouts_Integration constructor.
     *
     * @param WPSEO_Addon_Manager       $addon_manager       The addon manager.
     * @param WPSEO_Admin_Asset_Manager $admin_asset_manager The admin asset manager.
     * @param Options_Helper            $options_helper      The options helper.
     * @param Product_Helper            $product_helper      The product helper.
     */
    public function __construct(\WPSEO_Addon_Manager $addon_manager, \WPSEO_Admin_Asset_Manager $admin_asset_manager, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper)
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the workouts submenu page.
     *
     * @param array $submenu_pages The Yoast SEO submenu pages.
     *
     * @return array The filtered submenu pages.
     */
    public function add_submenu_page($submenu_pages)
    {
    }
    /**
     * Removes the workouts submenu page from older Premium versions
     *
     * @param array $submenu_pages The Yoast SEO submenu pages.
     *
     * @return array The filtered submenu pages.
     */
    public function remove_old_submenu_page($submenu_pages)
    {
    }
    /**
     * Enqueue the workouts app.
     */
    public function enqueue_assets()
    {
    }
    /**
     * Renders the target for the React to mount to.
     */
    public function render_target()
    {
    }
    /**
     * Gets the workouts option.
     *
     * @return mixed|null Returns workouts option if found, null if not.
     */
    private function get_workouts_option()
    {
    }
    /**
     * Returns the notification to show when Premium needs to be updated.
     *
     * @return string The notification to update Premium.
     */
    private function get_update_premium_notice()
    {
    }
    /**
     * Check whether Premium should be updated.
     *
     * @return bool Returns true when Premium is enabled and the version is below 17.7.
     */
    private function should_update_premium()
    {
    }
    /**
     * Check whether the Premium subscription has expired.
     *
     * @return bool Returns true when Premium subscription has expired.
     */
    private function has_premium_subscription_expired()
    {
    }
    /**
     * Check whether the Premium subscription is activated.
     *
     * @return bool Returns true when Premium subscription is activated.
     */
    private function has_premium_subscription_activated()
    {
    }
    /**
     * Returns the upsell/update copy to show in the card buttons.
     *
     * @return string Returns a string with the upsell/update copy for the card buttons.
     */
    private function get_upsell_text()
    {
    }
    /**
     * Returns the upsell/update link to show in the card buttons.
     *
     * @return string Returns a string with the upsell/update link for the card buttons.
     */
    private function get_upsell_link()
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations\Alerts {
  /**
   * Dismissable_Alert class.
   */
  abstract class Abstract_Dismissable_Alert implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Holds the alert identifier.
     *
     * @var string
     */
    protected $alert_identifier;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the dismissable alert.
     *
     * @param string[] $allowed_dismissable_alerts The allowed dismissable alerts.
     *
     * @return string[] The allowed dismissable alerts.
     */
    public function register_dismissable_alert($allowed_dismissable_alerts)
    {
    }
  }
  /**
   * Jetpack_Boost_Pre_Publish class.
   */
  class Jetpack_Boost_Pre_Publish extends \Yoast\WP\SEO\Integrations\Alerts\Abstract_Dismissable_Alert
  {
    /**
     * Holds the alert identifier.
     *
     * @var string
     */
    protected $alert_identifier = 'get-jetpack-boost-pre-publish-notification';
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
  }
  /**
   * Webinar_Promo_Notification class.
   */
  class Webinar_Promo_Notification extends \Yoast\WP\SEO\Integrations\Alerts\Abstract_Dismissable_Alert
  {
    /**
     * Holds the alert identifier.
     *
     * @var string
     */
    protected $alert_identifier = 'webinar-promo-notification';
  }
}

namespace Yoast\WP\SEO\Integrations\Blocks {
  /**
   * Dynamic_Block class.
   */
  abstract class Dynamic_Block implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The name of the block.
     *
     * @var string
     */
    protected $block_name;
    /**
     * The editor script for the block.
     *
     * @var string
     */
    protected $script;
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the block.
     *
     * @return void
     */
    public function register_block()
    {
    }
    /**
     * Presents the block output. This is abstract because in the loop we need to be able to build the data for the
     * presenter in the last moment.
     *
     * @param array $attributes The block attributes.
     *
     * @return string The block output.
     */
    public abstract function present($attributes);
  }
  /**
   * Internal_Linking_Category block class.
   */
  class Internal_Linking_Category implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * {@inheritDoc}
     */
    public function register_hooks()
    {
    }
    /**
     * Adds Yoast block categories.
     *
     * @param array $categories The categories.
     * @return array The filtered categories.
     */
    public function add_block_categories($categories)
    {
    }
  }
  /**
   * Siblings block class
   */
  class Breadcrumbs_Block extends \Yoast\WP\SEO\Integrations\Blocks\Dynamic_Block
  {
    /**
     * The name of the block.
     *
     * @var string
     */
    protected $block_name = 'breadcrumbs';
    /**
     * The editor script for the block.
     *
     * @var string
     */
    protected $script = 'yoast-seo-dynamic-blocks';
    /**
     * The Meta_Tags_Context_Memoizer.
     *
     * @var Meta_Tags_Context_Memoizer
     */
    private $context_memoizer;
    /**
     * The Replace vars helper.
     *
     * @var WPSEO_Replace_Vars
     */
    private $replace_vars;
    /**
     * The helpers surface.
     *
     * @var Helpers_Surface
     */
    private $helpers;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    private $indexable_repository;
    /**
     * The request helper.
     *
     * @var Request_Helper
     */
    private $request_helper;
    /**
     * Siblings_Block constructor.
     *
     * @param Meta_Tags_Context_Memoizer $context_memoizer     The context.
     * @param WPSEO_Replace_Vars         $replace_vars         The replace variable helper.
     * @param Helpers_Surface            $helpers              The Helpers surface.
     * @param Indexable_Repository       $indexable_repository The indexable repository.
     * @param Request_Helper             $request_helper       The request helper.
     */
    public function __construct(\Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer $context_memoizer, \WPSEO_Replace_Vars $replace_vars, \Yoast\WP\SEO\Surfaces\Helpers_Surface $helpers, \Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository, \Yoast\WP\SEO\Helpers\Request_Helper $request_helper)
    {
    }
    /**
     * Presents the breadcrumbs output for the current page or the available post_id.
     *
     * @param array $attributes The block attributes.
     *
     * @return string The block output.
     */
    public function present($attributes)
    {
    }
  }
  /**
   * Class to load assets required for structured data blocks.
   */
  class Structured_Data_Blocks implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * An instance of the WPSEO_Admin_Asset_Manager class.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * An instance of the image helper class.
     *
     * @var Image_Helper
     */
    protected $image_helper;
    /**
     * The image caches per post.
     *
     * @var array
     */
    protected $caches = [];
    /**
     * The used cache keys per post.
     *
     * @var array
     */
    protected $used_caches = [];
    /**
     * Whether or not we've registered our shutdown function.
     *
     * @var bool
     */
    protected $registered_shutdown_function = false;
    /**
     * Structured_Data_Blocks constructor.
     *
     * @param WPSEO_Admin_Asset_Manager $asset_manager The asset manager.
     * @param Image_Helper              $image_helper  The image helper.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $asset_manager, \Yoast\WP\SEO\Helpers\Image_Helper $image_helper)
    {
    }
    /**
     * Registers hooks for Structured Data Blocks with WordPress.
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the blocks.
     *
     * @return void
     */
    public function register_blocks()
    {
    }
    /**
     * Enqueue Gutenberg block assets for backend editor.
     */
    public function enqueue_block_editor_assets()
    {
    }
    /**
     * Optimizes images in the FAQ blocks.
     *
     * @param array  $attributes The attributes.
     * @param string $content    The content.
     *
     * @return string The content with images optimized.
     */
    public function optimize_faq_images($attributes, $content)
    {
    }
    /**
     * Optimizes images in the How-To blocks.
     *
     * @param array  $attributes The attributes.
     * @param string $content    The content.
     *
     * @return string The content with images optimized.
     */
    public function optimize_how_to_images($attributes, $content)
    {
    }
    /**
     * Optimizes images in structured data blocks.
     *
     * @param array  $elements The list of elements from the block attributes.
     * @param string $key      The key in the data to iterate over.
     * @param string $content  The content.
     *
     * @return string The content with images optimized.
     */
    private function optimize_images($elements, $key, $content)
    {
    }
    /**
     * If the caches of structured data block images have been changed, saves them.
     *
     * @return void
     */
    public function maybe_save_used_caches()
    {
    }
    /**
     * Converts an attachment src to an attachment ID.
     *
     * @param string $src The attachment src.
     *
     * @return int The attachment ID. 0 if none was found.
     */
    private function attachment_src_to_id($src)
    {
    }
    /**
     * Returns the cache from postmeta for a given post.
     *
     * @param int $post_id The post ID.
     *
     * @return array The images cache.
     */
    private function get_cache_for_post($post_id)
    {
    }
    /**
     * Adds any images that have their ID in the block attributes to the cache.
     *
     * @param int    $post_id  The post ID.
     * @param array  $elements The elements.
     * @param string $key      The key in the elements we should loop over.
     *
     * @return void
     */
    private function add_images_from_attributes_to_used_cache($post_id, $elements, $key)
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations {
  /**
   * Adds customizations to the front end for breadcrumbs.
   */
  class Breadcrumbs_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The breadcrumbs presenter.
     *
     * @var Breadcrumbs_Presenter
     */
    private $presenter;
    /**
     * The meta tags context memoizer.
     *
     * @var Meta_Tags_Context_Memoizer
     */
    private $context_memoizer;
    /**
     * Breadcrumbs integration constructor.
     *
     * @param Helpers_Surface            $helpers          The helpers.
     * @param WPSEO_Replace_Vars         $replace_vars     The replace vars.
     * @param Meta_Tags_Context_Memoizer $context_memoizer The meta tags context memoizer.
     */
    public function __construct(\Yoast\WP\SEO\Surfaces\Helpers_Surface $helpers, \WPSEO_Replace_Vars $replace_vars, \Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer $context_memoizer)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Registers the `wpseo_breadcrumb` shortcode.
     *
     * @codeCoverageIgnore
     */
    public function register_hooks()
    {
    }
    /**
     * Renders the breadcrumbs.
     *
     * @return string The rendered breadcrumbs.
     */
    public function render()
    {
    }
  }
  /**
   * Adds cleanup hooks.
   */
  class Cleanup_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Identifier used to determine the current task.
     */
    const CURRENT_TASK_OPTION = 'wpseo-cleanup-current-task';
    /**
     * Identifier for the cron job.
     */
    const CRON_HOOK = 'wpseo_cleanup_cron';
    /**
     * Identifier for starting the cleanup.
     */
    const START_HOOK = 'wpseo_start_cleanup_indexables';
    /**
     * A helper for taxonomies.
     *
     * @var Taxonomy_Helper
     */
    private $taxonomy;
    /**
     * A helper for post types.
     *
     * @var Post_Type_Helper
     */
    private $post_type;
    /**
     * A helper for author archives.
     *
     * @var Author_Archive_Helper
     */
    private $author_archive;
    /**
     * The indexables repository.
     *
     * @var Indexable_Repository
     */
    private $indexable_repository;
    /**
     * The constructor.
     *
     * @param Taxonomy_Helper       $taxonomy       A helper for taxonomies.
     * @param Post_Type_Helper      $post_type      A helper for post types.
     * @param Author_Archive_Helper $author_archive A helper for author archives.
     * @param Indexable_Repository  $indexable_repository The indexables repository.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type, \Yoast\WP\SEO\Helpers\Author_Archive_Helper $author_archive, \Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Starts the indexables cleanup.
     *
     * @return void
     */
    public function run_cleanup()
    {
    }
    /**
     * Returns an array of cleanup tasks.
     *
     * @return Closure[] The cleanup tasks.
     */
    public function get_cleanup_tasks()
    {
    }
    /**
     * Gets additional tasks from the 'wpseo_cleanup_tasks' filter.
     *
     * @return Closure[] Associative array of cleanup functions.
     */
    private function get_additional_tasks()
    {
    }
    /**
     * Gets the deletion limit for cleanups.
     *
     * @return int The limit for the amount of entities to be cleaned.
     */
    private function get_limit()
    {
    }
    /**
     * Resets and stops the cleanup integration.
     *
     * @return void
     */
    public function reset_cleanup()
    {
    }
    /**
     * Starts the cleanup cron job.
     *
     * @param string $task_name The task name of the next cleanup task to run.
     *
     * @return void
     */
    private function start_cron_job($task_name)
    {
    }
    /**
     * The callback that is called for the cleanup cron job.
     *
     * @return void
     */
    public function run_cleanup_cron()
    {
    }
    /**
     * Deletes rows from the indexable table depending on the object_type and object_sub_type.
     *
     * @param string $object_type     The object type to query.
     * @param string $object_sub_type The object subtype to query.
     * @param int    $limit           The limit we'll apply to the delete query.
     *
     * @return int|bool The number of rows that was deleted or false if the query failed.
     */
    protected function clean_indexables_with_object_type_and_object_sub_type($object_type, $object_sub_type, $limit)
    {
    }
    /**
     * Deletes rows from the indexable table depending on the post_status.
     *
     * @param string $post_status The post status to query.
     * @param int    $limit       The limit we'll apply to the delete query.
     *
     * @return int|bool The number of rows that was deleted or false if the query failed.
     */
    protected function clean_indexables_with_post_status($post_status, $limit)
    {
    }
    /**
     * Cleans up any indexables that belong to post types that are not/no longer publicly viewable.
     *
     * @param int $limit The limit we'll apply to the queries.
     *
     * @return bool|int The number of deleted rows, false if the query fails.
     */
    protected function clean_indexables_for_non_publicly_viewable_post($limit)
    {
    }
    /**
     * Cleans up any indexables that belong to taxonomies that are not/no longer publicly viewable.
     *
     * @param int $limit The limit we'll apply to the queries.
     *
     * @return bool|int The number of deleted rows, false if the query fails.
     */
    protected function clean_indexables_for_non_publicly_viewable_taxonomies($limit)
    {
    }
    /**
     * Cleans up any user indexables when the author archives have been disabled.
     *
     * @param int $limit The limit we'll apply to the queries.
     *
     * @return bool|int The number of deleted rows, false if the query fails.
     */
    protected function clean_indexables_for_authors_archive_disabled($limit)
    {
    }
    /**
     * Cleans up any indexables that belong to users that have their author archives disabled.
     *
     * @param int $limit The limit we'll apply to the queries.
     *
     * @return bool|int The number of deleted rows, false if the query fails.
     */
    protected function clean_indexables_for_authors_without_archive($limit)
    {
    }
    /**
     * Cleans orphaned rows from a yoast table.
     *
     * @param string $table  The table to clean up.
     * @param string $column The table column the cleanup will rely on.
     * @param int    $limit  The limit we'll apply to the queries.
     *
     * @return int|bool The number of deleted rows, false if the query fails.
     */
    protected function cleanup_orphaned_from_table($table, $column, $limit)
    {
    }
    /**
     * Updates the author_id of indexables which author_id is not in the wp_users table with the id of the reassingned user.
     *
     * @param int $limit The limit we'll apply to the queries.
     *
     * @return int|bool The number of updated rows, false if query to get data fails.
     */
    protected function update_indexables_author_to_reassigned($limit)
    {
    }
    /**
     * Deletes rows from the indexable table where the source is no longer there.
     *
     * @param string $source_table The source table which we need to check the indexables against.
     * @param string $source_identifier The identifier which the indexables are matched to.
     * @param string $object_type The indexable object type.
     * @param int    $limit The limit we'll apply to the delete query.
     *
     * @return int|bool The number of rows that was deleted or false if the query failed.
     */
    protected function clean_indexables_for_object_type_and_source_table($source_table, $source_identifier, $object_type, $limit)
    {
    }
    /**
     * Fetches pairs of old_id -> new_id indexed by old_id.
     * By using the old_id (i.e. the id of the user that has been deleted) as key of the associative array, we can easily compose an array of unique pairs of old_id -> new_id.
     *
     * @param int $limit The limit we'll apply to the queries.
     *
     * @return int|bool The associative array with shape [ old_id => [ old_id, new_author ] ] or false if query to get data fails.
     */
    private function get_reassigned_authors($limit)
    {
    }
    /**
     * Updates the indexable's author_id referring to a deleted author with the id of the reassigned user.
     *
     * @param array $reassigned_authors_objs The array of objects with shape [ old_id => [ old_id, new_id ] ].
     * @param int   $limit                   The limit we'll apply to the queries.
     *
     * @return int|bool The associative array with shape [ old_id => [ old_id, new_author ] ] or false if query to get data fails.
     */
    private function update_indexable_authors($reassigned_authors_objs, $limit)
    {
    }
  }
  /**
   * Class to manage the integration with Yoast Duplicate Post.
   */
  class Duplicate_Post_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Filters out the Zapier meta when you copy a post with Yoast Duplicate Post.
     *
     * @param array $meta_excludelist The current excludelist of meta fields.
     *
     * @return array The updated excludelist.
     */
    public function exclude_zapier_meta($meta_excludelist)
    {
    }
  }
  /**
   * Estimated reading time class.
   */
  class Estimated_Reading_Time implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds an estimated-reading-time hidden field.
     *
     * @param array $field_defs The $fields_defs.
     *
     * @return array
     */
    public function add_estimated_reading_time_hidden_fields($field_defs)
    {
    }
  }
  /**
   * Excludes Attachment post types from the indexable table.
   *
   * Posts with these post types will not be saved to the indexable table.
   */
  class Exclude_Attachment_Post_Type extends \Yoast\WP\SEO\Integrations\Abstract_Exclude_Post_Type
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Returns the names of the post types to be excluded.
     * To be used in the wpseo_indexable_excluded_post_types filter.
     *
     * @return array The names of the post types.
     */
    public function get_post_type()
    {
    }
  }
  /**
   * Excludes certain oEmbed Cache-specific post types from the indexable table.
   *
   * Posts with these post types will not be saved to the indexable table.
   */
  class Exclude_Oembed_Cache_Post_Type extends \Yoast\WP\SEO\Integrations\Abstract_Exclude_Post_Type
  {
    /**
     * This integration is only active when the database migrations have been run.
     *
     * @return array|string[] The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Returns the names of the post types to be excluded.
     * To be used in the wpseo_indexable_excluded_post_types filter.
     *
     * @return array The names of the post types.
     */
    public function get_post_type()
    {
    }
  }
  /**
   * Gathers all feature flags and surfaces them to the JavaScript side of the plugin.
   */
  class Feature_Flag_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * All of the feature flag conditionals.
     *
     * @var Feature_Flag_Conditional[]
     */
    protected $feature_flags;
    /**
     * Feature_Flag_Integration constructor.
     *
     * @param WPSEO_Admin_Asset_Manager $asset_manager    The admin asset manager.
     * @param Feature_Flag_Conditional  ...$feature_flags All of the known feature flag conditionals.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $asset_manager, \Yoast\WP\SEO\Conditionals\Feature_Flag_Conditional ...$feature_flags)
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return string[] The conditionals based on which this loadable should be active.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Gathers all the feature flags and injects them into the JavaScript.
     *
     * @return void
     */
    public function add_feature_flags()
    {
    }
    /**
     * Returns an array of all enabled feature flags.
     *
     * @return string[] The array of enabled features.
     */
    public function get_enabled_features()
    {
    }
    /**
     * Runs the list of enabled feature flags through a filter.
     *
     * @param string[] $enabled_features The list of currently enabled feature flags.
     *
     * @return string[] The (possibly adapted) list of enabled features.
     */
    protected function filter_enabled_features($enabled_features)
    {
    }
  }
  /**
   * Class Front_End_Integration.
   */
  class Front_End_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The memoizer for the meta tags context.
     *
     * @var Meta_Tags_Context_Memoizer
     */
    private $context_memoizer;
    /**
     * The container.
     *
     * @var ContainerInterface
     */
    protected $container;
    /**
     * Represents the options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * Represents the request helper.
     *
     * @var Request_Helper
     */
    protected $request;
    /**
     * The helpers surface.
     *
     * @var Helpers_Surface
     */
    protected $helpers;
    /**
     * The replace vars helper.
     *
     * @var WPSEO_Replace_Vars
     */
    protected $replace_vars;
    /**
     * The presenters we loop through on each page load.
     *
     * @var string[]
     */
    protected $base_presenters = ['Title', 'Meta_Description', 'Robots'];
    /**
     * The presenters we loop through on each page load.
     *
     * @var string[]
     */
    protected $indexing_directive_presenters = ['Canonical', 'Rel_Prev', 'Rel_Next'];
    /**
     * The Open Graph specific presenters.
     *
     * @var string[]
     */
    protected $open_graph_presenters = ['Open_Graph\\Locale', 'Open_Graph\\Type', 'Open_Graph\\Title', 'Open_Graph\\Description', 'Open_Graph\\Url', 'Open_Graph\\Site_Name', 'Open_Graph\\Article_Publisher', 'Open_Graph\\Article_Author', 'Open_Graph\\Article_Published_Time', 'Open_Graph\\Article_Modified_Time', 'Open_Graph\\Image', 'Meta_Author'];
    /**
     * The Open Graph specific presenters that should be output on error pages.
     *
     * @var array
     */
    protected $open_graph_error_presenters = ['Open_Graph\\Locale', 'Open_Graph\\Title', 'Open_Graph\\Site_Name'];
    /**
     * The Twitter card specific presenters.
     *
     * @var string[]
     */
    protected $twitter_card_presenters = ['Twitter\\Card', 'Twitter\\Title', 'Twitter\\Description', 'Twitter\\Image', 'Twitter\\Creator', 'Twitter\\Site'];
    /**
     * The Slack specific presenters.
     *
     * @var string[]
     */
    protected $slack_presenters = ['Slack\\Enhanced_Data'];
    /**
     * The Webmaster verification specific presenters.
     *
     * @var string[]
     */
    protected $webmaster_verification_presenters = ['Webmaster\\Baidu', 'Webmaster\\Bing', 'Webmaster\\Google', 'Webmaster\\Pinterest', 'Webmaster\\Yandex'];
    /**
     * Presenters that are only needed on singular pages.
     *
     * @var string[]
     */
    protected $singular_presenters = ['Meta_Author', 'Open_Graph\\Article_Author', 'Open_Graph\\Article_Publisher', 'Open_Graph\\Article_Published_Time', 'Open_Graph\\Article_Modified_Time', 'Twitter\\Creator', 'Slack\\Enhanced_Data'];
    /**
     * The presenters we want to be last in our output.
     *
     * @var string[]
     */
    protected $closing_presenters = ['Schema'];
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Front_End_Integration constructor.
     *
     * @codeCoverageIgnore It sets dependencies.
     *
     * @param Meta_Tags_Context_Memoizer $context_memoizer  The meta tags context memoizer.
     * @param ContainerInterface         $service_container The DI container.
     * @param Options_Helper             $options           The options helper.
     * @param Request_Helper             $request           The request helper.
     * @param Helpers_Surface            $helpers           The helpers surface.
     * @param WPSEO_Replace_Vars         $replace_vars      The replace vars helper.
     */
    public function __construct(\Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer $context_memoizer, \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $service_container, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Request_Helper $request, \Yoast\WP\SEO\Surfaces\Helpers_Surface $helpers, \WPSEO_Replace_Vars $replace_vars)
    {
    }
    /**
     * Registers the appropriate hooks to show the SEO metadata on the frontend.
     *
     * Removes some actions to remove metadata that WordPress shows on the frontend,
     * to avoid duplicate and/or mismatched metadata.
     */
    public function register_hooks()
    {
    }
    /**
     * Filters the title, mainly used for compatibility reasons.
     *
     * @return string
     */
    public function filter_title()
    {
    }
    /**
     * Filters our robots presenter, but only when wp_robots is attached to the wp_head action.
     *
     * @param array $presenters The presenters for current page.
     *
     * @return array The filtered presenters.
     */
    public function filter_robots_presenter($presenters)
    {
    }
    /**
     * Presents the head in the front-end. Resets wp_query if it's not the main query.
     *
     * @codeCoverageIgnore It just calls a WordPress function.
     */
    public function call_wpseo_head()
    {
    }
    /**
     * Echoes all applicable presenters for a page.
     */
    public function present_head()
    {
    }
    /**
     * Returns all presenters for this page.
     *
     * @param string                 $page_type The page type.
     * @param Meta_Tags_Context|null $context   The meta tags context for the current page.
     *
     * @return Abstract_Indexable_Presenter[] The presenters.
     */
    public function get_presenters($page_type, $context = null)
    {
    }
    /**
     * Generate the array of presenters we need for the current request.
     *
     * @param string $page_type The page type we're retrieving presenters for.
     *
     * @return string[] The presenters.
     */
    private function get_needed_presenters($page_type)
    {
    }
    /**
     * Filters the presenters based on the page type.
     *
     * @param string $page_type The page type.
     *
     * @return string[] The presenters.
     */
    private function get_presenters_for_page_type($page_type)
    {
    }
    /**
     * Returns a list of all available presenters based on settings.
     *
     * @return string[] The presenters.
     */
    private function get_all_presenters()
    {
    }
    /**
     * Whether the title presenter should be removed.
     *
     * @return bool True when the title presenter should be removed, false otherwise.
     */
    public function should_title_presenter_be_removed()
    {
    }
    /**
     * Checks if the Title presenter needs to be removed.
     *
     * @param string[] $presenters The presenters.
     *
     * @return string[] The presenters.
     */
    private function maybe_remove_title_presenter($presenters)
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations\Front_End {
  /**
   * Adds actions that were previously called and are now deprecated.
   */
  class Backwards_Compatibility implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Represents the options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Backwards_Compatibility constructor
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Calls the old wpseo_opengraph action.
     *
     * @return void
     */
    public function call_wpseo_opengraph()
    {
    }
    /**
     * Calls the old wpseo_twitter action.
     *
     * @return void
     */
    public function call_wpseo_twitter()
    {
    }
  }
  /**
   * Adds support for shortcodes to category and term descriptions.
   */
  class Category_Term_Description implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds shortcode support to category and term descriptions.
     *
     * This methods wrap in output buffering to prevent shortcodes that echo stuff
     * instead of return from breaking things.
     *
     * @param string $description String to add shortcodes in.
     *
     * @return string Content with shortcodes filtered out.
     */
    public function add_shortcode_support($description)
    {
    }
  }
  /**
   * Class Comment_Link_Fixer.
   */
  class Comment_Link_Fixer implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The redirects helper.
     *
     * @var Redirect_Helper
     */
    protected $redirect;
    /**
     * The robots helper.
     *
     * @var Robots_Helper
     */
    protected $robots;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Comment_Link_Fixer constructor.
     *
     * @codeCoverageIgnore It only sets depedencies.
     *
     * @param Redirect_Helper $redirect The redirect helper.
     * @param Robots_Helper   $robots   The robots helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Redirect_Helper $redirect, \Yoast\WP\SEO\Helpers\Robots_Helper $robots)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the url contains the ?replytocom query parameter.
     *
     * @codeCoverageIgnore Wraps the filter input.
     *
     * @return string|null The value of replytocom or null if it does not exist.
     */
    protected function get_replytocom_parameter()
    {
    }
    /**
     * Removes the ?replytocom variable from the link, replacing it with a #comment-<number> anchor.
     *
     * @todo Should this function also allow for relative urls ?
     *
     * @param string $link The comment link as a string.
     *
     * @return string The modified link.
     */
    public function remove_reply_to_com($link)
    {
    }
    /**
     * Redirects out the ?replytocom variables.
     *
     * @return bool True when redirect has been done.
     */
    public function replytocom_redirect()
    {
    }
    /**
     * Checks whether we can allow the feature that removes ?replytocom query parameters.
     *
     * @codeCoverageIgnore It just wraps a call to a filter.
     *
     * @return bool True to remove, false not to remove.
     */
    private function clean_reply_to_com()
    {
    }
  }
  /**
   * Class Crawl_Cleanup_Basic.
   */
  class Crawl_Cleanup_Basic implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * Crawl Cleanup Basic integration constructor.
     *
     * @param Options_Helper $options_helper The option helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Removes X-Pingback and X-Powered-By headers as they're unneeded.
     */
    public function clean_headers()
    {
    }
    /**
     * Remove the core s.w.org hint as it's only used for emoji stuff we don't use.
     *
     * @param array $hints The hints we're adding to.
     *
     * @return array
     */
    public function resource_hints_plain_cleanup($hints)
    {
    }
    /**
     * Checks if the value of an option is set to true.
     *
     * @param string $option_name The option name.
     *
     * @return bool
     */
    private function is_true($option_name)
    {
    }
  }
  /**
   * Adds actions that cleanup unwanted rss feed links.
   */
  class Crawl_Cleanup_Rss implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * Crawl Cleanup RSS integration constructor.
     *
     * @param Options_Helper $options_helper The option helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Register our RSS related hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Disable feeds on selected cases.
     */
    public function maybe_disable_feeds()
    {
    }
    /**
     * Redirect feeds we don't want away.
     */
    public function maybe_redirect_feeds()
    {
    }
    /**
     * Sends a cache control header.
     *
     * @param int $expiration The expiration time.
     */
    public function cache_control_header($expiration)
    {
    }
    /**
     * Redirect a feed result to somewhere else.
     *
     * @param string $url    The location we're redirecting to.
     * @param string $reason The reason we're redirecting.
     */
    private function redirect_feed($url, $reason)
    {
    }
    /**
     * Retrieves the queried post type.
     *
     * @return string The queried post type.
     */
    private function get_queried_post_type()
    {
    }
    /**
     * Checks if the value of an option is set to true.
     *
     * @param string $option_name The option name.
     *
     * @return bool
     */
    private function is_true($option_name)
    {
    }
  }
  /**
   * Class Crawl_Cleanup_Searches.
   */
  class Crawl_Cleanup_Searches implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Patterns to match against to find spam.
     *
     * @var array
     */
    private $patterns = ['/[：（）【】［］]+/u', '/(TALK|QQ)\\:/iu'];
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * The redirect helper.
     *
     * @var Redirect_Helper
     */
    private $redirect_helper;
    /**
     * Crawl_Cleanup_Searches integration constructor.
     *
     * @param Options_Helper  $options_helper  The option helper.
     * @param Redirect_Helper $redirect_helper The redirect helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Redirect_Helper $redirect_helper)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array The array of conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Check if we want to allow this search to happen.
     *
     * @param WP_Query $query The main query.
     *
     * @return WP_Query
     */
    public function validate_search(\WP_Query $query)
    {
    }
    /**
     * Redirect pretty search URLs to the "raw" equivalent
     */
    public function maybe_redirect_searches()
    {
    }
    /**
     * Check query against unwanted search patterns.
     *
     * @param WP_Query $query The main WordPress query.
     *
     * @return void
     */
    private function check_unwanted_patterns(\WP_Query $query)
    {
    }
    /**
     * Redirect to the homepage for invalid searches.
     *
     * @param string $reason The reason for redirecting away.
     * @param string $to_url The URL to redirect to.
     *
     * @return void
     */
    private function redirect_away($reason, $to_url = '')
    {
    }
    /**
     * Limits the number of characters in the search query.
     *
     * @return void
     */
    private function limit_characters()
    {
    }
    /**
     * Determines if a text string contains an emoji or not.
     *
     * @param string $text The text string to detect emoji in.
     *
     * @return bool
     */
    private function has_emoji($text)
    {
    }
  }
  /**
   * Class Feed_Improvements
   */
  class Feed_Improvements implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Holds the options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Holds the meta helper surface.
     *
     * @var Meta_Surface
     */
    private $meta;
    /**
     * Canonical_Header constructor.
     *
     * @codeCoverageIgnore It only sets depedencies.
     *
     * @param Options_Helper $options The options helper.
     * @param Meta_Surface   $meta    The meta surface.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Surfaces\Meta_Surface $meta)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Registers hooks to WordPress.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Filter `bloginfo_rss` output to give the URL for what's being shown instead of just always the homepage.
     *
     * @param string $show The output so far.
     * @param string $what What is being shown.
     *
     * @return string
     */
    public function filter_bloginfo_rss($show, $what)
    {
    }
    /**
     * Makes sure send canonical header always runs, because this RSS hook does not support the for_comments parameter
     *
     * @return void
     */
    public function handle_rss_feed()
    {
    }
    /**
     * Adds a canonical link header to the main canonical URL for the requested feed object. If it is not a comment
     * feed.
     *
     * @param bool $for_comments If the RRS feed is meant for a comment feed.
     *
     * @return void
     */
    public function send_canonical_header($for_comments)
    {
    }
    /**
     * Adds noindex, follow tag for comment feeds.
     *
     * @param bool $for_comments If the RSS feed is meant for a comment feed.
     *
     * @return void
     */
    public function add_robots_headers($for_comments)
    {
    }
    /**
     * Makes sure the title separator set in Yoast SEO is used for all feeds.
     *
     * @param string $separator The separator from WordPress.
     *
     * @return string The separator from Yoast SEO's settings.
     */
    public function filter_document_title_separator($separator)
    {
    }
    /**
     * Determines the main URL for the queried object.
     *
     * @param string $url The URL determined so far.
     *
     * @return string The canonical URL for the queried object.
     */
    protected function get_url_for_queried_object($url = '')
    {
    }
  }
  /**
   * Class Force_Rewrite_Title.
   */
  class Force_Rewrite_Title implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Toggle indicating whether output buffering has been started.
     *
     * @var bool
     */
    private $ob_started = false;
    /**
     * The WP Query wrapper.
     *
     * @var WP_Query_Wrapper
     */
    private $wp_query;
    /**
     * Sets the helpers.
     *
     * @codeCoverageIgnore It just handles dependencies.
     *
     * @param Options_Helper   $options  Options helper.
     * @param WP_Query_Wrapper $wp_query WP query wrapper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Wrappers\WP_Query_Wrapper $wp_query)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Used in the force rewrite functionality this retrieves the output, replaces the title with the proper SEO
     * title and then flushes the output.
     *
     * @return bool
     */
    public function flush_cache()
    {
    }
    /**
     * Starts the output buffer so it can later be fixed by flush_cache().
     */
    public function force_rewrite_output_buffer()
    {
    }
    /**
     * Replaces the titles from the parts that contains a title.
     *
     * @param string $content          The content to remove the titles from.
     * @param array  $parts_with_title The parts containing a title.
     *
     * @return string The modified content.
     */
    protected function replace_titles_from_content($content, $parts_with_title)
    {
    }
    /**
     * Removes the title from the part that contains the title and put this modified part back
     * into the content.
     *
     * @param string $part_with_title The part with the title that needs to be replaced.
     * @param string $content         The entire content.
     *
     * @return string The altered content.
     */
    protected function replace_title($part_with_title, $content)
    {
    }
    /**
     * Starts the output buffering.
     *
     * @codeCoverageIgnore
     */
    protected function start_output_buffering()
    {
    }
    /**
     * Retrieves the buffered output.
     *
     * @codeCoverageIgnore
     *
     * @return false|string The buffered output.
     */
    protected function get_buffered_output()
    {
    }
  }
  /**
   * Handles intercepting requests.
   */
  class Handle_404 implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The WP Query wrapper.
     *
     * @var WP_Query_Wrapper
     */
    private $query_wrapper;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Handle_404 constructor.
     *
     * @codeCoverageIgnore Handles dependencies.
     *
     * @param WP_Query_Wrapper $query_wrapper The query wrapper.
     */
    public function __construct(\Yoast\WP\SEO\Wrappers\WP_Query_Wrapper $query_wrapper)
    {
    }
    /**
     * Handles the 404 status code.
     *
     * @param bool $handled Whether we've handled the request.
     *
     * @return bool True if it's 404.
     */
    public function handle_404($handled)
    {
    }
    /**
     * If there are no posts in a feed, make it 404 instead of sending an empty RSS feed.
     *
     * @return bool True if it's 404.
     */
    protected function is_feed_404()
    {
    }
    /**
     * Sets the 404 status code.
     */
    protected function set_404()
    {
    }
    /**
     * Sets the headers for http.
     *
     * @codeCoverageIgnore
     */
    protected function set_headers()
    {
    }
  }
  /**
   * Class Indexing_Controls.
   */
  class Indexing_Controls implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The robots helper.
     *
     * @var Robots_Helper
     */
    protected $robots;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * The constructor.
     *
     * @codeCoverageIgnore Sets the dependencies.
     *
     * @param Robots_Helper $robots The robots helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Robots_Helper $robots)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Sends a Robots HTTP header preventing URL from being indexed in the search results while allowing search engines
     * to follow the links in the object at the URL.
     *
     * @return bool Boolean indicating whether the noindex header was sent.
     */
    public function noindex_robots()
    {
    }
    /**
     * Adds rel="nofollow" to a link, only used for login / registration links.
     *
     * @param string $input The link element as a string.
     *
     * @return string
     */
    public function nofollow_link($input)
    {
    }
    /**
     * Sets the x-robots-tag to noindex follow.
     *
     * @codeCoverageIgnore Too difficult to test.
     *
     * @return bool
     */
    protected function set_robots_header()
    {
    }
  }
  /**
   * Class Open_Graph_OEmbed.
   */
  class Open_Graph_OEmbed implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The meta surface.
     *
     * @var Meta_Surface
     */
    private $meta;
    /**
     * The oEmbed data.
     *
     * @var array
     */
    private $data;
    /**
     * The post ID for the current post.
     *
     * @var int
     */
    private $post_id;
    /**
     * The post meta.
     *
     * @var Meta|false
     */
    private $post_meta;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Open_Graph_OEmbed constructor.
     *
     * @param Meta_Surface $meta The meta surface.
     */
    public function __construct(\Yoast\WP\SEO\Surfaces\Meta_Surface $meta)
    {
    }
    /**
     * Callback function to pass to the oEmbed's response data that will enable
     * support for using the image and title set by the WordPress SEO plugin's fields. This
     * address the concern where some social channels/subscribed use oEmebed data over Open Graph data
     * if both are present.
     *
     * @link https://developer.wordpress.org/reference/hooks/oembed_response_data/ for hook info.
     *
     * @param array   $data The oEmbed data.
     * @param WP_Post $post The current Post object.
     *
     * @return array An array of oEmbed data with modified values where appropriate.
     */
    public function set_oembed_data($data, $post)
    {
    }
    /**
     * Sets the OpenGraph title if configured.
     */
    protected function set_title()
    {
    }
    /**
     * Sets the OpenGraph description if configured.
     */
    protected function set_description()
    {
    }
    /**
     * Sets the image if it has been configured.
     */
    protected function set_image()
    {
    }
  }
  /**
   * Class Redirects.
   */
  class Redirects implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * The meta helper.
     *
     * @var Meta_Helper
     */
    protected $meta;
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    protected $current_page;
    /**
     * The redirect helper.
     *
     * @var Redirect_Helper
     */
    private $redirect;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    private $url;
    /**
     * Holds the WP_Query variables we should get rid of.
     *
     * @var string[]
     */
    private $date_query_variables = ['year', 'm', 'monthnum', 'day', 'hour', 'minute', 'second'];
    /**
     * Sets the helpers.
     *
     * @codeCoverageIgnore
     *
     * @param Options_Helper      $options      Options helper.
     * @param Meta_Helper         $meta         Meta helper.
     * @param Current_Page_Helper $current_page The current page helper.
     * @param Redirect_Helper     $redirect     The redirect helper.
     * @param Url_Helper          $url          The URL helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Meta_Helper $meta, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page, \Yoast\WP\SEO\Helpers\Redirect_Helper $redirect, \Yoast\WP\SEO\Helpers\Url_Helper $url)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Disable date queries, if they're disabled in Yoast SEO settings, to prevent indexing the wrong things.
     *
     * @return void
     */
    public function disable_date_queries()
    {
    }
    /**
     * When certain archives are disabled, this redirects those to the homepage.
     */
    public function archive_redirect()
    {
    }
    /**
     * Based on the redirect meta value, this function determines whether it should redirect the current post / page.
     */
    public function page_redirect()
    {
    }
    /**
     * If the option to disable attachment URLs is checked, this performs the redirect to the attachment.
     */
    public function attachment_redirect()
    {
    }
    /**
     * Checks if certain archive pages are disabled to determine if a archive redirect is needed.
     *
     * @codeCoverageIgnore
     *
     * @return bool Whether or not to redirect an archive page.
     */
    protected function need_archive_redirect()
    {
    }
    /**
     * Retrieves the attachment url for the current page.
     *
     * @codeCoverageIgnore It wraps WordPress functions.
     *
     * @return string The attachment url.
     */
    protected function get_attachment_url()
    {
    }
    /**
     * Redirects away query variables that shouldn't work.
     *
     * @param array  $query_vars The query variables in the current URL.
     * @param string $base_url   The base URL without query string.
     *
     * @return void
     */
    private function do_date_redirect($query_vars, $base_url)
    {
    }
    /**
     * Strips `cat=-1` from the URL and redirects to the resulting URL.
     */
    public function category_redirect()
    {
    }
  }
  /**
   * Handles adding the sitemap to the `robots.txt`.
   */
  class Robots_Txt_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Holds the options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Holds the robots txt helper.
     *
     * @var Robots_Txt_Helper
     */
    protected $robots_txt_helper;
    /**
     * Holds the robots txt presenter.
     *
     * @var Robots_Txt_Presenter
     */
    protected $robots_txt_presenter;
    /**
     * Sets the helpers.
     *
     * @param Options_Helper       $options_helper       Options helper.
     * @param Robots_Txt_Helper    $robots_txt_helper    Robots txt helper.
     * @param Robots_Txt_Presenter $robots_txt_presenter Robots txt presenter.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Robots_Txt_Helper $robots_txt_helper, \Yoast\WP\SEO\Presenters\Robots_Txt_Presenter $robots_txt_presenter)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Filters the robots.txt output.
     *
     * @param string $robots_txt The robots.txt output from WordPress.
     *
     * @return string Filtered robots.txt output.
     */
    public function filter_robots($robots_txt)
    {
    }
    /**
     * Add a disallow rule for search to robots.txt.
     *
     * @param Robots_Txt_Helper $robots_txt_helper The robots txt helper.
     *
     * @return void
     */
    public function add_disallow_search_to_robots(\Yoast\WP\SEO\Helpers\Robots_Txt_Helper $robots_txt_helper)
    {
    }
    /**
     * Add a disallow rule for /wp-json/ to robots.txt.
     *
     * @param Robots_Txt_Helper $robots_txt_helper The robots txt helper.
     *
     * @return void
     */
    public function add_disallow_wp_json_to_robots(\Yoast\WP\SEO\Helpers\Robots_Txt_Helper $robots_txt_helper)
    {
    }
    /**
     * Replaces the default WordPress robots.txt output.
     *
     * @param string $robots_txt Input robots.txt.
     *
     * @return string
     */
    protected function remove_default_robots($robots_txt)
    {
    }
    /**
     * Adds XML sitemap reference to robots.txt.
     *
     * @return void
     */
    protected function maybe_add_xml_sitemap()
    {
    }
    /**
     * Adds subdomain multisite' XML sitemap references to robots.txt.
     *
     * @return void
     */
    protected function add_subdirectory_multisite_xml_sitemaps()
    {
    }
    /**
     * Retrieves whether the XML sitemaps are enabled, keyed by blog ID.
     *
     * @return array
     */
    protected function get_xml_sitemaps_enabled()
    {
    }
    /**
     * Retrieves whether the sitemap is allowed on a sub site.
     *
     * @return bool
     */
    protected function is_sitemap_allowed()
    {
    }
    /**
     * Retrieves whether the sitemap is enabled on a site.
     *
     * @param int $blog_id The blog ID.
     *
     * @return bool
     */
    protected function is_sitemap_enabled_for($blog_id)
    {
    }
    /**
     * Determines whether Yoast SEO is active.
     *
     * @param int $blog_id The blog ID.
     *
     * @return bool
     */
    protected function is_yoast_active_on($blog_id)
    {
    }
    /**
     * Determines whether Yoast SEO is active for the entire network.
     *
     * @return bool
     */
    protected function is_yoast_active_for_network()
    {
    }
    /**
     * Retrieves the blog IDs of public, "active" sites on the network.
     *
     * @return array
     */
    protected function get_blog_ids()
    {
    }
  }
  /**
   * Class RSS_Footer_Embed.
   */
  class RSS_Footer_Embed implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Sets the required helpers.
     *
     * @codeCoverageIgnore It only handles dependencies.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the RSS footer (or header) to the full RSS feed item.
     *
     * @param string $content Feed item content.
     *
     * @return string
     */
    public function embed_rssfooter($content)
    {
    }
    /**
     * Adds the RSS footer (or header) to the excerpt RSS feed item.
     *
     * @param string $content Feed item excerpt.
     *
     * @return string
     */
    public function embed_rssfooter_excerpt($content)
    {
    }
    /**
     * Checks if the RSS footer should included.
     *
     * @param string $context The context of the RSS content.
     *
     * @return bool Whether or not the RSS footer should included.
     */
    protected function include_rss_footer($context)
    {
    }
    /**
     * Checks if the RSS feed fields are configured.
     *
     * @return bool True when one of the fields has a value.
     */
    protected function is_configured()
    {
    }
    /**
     * Adds the RSS footer and/or header to an RSS feed item.
     *
     * @param string $content Feed item content.
     *
     * @return string The content to add.
     */
    protected function embed_rss($content)
    {
    }
    /**
     * Replaces the possible RSS variables with their actual values.
     *
     * @param string $content The RSS content that should have the variables replaced.
     *
     * @return string
     */
    protected function rss_replace_vars($content)
    {
    }
    /**
     * Retrieves the replacement variables.
     *
     * @codeCoverageIgnore It just contains too much WordPress functions.
     *
     * @param string $link_template The link template.
     * @param mixed  $post          The post to use.
     *
     * @return array The replacement variables.
     */
    protected function get_replace_vars($link_template, $post)
    {
    }
    /**
     * Retrieves the link template.
     *
     * @return string The link template.
     */
    protected function get_link_template()
    {
    }
  }
  /**
   * Adds the table of contents accessibility feature to the article piece with a fallback to the webpage piece.
   */
  class Schema_Accessibility_Feature implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the accessibility feature to the webpage if there is no article.
     *
     * @param array                   $piece         The graph piece.
     * @param Meta_Tags_Context       $context       The context.
     * @param Abstract_Schema_Piece   $the_generator The current schema generator.
     * @param Abstract_Schema_Piece[] $generators    The schema generators.
     *
     * @return array The graph piece.
     */
    public function maybe_add_accessibility_feature($piece, $context, $the_generator, $generators)
    {
    }
    /**
     * Adds the accessibility feature to a schema graph piece.
     *
     * @param array             $piece   The schema piece.
     * @param Meta_Tags_Context $context The context.
     *
     * @return array The graph piece.
     */
    public function add_accessibility_feature($piece, $context)
    {
    }
  }
  /**
   * Class WP_Robots_Integration
   *
   * @package Yoast\WP\SEO\Integrations\Front_End
   */
  class WP_Robots_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The meta tags context memoizer.
     *
     * @var Meta_Tags_Context_Memoizer
     */
    protected $context_memoizer;
    /**
     * Sets the dependencies for this integration.
     *
     * @param Meta_Tags_Context_Memoizer $context_memoizer The meta tags context memoizer.
     */
    public function __construct(\Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer $context_memoizer)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Adds our robots tag value to the WordPress robots tag output.
     *
     * @param array $robots The current robots data.
     *
     * @return array The robots data.
     */
    public function add_robots($robots)
    {
    }
    /**
     * Retrieves the robots key-value pairs.
     *
     * @return array The robots key-value pairs.
     */
    protected function get_robots_value()
    {
    }
    /**
     * Formats our robots fields, to match the pattern WordPress is using.
     *
     * Our format: `[ 'index' => 'noindex', 'max-image-preview' => 'max-image-preview:large', ... ]`
     * WordPress format: `[ 'noindex' => true, 'max-image-preview' => 'large', ... ]`
     *
     * @param array $robots Our robots value.
     *
     * @return array The formatted robots.
     */
    protected function format_robots($robots)
    {
    }
    /**
     * Ensures all other possible robots values are congruent with nofollow and or noindex.
     *
     * WordPress might add some robot values again.
     * When the page is set to noindex we want to filter out these values.
     *
     * @param array $robots The robots.
     *
     * @return array The filtered robots.
     */
    protected function enforce_robots_congruence($robots)
    {
    }
    /**
     * Sorts the robots array.
     *
     * @param array $robots The robots array.
     *
     * @return array The sorted robots array.
     */
    protected function sort_robots($robots)
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations {
  /**
   * Adds customizations to the front end for the primary category.
   */
  class Primary_Category implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * In this case only when on the frontend, the post overview, post edit or new post admin page.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Registers a filter to change a post's primary category.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Filters post_link_category to change the category to the chosen category by the user.
     *
     * @param stdClass     $category   The category that is now used for the post link.
     * @param array|null   $categories This parameter is not used.
     * @param WP_Post|null $post       The post in question.
     *
     * @return array|object|WP_Error|null The category we want to use for the post link.
     */
    public function post_link_category($category, $categories = null, $post = null)
    {
    }
    /**
     * Get the id of the primary category.
     *
     * @codeCoverageIgnore It justs wraps a dependency.
     *
     * @param WP_Post $post The post in question.
     *
     * @return int Primary category id.
     */
    protected function get_primary_category($post)
    {
    }
  }
  /**
   * Class Settings_Integration.
   */
  class Settings_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    const PAGE = 'wpseo_page_settings';
    /**
     * Holds the included WordPress options.
     *
     * @var string[]
     */
    const WP_OPTIONS = ['blogdescription'];
    /**
     * Holds the allowed option groups.
     *
     * @var array
     */
    const ALLOWED_OPTION_GROUPS = ['wpseo', 'wpseo_titles', 'wpseo_social'];
    /**
     * Holds the disallowed settings, per option group.
     *
     * @var array
     */
    const DISALLOWED_SETTINGS = ['wpseo' => ['myyoast-oauth', 'semrush_tokens', 'custom_taxonomy_slugs', 'zapier_subscription', 'import_cursors', 'workouts_data', 'configuration_finished_steps', 'importing_completed', 'wincher_tokens', 'least_readability_ignore_list', 'least_seo_score_ignore_list', 'most_linked_ignore_list', 'least_linked_ignore_list', 'indexables_page_reading_list'], 'wpseo_titles' => ['company_logo_meta', 'person_logo_meta']];
    /**
     * Holds the disabled on multisite settings, per option group.
     *
     * @var array
     */
    const DISABLED_ON_MULTISITE_SETTINGS = ['wpseo' => ['deny_search_crawling', 'deny_wp_json_crawling']];
    /**
     * Holds the WPSEO_Admin_Asset_Manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * Holds the WPSEO_Replace_Vars.
     *
     * @var WPSEO_Replace_Vars
     */
    protected $replace_vars;
    /**
     * Holds the Schema_Types.
     *
     * @var Schema_Types
     */
    protected $schema_types;
    /**
     * Holds the Current_Page_Helper.
     *
     * @var Current_Page_Helper
     */
    protected $current_page_helper;
    /**
     * Holds the Post_Type_Helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * Holds the Language_Helper.
     *
     * @var Language_Helper
     */
    protected $language_helper;
    /**
     * Holds the Taxonomy_Helper.
     *
     * @var Taxonomy_Helper
     */
    protected $taxonomy_helper;
    /**
     * Holds the Product_Helper.
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * Holds the Woocommerce_Helper.
     *
     * @var Woocommerce_Helper
     */
    protected $woocommerce_helper;
    /**
     * Holds the Article_Helper.
     *
     * @var Article_Helper
     */
    protected $article_helper;
    /**
     * Holds the User_Helper.
     *
     * @var User_Helper
     */
    protected $user_helper;
    /**
     * Holds the Settings_Introduction_Action.
     *
     * @var Settings_Introduction_Action
     */
    protected $settings_introduction_action;
    /**
     * Constructs Settings_Integration.
     *
     * @param WPSEO_Admin_Asset_Manager    $asset_manager                The WPSEO_Admin_Asset_Manager.
     * @param WPSEO_Replace_Vars           $replace_vars                 The WPSEO_Replace_Vars.
     * @param Schema_Types                 $schema_types                 The Schema_Types.
     * @param Current_Page_Helper          $current_page_helper          The Current_Page_Helper.
     * @param Post_Type_Helper             $post_type_helper             The Post_Type_Helper.
     * @param Language_Helper              $language_helper              The Language_Helper.
     * @param Taxonomy_Helper              $taxonomy_helper              The Taxonomy_Helper.
     * @param Product_Helper               $product_helper               The Product_Helper.
     * @param Woocommerce_Helper           $woocommerce_helper           The Woocommerce_Helper.
     * @param Article_Helper               $article_helper               The Article_Helper.
     * @param User_Helper                  $user_helper                  The User_Helper.
     * @param Settings_Introduction_Action $settings_introduction_action The Settings_Introduction_Action.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $asset_manager, \WPSEO_Replace_Vars $replace_vars, \Yoast\WP\SEO\Config\Schema_Types $schema_types, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page_helper, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast\WP\SEO\Helpers\Language_Helper $language_helper, \Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy_helper, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper, \Yoast\WP\SEO\Helpers\Woocommerce_Helper $woocommerce_helper, \Yoast\WP\SEO\Helpers\Schema\Article_Helper $article_helper, \Yoast\WP\SEO\Helpers\User_Helper $user_helper, \Yoast\WP\SEO\Actions\Settings_Introduction_Action $settings_introduction_action)
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers the different options under the setting.
     *
     * @return void
     */
    public function register_setting()
    {
    }
    /**
     * Adds the page.
     *
     * @param array $pages The pages.
     *
     * @return array The pages.
     */
    public function add_page($pages)
    {
    }
    /**
     * Adds a dummy page.
     *
     * Because the options route NEEDS to redirect to something.
     *
     * @param array $pages The pages.
     *
     * @return array The pages.
     */
    public function add_settings_saved_page($pages)
    {
    }
    /**
     * Displays the page.
     */
    public function display_page()
    {
    }
    /**
     * Enqueues the assets.
     *
     * @return void
     */
    public function enqueue_assets()
    {
    }
    /**
     * Removes all current WP notices.
     *
     * @return void
     */
    public function remove_notices()
    {
    }
    /**
     * Creates the script data.
     *
     * @return array The script data.
     */
    protected function get_script_data()
    {
    }
    /**
     * Retrieves the preferences.
     *
     * @param array $settings The settings.
     *
     * @return array The preferences.
     */
    protected function get_preferences($settings)
    {
    }
    /**
     * Retrieves the preferences.
     *
     * @return array The preferences.
     */
    protected function get_introduction_data()
    {
    }
    /**
     * Retrieves the currently represented person.
     *
     * @param array $settings The settings.
     *
     * @return array The currently represented person's ID and name.
     */
    protected function get_site_represents_person($settings)
    {
    }
    /**
     * Returns settings for the Call to Buy (CTB) buttons.
     *
     * @return string[] The array of CTB settings.
     */
    public function get_upsell_settings()
    {
    }
    /**
     * Retrieves the default setting values.
     *
     * These default values are currently being used in the UI for dummy fields.
     * Dummy fields should not expose or reflect the actual data.
     *
     * @return array The default setting values.
     */
    protected function get_default_setting_values()
    {
    }
    /**
     * Retrieves the settings and their values.
     *
     * @param array $default_setting_values The default setting values.
     *
     * @return array The settings.
     */
    protected function get_settings($default_setting_values)
    {
    }
    /**
     * Transforms setting values.
     *
     * @param array $settings The settings.
     *
     * @return array The settings.
     */
    protected function transform_settings($settings)
    {
    }
    /**
     * Retrieves the disabled settings.
     *
     * @param array $settings The settings.
     *
     * @return array The settings.
     */
    protected function get_disabled_settings($settings)
    {
    }
    /**
     * Retrieves the replacement variables.
     *
     * @return array The replacement variables.
     */
    protected function get_replacement_variables()
    {
    }
    /**
     * Retrieves the schema.
     *
     * @param array $post_types The post types.
     *
     * @return array The schema.
     */
    protected function get_schema(array $post_types)
    {
    }
    /**
     * Transforms the post types, to represent them.
     *
     * @param WP_Post_Type[] $post_types The WP_Post_Type array to transform.
     *
     * @return array The post types.
     */
    protected function transform_post_types($post_types)
    {
    }
    /**
     * Compares two post types.
     *
     * @param array $a The first post type.
     * @param array $b The second post type.
     *
     * @return int The order.
     */
    protected function compare_post_types($a, $b)
    {
    }
    /**
     * Transforms the taxonomies, to represent them.
     *
     * @param WP_Taxonomy[] $taxonomies      The WP_Taxonomy array to transform.
     * @param string[]      $post_type_names The post type names.
     *
     * @return array The taxonomies.
     */
    protected function transform_taxonomies($taxonomies, $post_type_names)
    {
    }
    /**
     * Gets the route from a name, rewrite and rest_base.
     *
     * @param string $name      The name.
     * @param array  $rewrite   The rewrite data.
     * @param string $rest_base The rest base.
     *
     * @return string The route.
     */
    protected function get_route($name, $rewrite, $rest_base)
    {
    }
    /**
     * Retrieves the fallbacks.
     *
     * @return array The fallbacks.
     */
    protected function get_fallbacks()
    {
    }
    /**
     * Removes the notification related to the post types which have been made public.
     *
     * @return void
     */
    private function remove_post_types_made_public_notification()
    {
    }
    /**
     * Removes the notification related to the taxonomies which have been made public.
     *
     * @return void
     */
    private function remove_taxonomies_made_public_notification()
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations\Third_Party {
  /**
   * AMP integration.
   */
  class AMP implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The front end integration.
     *
     * @var Front_End_Integration
     */
    protected $front_end;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Constructs the AMP integration
     *
     * @param Front_End_Integration $front_end The front end integration.
     */
    public function __construct(\Yoast\WP\SEO\Integrations\Front_End_Integration $front_end)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Removes amp meta output.
     *
     * @return void
     */
    public function remove_amp_meta_output()
    {
    }
  }
  /**
   * BbPress integration.
   */
  class BbPress implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * BbPress constructor.
     *
     * @codeCoverageIgnore It only sets dependencies.
     *
     * @param Options_Helper $options The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
  }
  /**
   * Integrates the Yoast SEO metabox in the Elementor editor.
   */
  class Elementor implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The identifier for the elementor tab.
     */
    const YOAST_TAB = 'yoast-tab';
    /**
     * Represents the post.
     *
     * @var WP_Post|null
     */
    protected $post;
    /**
     * Represents the admin asset manager.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * Represents the options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * Represents the capability helper.
     *
     * @var Capability_Helper
     */
    protected $capability;
    /**
     * Holds whether the socials are enabled.
     *
     * @var bool
     */
    protected $social_is_enabled;
    /**
     * Holds whether the advanced settings are enabled.
     *
     * @var bool
     */
    protected $is_advanced_metadata_enabled;
    /**
     * Helper to determine whether or not the SEO analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_SEO
     */
    protected $seo_analysis;
    /**
     * Helper to determine whether or not the readability analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_Readability
     */
    protected $readability_analysis;
    /**
     * Helper to determine whether or not the inclusive language analysis is enabled.
     *
     * @var WPSEO_Metabox_Analysis_Inclusive_Language
     */
    protected $inclusive_language_analysis;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Constructor.
     *
     * @param WPSEO_Admin_Asset_Manager $asset_manager                      The asset manager.
     * @param Options_Helper            $options                            The options helper.
     * @param Capability_Helper         $capability                         The capability helper.
     */
    public function __construct(\WPSEO_Admin_Asset_Manager $asset_manager, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Capability_Helper $capability)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Registers our Elementor hooks.
     */
    public function register_elementor_hooks()
    {
    }
    /**
     * Initializes the integration.
     *
     * @return void
     */
    public function init()
    {
    }
    /**
     * Register a panel tab slug, in order to allow adding controls to this tab.
     */
    public function add_yoast_panel_tab()
    {
    }
    /**
     * Register additional document controls.
     *
     * @param PageBase $document The PageBase document.
     */
    public function register_document_controls($document)
    {
    }
    // Below is mostly copied from `class-metabox.php`. That constructor has side-effects we do not need.
    /**
     * Determines whether the metabox should be shown for the passed identifier.
     *
     * By default, the check is done for post types, but can also be used for taxonomies.
     *
     * @param string|null $identifier The identifier to check.
     * @param string      $type       The type of object to check. Defaults to post_type.
     *
     * @return bool Whether the metabox should be displayed.
     */
    public function display_metabox($identifier = null, $type = 'post_type')
    {
    }
    /**
     * Saves the WP SEO metadata for posts.
     *
     * Outputs JSON via wp_send_json then stops code execution.
     *
     * {@internal $_POST parameters are validated via sanitize_post_meta().}}
     *
     * @return void
     */
    public function save_postdata()
    {
    }
    /**
     * Determines if the given meta value key is disabled.
     *
     * @param string $key The key of the meta value.
     *
     * @return bool Whether the given meta value key is disabled.
     */
    public function is_meta_value_disabled($key)
    {
    }
    /**
     * Enqueues all the needed JS and CSS.
     *
     * @return void
     */
    public function enqueue()
    {
    }
    /**
     * Renders the metabox hidden fields.
     *
     * @return void
     */
    protected function render_hidden_fields()
    {
    }
    /**
     * Returns the slug for the post being edited.
     *
     * @return string
     */
    protected function get_post_slug()
    {
    }
    /**
     * Returns post in metabox context.
     *
     * @return WP_Post|null
     */
    protected function get_metabox_post()
    {
    }
    /**
     * Passes variables to js for use with the post-scraper.
     *
     * @return array
     */
    protected function get_metabox_script_data()
    {
    }
    /**
     * Prepares the replace vars for localization.
     *
     * @return array Replace vars.
     */
    protected function get_replace_vars()
    {
    }
    /**
     * Prepares the recommended replace vars for localization.
     *
     * @return array Recommended replacement variables.
     */
    protected function get_recommended_replace_vars()
    {
    }
    /**
     * Returns the list of replace vars that should be hidden inside the editor.
     *
     * @return string[] The hidden replace vars.
     */
    protected function get_hidden_replace_vars()
    {
    }
    /**
     * Gets the custom replace variables for custom taxonomies and fields.
     *
     * @param WP_Post $post The post to check for custom taxonomies and fields.
     *
     * @return array Array containing all the replacement variables.
     */
    protected function get_custom_replace_vars($post)
    {
    }
    /**
     * Gets the custom replace variables for custom taxonomies.
     *
     * @param WP_Post $post The post to check for custom taxonomies.
     *
     * @return array Array containing all the replacement variables.
     */
    protected function get_custom_taxonomies_replace_vars($post)
    {
    }
    /**
     * Gets the custom replace variables for custom fields.
     *
     * @param WP_Post $post The post to check for custom fields.
     *
     * @return array Array containing all the replacement variables.
     */
    protected function get_custom_fields_replace_vars($post)
    {
    }
    /**
     * Determines the scope based on the post type.
     * This can be used by the replacevar plugin to determine if a replacement needs to be executed.
     *
     * @return string String describing the current scope.
     */
    protected function determine_scope()
    {
    }
    /**
     * Determines whether or not the current post type has registered taxonomies.
     *
     * @return bool Whether the current post type has taxonomies.
     */
    protected function current_post_type_has_taxonomies()
    {
    }
    /**
     * Returns an array with shortcode tags for all registered shortcodes.
     *
     * @return array
     */
    protected function get_valid_shortcode_tags()
    {
    }
  }
  /**
   * Excludes certain Elementor-specific post types from the indexable table.
   *
   * Posts with these post types will not be saved to the indexable table.
   */
  class Exclude_Elementor_Post_Types extends \Yoast\WP\SEO\Integrations\Abstract_Exclude_Post_Type
  {
    /**
     * This integration is only active when the Elementor plugin
     * is installed and activated.
     *
     * @return array|string[] The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Returns the names of the post types to be excluded.
     * To be used in the wpseo_indexable_excluded_post_types filter.
     *
     * @return array The names of the post types.
     */
    public function get_post_type()
    {
    }
  }
  /**
   * Excludes certain WooCommerce-specific post types from the indexable table.
   *
   * Posts with these post types will not be saved to the indexable table.
   */
  class Exclude_WooCommerce_Post_Types extends \Yoast\WP\SEO\Integrations\Abstract_Exclude_Post_Type
  {
    /**
     * This integration is only active when the WooCommerce plugin
     * is installed and activated.
     *
     * @return array|string[] The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Returns the names of the post types to be excluded.
     * To be used in the wpseo_indexable_excluded_post_types filter.
     *
     * @return array The names of the post types.
     */
    public function get_post_type()
    {
    }
  }
  /**
   * Jetpack integration.
   */
  class Jetpack implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
  }
  /**
   * W3 Total Cache integration.
   */
  class W3_Total_Cache implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * On successful update/add of the taxonomy meta option, flush the W3TC cache.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
  }
  /**
   * Web Stories integration.
   */
  class Web_Stories_Post_Edit implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds a isWebStoriesIntegrationActive variable to the Adminl10n array.
     *
     * @param array $input The array to add the isWebStoriesIntegrationActive to.
     *
     * @return array The passed array with the additional isWebStoriesIntegrationActive variable set to 1 if we are editing a web story.
     */
    public function add_admin_l10n($input)
    {
    }
  }
  /**
   * Web Stories integration.
   */
  class Web_Stories implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The front end integration.
     *
     * @var Front_End_Integration
     */
    protected $front_end;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Constructs the Web Stories integration
     *
     * @param Front_End_Integration $front_end The front end integration.
     */
    public function __construct(\Yoast\WP\SEO\Integrations\Front_End_Integration $front_end)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Filter 'wpseo_frontend_presenters' - Allow filtering the presenter instances in or out of the request.
     *
     * @param array             $presenters The presenters.
     * @param Meta_Tags_Context $context    The meta tags context for the current page.
     * @return array Filtered presenters.
     */
    public function filter_frontend_presenters($presenters, $context)
    {
    }
    /**
     * Hooks into web story <head> generation to modify output.
     *
     * @return void
     */
    public function web_stories_story_head()
    {
    }
    /**
     * Filters the meta description for stories.
     *
     * @param string                 $description  The description sentence.
     * @param Indexable_Presentation $presentation The presentation of an indexable.
     * @return string The description sentence.
     */
    public function filter_meta_description($description, $presentation)
    {
    }
    /**
     * Filters Article type for Web Stories.
     *
     * @param string|string[] $type      The Article type.
     * @param Indexable       $indexable The indexable.
     * @return string|string[] Article type.
     */
    public function filter_schema_article_type($type, $indexable)
    {
    }
  }
  /**
   * Handles automatically tracking published posts with Wincher.
   */
  class Wincher_Publish implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The Wincher enabled conditional.
     *
     * @var Wincher_Enabled_Conditional
     */
    protected $wincher_enabled;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The Wincher keyphrases action handler.
     *
     * @var Wincher_Keyphrases_Action
     */
    protected $keyphrases_action;
    /**
     * The Wincher account action handler.
     *
     * @var Wincher_Account_Action
     */
    protected $account_action;
    /**
     * Wincher publish constructor.
     *
     * @param Wincher_Enabled_Conditional $wincher_enabled   The WPML WPSEO conditional.
     * @param Options_Helper              $options_helper    The options helper.
     * @param Wincher_Keyphrases_Action   $keyphrases_action The keyphrases action class.
     * @param Wincher_Account_Action      $account_action    The account action class.
     */
    public function __construct(\Yoast\WP\SEO\Conditionals\Wincher_Enabled_Conditional $wincher_enabled, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Actions\Wincher\Wincher_Keyphrases_Action $keyphrases_action, \Yoast\WP\SEO\Actions\Wincher\Wincher_Account_Action $account_action)
    {
    }
    /**
     * Initializes the integration.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * This integration should only be active when the feature is enabled, a token is available and automatically tracking is enabled.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Determines whether the current request is a REST request.
     *
     * @return bool Whether the request is a REST request.
     */
    public function is_rest_request()
    {
    }
    /**
     * Sends the keyphrases associated with the post to Wincher for automatic tracking.
     *
     * @param WP_Post $post The post to extract the keyphrases from.
     *
     * @return void
     */
    public function track_request($post)
    {
    }
    /**
     * Republishes the original post with the passed post, when using the Block Editor.
     *
     * @param WP_Post $post The copy's post object.
     *
     * @return void
     */
    public function track_after_rest_api_request($post)
    {
    }
    /**
     * Republishes the original post with the passed post, when using the Classic Editor.
     *
     * Runs also in the Block Editor to save the custom meta data only when there
     * are custom meta boxes.
     *
     * @param int     $post_id The copy's post ID.
     * @param WP_Post $post    The copy's post object.
     *
     * @return void
     */
    public function track_after_post_request($post_id, $post)
    {
    }
  }
  /**
   * Adds the Wincher integration.
   */
  class Wincher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The Wincher helper instance.
     *
     * @var Wincher_Helper
     */
    protected $wincher;
    /**
     * The Wincher integration toggle constructor.
     *
     * @param Wincher_Helper $wincher The Wincher helper instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Wincher_Helper $wincher)
    {
    }
    /**
     * Initializes the integration.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Adds the Wincher integration toggle to the $integration_toggles array.
     *
     * @param array $integration_toggles The integration toggles array.
     *
     * @return array The updated integration toggles array.
     */
    public function add_integration_toggle($integration_toggles)
    {
    }
    /**
     * Adds the disabled note when the integration toggle is disabled.
     *
     * @deprecated 20.3
     * @codeCoverageIgnore
     *
     * @param Yoast_Feature_Toggle $integration The integration toggle class.
     */
    public function after_integration_toggle($integration)
    {
    }
    /**
     * Adds the disabled note to the network integration toggle.
     *
     * @param Yoast_Feature_Toggle $integration The integration toggle class.
     */
    public function after_network_integration_toggle($integration)
    {
    }
    /**
     * Outputs the disabled note.
     *
     * @codeCoverageIgnore
     *
     * @return void
     */
    protected function get_disabled_note()
    {
    }
  }
  /**
   * The permalink watcher.
   */
  class Woocommerce_Permalinks implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Represents the indexable helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Constructor.
     *
     * @param Indexable_Helper $indexable_helper Indexable Helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Indexable_Helper $indexable_helper)
    {
    }
    /**
     * Registers the hooks.
     *
     * @codeCoverageIgnore
     */
    public function register_hooks()
    {
    }
    /**
     * Filters the product post type from the post type.
     *
     * @param array $post_types The post types to filter.
     *
     * @return array The filtered post types.
     */
    public function filter_product_from_post_types($post_types)
    {
    }
    /**
     * Resets the indexables for WooCommerce based on the changed permalink fields.
     *
     * @param array $old_value The old value.
     * @param array $new_value The new value.
     */
    public function reset_woocommerce_permalinks($old_value, $new_value)
    {
    }
    /**
     * Retrieves the taxonomies based on the attributes.
     *
     * @return array The taxonomies.
     */
    protected function get_attribute_taxonomies()
    {
    }
  }
  /**
   * A WooCommerce integration that runs in the post editor.
   */
  class WooCommerce_Post_Edit implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Register the hooks for this integration to work.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Only run this integration when WooCommerce is active and the user is in the post editor.
     *
     * @return string[] The conditionals that should be met before this integration is loaded.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Don't show the date in the Google preview for WooCommerce products,
     * since Google does not show dates for product pages in the search results.
     *
     * @param array   $values Key-value map of variables we enqueue in the JavaScript of the post editor.
     * @param WP_Post $post   The post currently opened in the editor.
     *
     * @return array The values, where the `metaDescriptionDate` is set to the empty string.
     */
    public function remove_meta_description_date($values, $post)
    {
    }
  }
  /**
   * WooCommerce integration.
   */
  class WooCommerce implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * The WPSEO Replace Vars object.
     *
     * @var WPSEO_Replace_Vars
     */
    private $replace_vars;
    /**
     * The memoizer for the meta tags context.
     *
     * @var Meta_Tags_Context_Memoizer
     */
    protected $context_memoizer;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    private $repository;
    /**
     * The pagination helper.
     *
     * @var Pagination_Helper
     */
    protected $pagination_helper;
    /**
     * The WooCommerce helper.
     *
     * @var Woocommerce_Helper
     */
    private $woocommerce_helper;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * WooCommerce constructor.
     *
     * @param Options_Helper             $options            The options helper.
     * @param WPSEO_Replace_Vars         $replace_vars       The replace vars helper.
     * @param Meta_Tags_Context_Memoizer $context_memoizer   The meta tags context memoizer.
     * @param Indexable_Repository       $repository         The indexable repository.
     * @param Pagination_Helper          $pagination_helper  The paginataion helper.
     * @param Woocommerce_Helper         $woocommerce_helper The WooCommerce helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \WPSEO_Replace_Vars $replace_vars, \Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer $context_memoizer, \Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Helpers\Pagination_Helper $pagination_helper, \Yoast\WP\SEO\Helpers\Woocommerce_Helper $woocommerce_helper)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the correct canonical when WooCommerce is enabled.
     *
     * @param string                      $canonical    The current canonical.
     * @param Indexable_Presentation|null $presentation The indexable presentation.
     *
     * @return string The correct canonical.
     */
    public function canonical($canonical, $presentation = null)
    {
    }
    /**
     * Returns correct adjacent pages when WooCommerce is enabled.
     *
     * @param string                      $link         The current link.
     * @param string                      $rel          Link relationship, prev or next.
     * @param Indexable_Presentation|null $presentation The indexable presentation.
     *
     * @return string The correct link.
     */
    public function adjacent_rel_url($link, $rel, $presentation = null)
    {
    }
    /**
     * Adds a breadcrumb for the shop page.
     *
     * @param Indexable[] $indexables The array with indexables.
     *
     * @return Indexable[] The indexables to be shown in the breadcrumbs, with the shop page added.
     */
    public function add_shop_to_breadcrumbs($indexables)
    {
    }
    /**
     * Returns the ID of the WooCommerce shop page when the currently opened page is the shop page.
     *
     * @param int $page_id The page id.
     *
     * @return int The Page ID of the shop.
     */
    public function get_page_id($page_id)
    {
    }
    /**
     * Handles the title.
     *
     * @param string                      $title        The title.
     * @param Indexable_Presentation|null $presentation The indexable presentation.
     *
     * @return string The title to use.
     */
    public function title($title, $presentation = null)
    {
    }
    /**
     * Handles the meta description.
     *
     * @param string                      $description  The title.
     * @param Indexable_Presentation|null $presentation The indexable presentation.
     *
     * @return string The description to use.
     */
    public function description($description, $presentation = null)
    {
    }
    /**
     * Uses template for the given option name and replace the replacement variables on it.
     *
     * @param string $option_name  The option name to get the template for.
     * @param string $shop_page_id The page id to retrieve template for.
     *
     * @return string The rendered value.
     */
    protected function get_product_template($option_name, $shop_page_id)
    {
    }
    /**
     * Get paginated link for shop page.
     *
     * @param string                      $rel          Link relationship, prev or next or curr.
     * @param Indexable_Presentation|null $presentation The indexable presentation.
     *
     * @return string|null The link.
     */
    protected function get_shop_paginated_link($rel, $presentation = null)
    {
    }
    /**
     * Ensures a presentation is available.
     *
     * @param Indexable_Presentation $presentation The indexable presentation.
     *
     * @return Indexable_Presentation The presentation, taken from the current page if the input was invalid.
     */
    protected function ensure_presentation($presentation)
    {
    }
  }
  /**
   * Class WordProofIntegrationToggle.
   *
   * @package Yoast\WP\SEO\Integrations\Third_Party
   */
  class Wordproof_Integration_Toggle implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The WordProof helper instance.
     *
     * @var Wordproof_Helper
     */
    protected $wordproof;
    /**
     * The WordProof integration toggle constructor.
     *
     * @param Wordproof_Helper $wordproof The WordProof helper instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Wordproof_Helper $wordproof)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Adds the WordProof integration toggle to the array.
     *
     * @param array $integration_toggles The integration toggles array.
     *
     * @return array The updated integration toggles array.
     */
    public function add_integration_toggle($integration_toggles)
    {
    }
    /**
     * Set the default WordProof integration option value depending if the integration is disabled or not.
     *
     * @param array $defaults Array containing default wpseo options.
     *
     * @return array
     */
    public function default_values($defaults)
    {
    }
    /**
     * Add an explainer when the integration toggle is disabled.
     *
     * @deprecated 20.3
     * @codeCoverageIgnore
     *
     * @param Yoast_Feature_Toggle $integration The integration toggle class.
     */
    public function after_integration_toggle($integration)
    {
    }
    /**
     * Add an explainer when the network integration toggle is disabled.
     *
     * @param Yoast_Feature_Toggle $integration The integration toggle class.
     */
    public function after_network_integration_toggle($integration)
    {
    }
  }
  /**
   * Class WordProof
   *
   * @package Yoast\WP\SEO\Integrations\Third_Party
   */
  class Wordproof implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The Yoast meta key used to save if a post shiould be timestamped.
     *
     * @var string
     */
    protected $post_meta_key = '_yoast_wpseo_wordproof_timestamp';
    /**
     * The WordProof helper instance.
     *
     * @var Wordproof_Helper
     */
    protected $wordproof;
    /**
     * Asset manager instance.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * The WordProof integration constructor.
     *
     * @param Wordproof_Helper          $wordproof     The WordProof helper instance.
     * @param WPSEO_Admin_Asset_Manager $asset_manager The WPSEO admin asset manager instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Wordproof_Helper $wordproof, \WPSEO_Admin_Asset_Manager $asset_manager = null)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Initializes the WordProof WordPress SDK.
     */
    public function sdk_setup()
    {
    }
    /**
     * Removes the WordProof timestamp post meta if a legal page is changed.
     *
     * @param int $old_post_id The old post id.
     * @param int $new_post_id The new post id.
     */
    public function disable_timestamp_for_previous_legal_page($old_post_id, $new_post_id)
    {
    }
    /**
     * Return the Yoast post meta key for the SDK to determine if the post should be timestamped.
     *
     * @param array $meta_keys The array containing meta keys that should be used.
     * @return array
     */
    public function add_post_meta_key($meta_keys)
    {
    }
    /**
     * Return an empty array to disable automatically timestamping selected post types.
     *
     * @param array $post_types The array containing post types that should be automatically timestamped.
     * @return array
     */
    public function wordproof_timestamp_post_types($post_types)
    {
    }
    /**
     * This filters hides the certificate if the Yoast post meta key is not set to true.
     *
     * @param bool    $value If the certificate should be shown.
     * @param WP_Post $post  The post object of the post for which to determine the certificate should be shown.
     * @return bool|null
     */
    public function show_certificate($value, $post)
    {
    }
    /**
     * Adds the WordProof integration toggle to the array.
     *
     * @param array $fields The currently registered meta fields.
     *
     * @return array A new array with meta fields.
     */
    public function add_meta_field($fields)
    {
    }
    /**
     * Enqueue the uikit script.
     *
     * @return void
     */
    public function enqueue_assets()
    {
    }
    /**
     * Adds async to the wordproof-uikit script.
     *
     * @param string $tag    The script tag for the enqueued script.
     * @param string $handle The script's registered handle.
     * @param string $src    The script's source URL.
     *
     * @return string The script's tag.
     *
     * @phpcs:disable WordPress.WP.EnqueuedResources.NonEnqueuedScript
     */
    public function add_async_to_script($tag, $handle, $src)
    {
    }
  }
  /**
   * Adds a notification to the dashboard if the WPML plugin is installed,
   * but the Yoast SEO Multilingual plugin (a glue plugin to make Yoast SEO and WPML work nicely together)
   * is not.
   */
  class WPML_WPSEO_Notification implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The notification ID.
     *
     * @internal
     */
    const NOTIFICATION_ID = 'wpml-wpseo-not-installed';
    /**
     * The short link helper.
     *
     * @var Short_Link_Helper
     */
    protected $short_link_helper;
    /**
     * The notification center.
     *
     * @var Yoast_Notification_Center
     */
    protected $notification_center;
    /**
     * The WPML WPSEO conditional.
     *
     * @var WPML_WPSEO_Conditional
     */
    protected $wpml_wpseo_conditional;
    /**
     * WPML WPSEO notification constructor.
     *
     * @param Short_Link_Helper         $short_link_helper      The short link helper.
     * @param Yoast_Notification_Center $notification_center    The notification center.
     * @param WPML_WPSEO_Conditional    $wpml_wpseo_conditional The WPML WPSEO conditional.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Short_Link_Helper $short_link_helper, \Yoast_Notification_Center $notification_center, \Yoast\WP\SEO\Conditionals\Third_Party\WPML_WPSEO_Conditional $wpml_wpseo_conditional)
    {
    }
    /**
     * Initializes the integration.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * This integration should only be active when WPML is installed and activated.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Notify the user that the Yoast SEO Multilingual plugin is not installed
     * (when the WPML plugin is installed).
     *
     * Remove the notification again when it is installed.
     *
     * @return void
     */
    public function notify_not_installed()
    {
    }
    /**
     * Generates the notification to show to the user when WPML is installed,
     * but the Yoast SEO Multilingual plugin is not.
     *
     * @return Yoast_Notification The notification.
     */
    protected function get_notification()
    {
    }
  }
  /**
   * WPML integration.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded -- Known false positive with acronyms. Fix expected in YoastCS 3.x.
   */
  class WPML implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Adds a filter to WPML's wpml_get_home_url filter to ensure we get the unmanipulated home URL.
     */
    public function filter_home_url_before()
    {
    }
    /**
     * Removes the wpml_get_home_url filter to return the WPML, language-enriched home URL.
     *
     * @param string $home_url The filtered home URL.
     *
     * @return string The unfiltered home URL.
     */
    public function filter_home_url_after($home_url)
    {
    }
    /**
     * Returns the original URL instead of the language-enriched URL.
     * This method gets automatically triggered by the wpml_get_home_url filter.
     *
     * @param string $home_url The url altered by WPML. Unused.
     * @param string $url      The url that isn't altered by WPML.
     *
     * @return string The original url.
     */
    public function wpml_get_home_url($home_url, $url)
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations {
  /**
   * Class to manage the integration with the WP uninstall flow.
   */
  class Uninstall_Integration implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Performs all necessary actions that should happen upon plugin uninstall.
     *
     * @return void
     */
    public function wpseo_uninstall()
    {
    }
    /**
     * Clears the persistent import statuses.
     *
     * @return void
     */
    public function clear_import_statuses()
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations\Watchers {
  /**
   * Enables Yoast add-on auto updates when Yoast SEO is enabled and the other way around.
   *
   * Also removes the auto-update toggles from the Yoast SEO add-ons.
   */
  class Addon_Update_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * ID string used by WordPress to identify the free plugin.
     *
     * @var string
     */
    const WPSEO_FREE_PLUGIN_ID = 'wordpress-seo/wp-seo.php';
    /**
     * A list of Yoast add-on identifiers.
     *
     * @var string[]
     */
    const ADD_ON_PLUGIN_FILES = [
      'wordpress-seo-premium/wp-seo-premium.php',
      'wpseo-video/video-seo.php',
      'wpseo-local/local-seo.php',
      // When installing Local through a released zip, the path is different from the path on a dev environment.
      'wpseo-woocommerce/wpseo-woocommerce.php',
      'wpseo-news/wpseo-news.php',
      'acf-content-analysis-for-yoast-seo/yoast-acf-analysis.php',
    ];
    /**
     * Registers the hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return string[] The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Replaces the auto-update toggle links for the Yoast add-ons
     * with a text explaining that toggling the Yoast SEO auto-update setting
     * automatically toggles the one for the setting for the add-ons as well.
     *
     * @param string $old_html The old HTML.
     * @param string $plugin   The plugin.
     *
     * @return string The new HTML, with the auto-update toggle link replaced.
     */
    public function replace_auto_update_toggles_of_addons($old_html, $plugin)
    {
    }
    /**
     * Handles the situation where the auto_update_plugins option did not previously exist.
     *
     * @param string      $option The name of the option that is being created.
     * @param array|mixed $value  The new (and first) value of the option that is being created.
     */
    public function call_toggle_auto_updates_with_empty_array($option, $value)
    {
    }
    /**
     * Enables premium auto updates when free are enabled and the other way around.
     *
     * @param string $option    The name of the option that has been updated.
     * @param array  $new_value The new value of the `auto_update_plugins` option.
     * @param array  $old_value The old value of the `auto_update_plugins` option.
     *
     * @return void
     */
    public function toggle_auto_updates_for_add_ons($option, $new_value, $old_value)
    {
    }
    /**
     * Trigger a change in the auto update detection whenever a new Yoast addon is activated.
     *
     * @param string $plugin The plugin that is activated.
     *
     * @return void
     */
    public function maybe_toggle_auto_updates_for_new_install($plugin)
    {
    }
    /**
     * Enables auto-updates for all addons.
     *
     * @param string[] $auto_updated_plugins The current list of auto-updated plugins.
     */
    protected function enable_auto_updates_for_addons($auto_updated_plugins)
    {
    }
    /**
     * Disables auto-updates for all addons.
     *
     * @param string[] $auto_updated_plugins The current list of auto-updated plugins.
     */
    protected function disable_auto_updates_for_addons($auto_updated_plugins)
    {
    }
    /**
     * Checks whether auto updates for a plugin are enabled.
     *
     * @param string $plugin_id            The plugin ID.
     * @param array  $auto_updated_plugins The array of auto updated plugins.
     *
     * @return bool Whether auto updates for a plugin are enabled.
     */
    protected function are_auto_updates_enabled($plugin_id, $auto_updated_plugins)
    {
    }
  }
  /**
   * Shows a notification for users who have WordPress auto updates enabled but not Yoast SEO auto updates.
   */
  class Auto_Update_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The notification ID.
     */
    const NOTIFICATION_ID = 'wpseo-auto-update';
    /**
     * The Yoast notification center.
     *
     * @var Yoast_Notification_Center
     */
    protected $notification_center;
    /**
     * Auto_Update constructor.
     *
     * @param Yoast_Notification_Center $notification_center The notification center.
     */
    public function __construct(\Yoast_Notification_Center $notification_center)
    {
    }
    /**
     * Initializes the integration.
     *
     * On admin_init, it is checked whether the notification to auto-update Yoast SEO needs to be shown or removed.
     * This is also done when major WP core updates are being enabled or disabled,
     * and when automatic updates for Yoast SEO are being enabled or disabled.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Removes the notification from the notification center, if it exists.
     *
     * @return void
     */
    public function remove_notification()
    {
    }
  }
  /**
   * Ancestor watcher to update the ancestor's children.
   *
   * Updates its children's permalink when the ancestor itself is updated.
   */
  class Indexable_Ancestor_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Represents the indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * Represents the indexable hierarchy builder.
     *
     * @var Indexable_Hierarchy_Builder
     */
    protected $indexable_hierarchy_builder;
    /**
     * Represents the indexable hierarchy repository.
     *
     * @var Indexable_Hierarchy_Repository
     */
    protected $indexable_hierarchy_repository;
    /**
     * Represents the WordPress database object.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Represents the permalink helper.
     *
     * @var Permalink_Helper
     */
    protected $permalink_helper;
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * Sets the needed dependencies.
     *
     * @param Indexable_Repository           $indexable_repository           The indexable repository.
     * @param Indexable_Hierarchy_Builder    $indexable_hierarchy_builder    The indexable hierarchy builder.
     * @param Indexable_Hierarchy_Repository $indexable_hierarchy_repository The indexable hierarchy repository.
     * @param wpdb                           $wpdb                           The wpdb object.
     * @param Permalink_Helper               $permalink_helper               The permalink helper.
     * @param Post_Type_Helper               $post_type_helper               The post type helper.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository, \Yoast\WP\SEO\Builders\Indexable_Hierarchy_Builder $indexable_hierarchy_builder, \Yoast\WP\SEO\Repositories\Indexable_Hierarchy_Repository $indexable_hierarchy_repository, \wpdb $wpdb, \Yoast\WP\SEO\Helpers\Permalink_Helper $permalink_helper, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper)
    {
    }
    /**
     * Registers the appropriate hooks.
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * If an indexable's permalink has changed, updates its children in the hierarchy table and resets the children's permalink.
     *
     * @param Indexable $indexable        The indexable.
     * @param Indexable $indexable_before The old indexable.
     *
     * @return bool True if the children were reset.
     */
    public function reset_children($indexable, $indexable_before)
    {
    }
    /**
     * Finds all child indexables for the given term.
     *
     * @param int         $term_id          Term to fetch the indexable for.
     * @param Indexable[] $child_indexables The already known child indexables.
     *
     * @return array The list of additional child indexables for a given term.
     */
    public function get_children_for_term($term_id, array $child_indexables)
    {
    }
    /**
     * Updates the indexable hierarchy and indexable permalink.
     *
     * @param Indexable $indexable The indexable to update the hierarchy and permalink for.
     */
    protected function update_hierarchy_and_permalink($indexable)
    {
    }
    /**
     * Retrieves the object id's for a term based on the term-post relationship.
     *
     * @param int         $term_id          The term to get the object id's for.
     * @param Indexable[] $child_indexables The child indexables.
     *
     * @return array List with object ids for the term.
     */
    protected function get_object_ids_for_term($term_id, $child_indexables)
    {
    }
  }
  /**
   * Watches the disable-attachment key in wpseo_titles, in order to clear the permalink of the category indexables.
   */
  class Indexable_Attachment_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * The attachment cleanup helper.
     *
     * @var Attachment_Cleanup_Helper
     */
    protected $attachment_cleanup;
    /**
     * The notifications center.
     *
     * @var Yoast_Notification_Center
     */
    private $notification_center;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Attachment_Watcher constructor.
     *
     * @param Indexing_Helper           $indexing_helper     The indexing helper.
     * @param Attachment_Cleanup_Helper $attachment_cleanup  The attachment cleanup helper.
     * @param Yoast_Notification_Center $notification_center The notification center.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper, \Yoast\WP\SEO\Helpers\Attachment_Cleanup_Helper $attachment_cleanup, \Yoast_Notification_Center $notification_center)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the disable-attachment key in wpseo_titles has a change in value, and if so,
     * either it cleans up attachment indexables when it has been toggled to true,
     * or it starts displaying a notification for the user to start a new SEO optimization.
     *
     * @param array $old_value The old value of the wpseo_titles option.
     * @param array $new_value The new value of the wpseo_titles option.
     *
     * @return void
     */
    public function check_option($old_value, $new_value)
    {
    }
  }
  /**
   * Watches the `wpseo_titles` option for changes to the author archive settings.
   */
  class Indexable_Author_Archive_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Check if the author archives are disabled whenever the `wpseo_titles` option
     * changes.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * This watcher should only be run when the migrations have been run.
     * (Otherwise there may not be an indexable table to clean).
     *
     * @return string[] The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Reschedule the indexable cleanup routine if the author archives are disabled.
     * to make sure that all authors are removed from the indexables table.
     *
     * When author archives are disabled, they can never be indexed.
     *
     * @param array $old_value The old `wpseo_titles` option value.
     * @param array $new_value The new `wpseo_titles` option value.
     *
     * @return void
     */
    public function reschedule_indexable_cleanup_when_author_archives_are_disabled($old_value, $new_value)
    {
    }
  }
  /**
   * Watches an Author to save the meta information to an Indexable when updated.
   */
  class Indexable_Author_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Author_Watcher constructor.
     *
     * @param Indexable_Repository $repository The repository to use.
     * @param Indexable_Builder    $builder    The builder to use.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Deletes user meta.
     *
     * @param int $user_id User ID to delete the metadata of.
     *
     * @return void
     */
    public function delete_indexable($user_id)
    {
    }
    /**
     * Saves user meta.
     *
     * @param int $user_id User ID.
     *
     * @return void
     */
    public function build_indexable($user_id)
    {
    }
    /**
     * Handles the case in which an author is deleted.
     *
     * @param int      $user_id     User ID.
     * @param int|null $new_user_id The ID of the user the old author's posts are reassigned to.
     *
     * @return void
     */
    public function handle_user_delete($user_id, $new_user_id = null)
    {
    }
    /**
     * Reassigns the indexables of a user to another user.
     *
     * @param int $user_id     The user ID.
     * @param int $new_user_id The user ID to reassign the indexables to.
     *
     * @return void
     */
    public function maybe_reassign_user_indexables($user_id, $new_user_id)
    {
    }
  }
  /**
   * WordPress Permalink structure watcher.
   *
   * Handles updates to the permalink_structure for the Indexables table.
   */
  class Indexable_Permalink_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Represents the options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The taxonomy helper.
     *
     * @var Taxonomy_Helper
     */
    protected $taxonomy_helper;
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    private $post_type;
    /**
     * The indexable helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Permalink_Watcher constructor.
     *
     * @param Post_Type_Helper $post_type       The post type helper.
     * @param Options_Helper   $options         The options helper.
     * @param Indexable_Helper $indexable       The indexable helper.
     * @param Taxonomy_Helper  $taxonomy_helper The taxonomy helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable, \Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy_helper)
    {
    }
    /**
     * Registers the hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Resets the permalinks for everything that is related to the permalink structure.
     */
    public function reset_permalinks()
    {
    }
    /**
     * Resets the permalink for the given post type.
     *
     * @param string $post_type The post type to reset.
     */
    public function reset_permalinks_post_type($post_type)
    {
    }
    /**
     * Resets the term indexables when the base has been changed.
     *
     * @param string $old_value Unused. The old option value.
     * @param string $new_value Unused. The new option value.
     * @param string $type      The option name.
     */
    public function reset_permalinks_term($old_value, $new_value, $type)
    {
    }
    /**
     * Resets the permalink indexables automatically, if necessary.
     *
     * @return bool Whether the reset request ran.
     */
    public function force_reset_permalinks()
    {
    }
    /**
     * Checks whether the permalinks should be reset after `permalink_structure` has changed.
     *
     * @return bool Whether the permalinks should be reset.
     */
    public function should_reset_permalinks()
    {
    }
    /**
     * Resets custom taxonomies if their slugs have changed.
     *
     * @return void
     */
    public function reset_altered_custom_taxonomies()
    {
    }
    /**
     * Retrieves a list with the public post types.
     *
     * @return array The post types.
     */
    protected function get_post_types()
    {
    }
    /**
     * Retrieves the taxonomies that belongs to the public post types.
     *
     * @param array $post_types The post types to get taxonomies for.
     *
     * @return array The retrieved taxonomies.
     */
    protected function get_taxonomies_for_post_types($post_types)
    {
    }
    /**
     * Schedules the WP-Cron job to check the permalink_structure status.
     *
     * @return void
     */
    protected function schedule_cron()
    {
    }
    /**
     * Unschedules the WP-Cron job to check the permalink_structure status.
     *
     * @return void
     */
    public function unschedule_cron()
    {
    }
  }
  /**
   * Watches the stripcategorybase key in wpseo_titles, in order to clear the permalink of the category indexables.
   */
  class Indexable_Category_Permalink_Watcher extends \Yoast\WP\SEO\Integrations\Watchers\Indexable_Permalink_Watcher
  {
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the stripcategorybase key in wpseo_titles has a change in value, and if so,
     * clears the permalink for category indexables.
     *
     * @param array $old_value The old value of the wpseo_titles option.
     * @param array $new_value The new value of the wpseo_titles option.
     *
     * @return void
     */
    public function check_option($old_value, $new_value)
    {
    }
  }
  /**
   * Date archive watcher to save the meta data to an indexable.
   *
   * Watches the date archive options to save the meta information when updated.
   */
  class Indexable_Date_Archive_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Date_Archive_Watcher constructor.
     *
     * @param Indexable_Repository $repository The repository to use.
     * @param Indexable_Builder    $builder    The date archive builder to use.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the date archive indexable needs to be rebuild based on option values.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return void
     */
    public function check_option($old_value, $new_value)
    {
    }
    /**
     * Saves the date archive.
     *
     * @return void
     */
    public function build_indexable()
    {
    }
  }
  /**
   * Home page watcher to save the meta data to an Indexable.
   *
   * Watches the home page options to save the meta information when updated.
   */
  class Indexable_Home_Page_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Home_Page_Watcher constructor.
     *
     * @param Indexable_Repository $repository The repository to use.
     * @param Indexable_Builder    $builder    The post builder to use.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the home page indexable needs to be rebuild based on option values.
     *
     * @param array  $old_value The old value of the option.
     * @param array  $new_value The new value of the option.
     * @param string $option    The name of the option.
     *
     * @return void
     */
    public function check_option($old_value, $new_value, $option)
    {
    }
    /**
     * Saves the home page.
     *
     * @return void
     */
    public function build_indexable()
    {
    }
  }
  /**
   * Home url option watcher.
   *
   * Handles updates to the home URL option for the Indexables table.
   */
  class Indexable_HomeUrl_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Represents the options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    private $post_type;
    /**
     * The indexable helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_HomeUrl_Watcher constructor.
     *
     * @param Post_Type_Helper $post_type The post type helper.
     * @param Options_Helper   $options   The options helper.
     * @param Indexable_Helper $indexable The indexable helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Resets the permalinks for everything that is related to the permalink structure.
     *
     * @return void
     */
    public function reset_permalinks()
    {
    }
    /**
     * Resets the permalink indexables automatically, if necessary.
     *
     * @return bool Whether the request ran.
     */
    public function force_reset_permalinks()
    {
    }
    /**
     * Checks whether permalinks should be reset.
     *
     * @return bool Whether the permalinks should be reset.
     */
    public function should_reset_permalinks()
    {
    }
  }
  /**
   * WordPress post meta watcher.
   */
  class Indexable_Post_Meta_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The post watcher.
     *
     * @var Indexable_Post_Watcher
     */
    protected $post_watcher;
    /**
     * An array of post IDs that need to be updated.
     *
     * @var array
     */
    protected $post_ids_to_update = [];
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Postmeta_Watcher constructor.
     *
     * @param Indexable_Post_Watcher $post_watcher The post watcher.
     */
    public function __construct(\Yoast\WP\SEO\Integrations\Watchers\Indexable_Post_Watcher $post_watcher)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Adds a post id to the array of posts to update.
     *
     * @param int|string $meta_id  The meta ID.
     * @param int|string $post_id  The post ID.
     * @param string     $meta_key The meta key.
     *
     * @return void
     */
    public function add_post_id($meta_id, $post_id, $meta_key)
    {
    }
    /**
     * Removes a post id from the array of posts to update.
     *
     * @param int|string $post_id The post ID.
     *
     * @return void
     */
    public function remove_post_id($post_id)
    {
    }
    /**
     * Updates all indexables changed during the request.
     *
     * @return void
     */
    public function update_indexables()
    {
    }
  }
  /**
   * Post type archive watcher to save the meta data to an Indexable.
   *
   * Watches the home page options to save the meta information when updated.
   */
  class Indexable_Post_Type_Archive_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Post_Type_Archive_Watcher constructor.
     *
     * @param Indexable_Repository $repository The repository to use.
     * @param Indexable_Builder    $builder    The post builder to use.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the home page indexable needs to be rebuild based on option values.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return bool Whether or not the option has been saved.
     */
    public function check_option($old_value, $new_value)
    {
    }
    /**
     * Saves the post type archive.
     *
     * @param string $post_type The post type.
     *
     * @return void
     */
    public function build_indexable($post_type)
    {
    }
  }
  /**
   * Post type change watcher.
   */
  class Indexable_Post_Type_Change_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * Holds the Options_Helper instance.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Holds the Post_Type_Helper instance.
     *
     * @var Post_Type_Helper
     */
    private $post_type_helper;
    /**
     * The notifications center.
     *
     * @var Yoast_Notification_Center
     */
    private $notification_center;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Post_Type_Change_Watcher constructor.
     *
     * @param Options_Helper            $options             The options helper.
     * @param Indexing_Helper           $indexing_helper     The indexing helper.
     * @param Post_Type_Helper          $post_type_helper    The post_typehelper.
     * @param Yoast_Notification_Center $notification_center The notification center.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast_Notification_Center $notification_center)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if one or more post types change visibility.
     *
     * @return void
     */
    public function check_post_types_public_availability()
    {
    }
    /**
     * Decides if a notification should be added in the notification center.
     *
     * @return void
     */
    private function maybe_add_notification()
    {
    }
    /**
     * Adds a notification to be shown on the next page request since posts are updated in an ajax request.
     *
     * @return void
     */
    private function add_notification()
    {
    }
  }
  /**
   * WordPress Post watcher.
   *
   * Fills the Indexable according to Post data.
   */
  class Indexable_Post_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * The indexable hierarchy repository.
     *
     * @var Indexable_Hierarchy_Repository
     */
    private $hierarchy_repository;
    /**
     * The link builder.
     *
     * @var Indexable_Link_Builder
     */
    protected $link_builder;
    /**
     * The author archive helper.
     *
     * @var Author_Archive_Helper
     */
    private $author_archive;
    /**
     * Holds the Post_Helper instance.
     *
     * @var Post_Helper
     */
    private $post;
    /**
     * Holds the logger.
     *
     * @var Logger
     */
    protected $logger;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Post_Watcher constructor.
     *
     * @param Indexable_Repository           $repository           The repository to use.
     * @param Indexable_Builder              $builder              The post builder to use.
     * @param Indexable_Hierarchy_Repository $hierarchy_repository The hierarchy repository to use.
     * @param Indexable_Link_Builder         $link_builder         The link builder.
     * @param Author_Archive_Helper          $author_archive       The author archive helper.
     * @param Post_Helper                    $post                 The post helper.
     * @param Logger                         $logger               The logger.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder, \Yoast\WP\SEO\Repositories\Indexable_Hierarchy_Repository $hierarchy_repository, \Yoast\WP\SEO\Builders\Indexable_Link_Builder $link_builder, \Yoast\WP\SEO\Helpers\Author_Archive_Helper $author_archive, \Yoast\WP\SEO\Helpers\Post_Helper $post, \Yoast\WP\SEO\Loggers\Logger $logger)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Deletes the meta when a post is deleted.
     *
     * @param int $post_id Post ID.
     *
     * @return void
     */
    public function delete_indexable($post_id)
    {
    }
    /**
     * Updates the relations when the post indexable is built.
     *
     * @param Indexable $indexable The indexable.
     * @param WP_Post   $post      The post.
     */
    public function updated_indexable($indexable, $post)
    {
    }
    /**
     * Saves post meta.
     *
     * @param int $post_id Post ID.
     *
     * @return void
     */
    public function build_indexable($post_id)
    {
    }
    /**
     * Updates the has_public_posts when the post indexable is built.
     *
     * @param Indexable $indexable The indexable to check.
     */
    protected function update_has_public_posts($indexable)
    {
    }
    /**
     * Reschedule indexable cleanup if the author does not have any public posts.
     * This should remove the author from the indexable table, since we do not
     * want to store authors without public facing posts in the table.
     *
     * @param Indexable $author_indexable The author indexable.
     *
     * @return void
     */
    protected function reschedule_cleanup_if_author_has_no_posts($author_indexable)
    {
    }
    /**
     * Updates the relations on post save or post status change.
     *
     * @param WP_Post $post The post that has been updated.
     */
    protected function update_relations($post)
    {
    }
    /**
     * Retrieves the related indexables for given post.
     *
     * @param WP_Post $post The post to get the indexables for.
     *
     * @return Indexable[] The indexables.
     */
    protected function get_related_indexables($post)
    {
    }
    /**
     * Tests if the site is multisite and switched.
     *
     * @return bool True when the site is multisite and switched
     */
    protected function is_multisite_and_switched()
    {
    }
  }
  /**
   * Watcher that checks for changes in the page used as homepage.
   *
   * Watches the static homepage option and updates the permalinks accordingly.
   */
  class Indexable_Static_Home_Page_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Static_Home_Page_Watcher constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Indexable_Repository $repository The repository to use.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Updates the new and previous homepage's permalink when the static home page is updated.
     *
     * @param string $old_value The previous homepage's ID.
     * @param int    $value     The new homepage's ID.
     */
    public function update_static_homepage_permalink($old_value, $value)
    {
    }
    /**
     * Updates the permalink based on the selected homepage settings.
     *
     * @param int $page_id The page's id.
     */
    private function update_permalink_for_page($page_id)
    {
    }
  }
  /**
   * Search result watcher to save the meta data to an Indexable.
   *
   * Watches the search result options to save the meta information when updated.
   */
  class Indexable_System_Page_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_System_Page_Watcher constructor.
     *
     * @param Indexable_Repository $repository The repository to use.
     * @param Indexable_Builder    $builder    The post builder to use.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the home page indexable needs to be rebuild based on option values.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return void
     */
    public function check_option($old_value, $new_value)
    {
    }
    /**
     * Saves the search result.
     *
     * @param string $type The type of no index page.
     *
     * @return void
     */
    public function build_indexable($type)
    {
    }
  }
  /**
   * Taxonomy watcher.
   *
   * Responds to changes in taxonomies public availability.
   */
  class Indexable_Taxonomy_Change_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * Holds the Options_Helper instance.
     *
     * @var Options_Helper
     */
    private $options;
    /**
     * Holds the Taxonomy_Helper instance.
     *
     * @var Taxonomy_Helper
     */
    private $taxonomy_helper;
    /**
     * The notifications center.
     *
     * @var Yoast_Notification_Center
     */
    private $notification_center;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Taxonomy_Change_Watcher constructor.
     *
     * @param Indexing_Helper           $indexing_helper     The indexing helper.
     * @param Options_Helper            $options             The options helper.
     * @param Taxonomy_Helper           $taxonomy_helper     The taxonomy helper.
     * @param Yoast_Notification_Center $notification_center The notification center.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy_helper, \Yoast_Notification_Center $notification_center)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if one or more taxonomies change visibility.
     *
     * @return void
     */
    public function check_taxonomy_public_availability()
    {
    }
    /**
     * Decides if a notification should be added in the notification center.
     *
     * @return void
     */
    private function maybe_add_notification()
    {
    }
    /**
     * Adds a notification to be shown on the next page request since posts are updated in an ajax request.
     *
     * @return void
     */
    private function add_notification()
    {
    }
  }
  /**
   * Watches Terms/Taxonomies to fill the related Indexable.
   */
  class Indexable_Term_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    protected $builder;
    /**
     * The link builder.
     *
     * @var Indexable_Link_Builder
     */
    protected $link_builder;
    /**
     * Represents the site helper.
     *
     * @var Site_Helper
     */
    protected $site;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Indexable_Term_Watcher constructor.
     *
     * @param Indexable_Repository   $repository   The repository to use.
     * @param Indexable_Builder      $builder      The post builder to use.
     * @param Indexable_Link_Builder $link_builder The lint builder to use.
     * @param Site_Helper            $site         The site helper.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Builders\Indexable_Builder $builder, \Yoast\WP\SEO\Builders\Indexable_Link_Builder $link_builder, \Yoast\WP\SEO\Helpers\Site_Helper $site)
    {
    }
    /**
     * Registers the hooks.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Deletes a term from the index.
     *
     * @param int $term_id The Term ID to delete.
     *
     * @return void
     */
    public function delete_indexable($term_id)
    {
    }
    /**
     * Update the taxonomy meta data on save.
     *
     * @param int $term_id ID of the term to save data for.
     *
     * @return void
     */
    public function build_indexable($term_id)
    {
    }
  }
  /**
   * Watcher for the titles option.
   *
   * Represents the option titles watcher.
   */
  class Option_Titles_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Checks if one of the relevant options has been changed.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return bool Whether or not the ancestors are removed.
     */
    public function check_option($old_value, $new_value)
    {
    }
    /**
     * Retrieves the relevant keys.
     *
     * @return array Array with the relevant keys.
     */
    protected function get_relevant_keys()
    {
    }
    /**
     * Removes the ancestors for given post types.
     *
     * @param array $post_types The post types to remove hierarchy for.
     *
     * @return bool True when delete query was successful.
     */
    protected function delete_ancestors($post_types)
    {
    }
  }
  /**
   * Watcher for the wpseo option.
   *
   * Represents the option wpseo watcher.
   */
  class Option_Wpseo_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Holds the WordProof helper instance.
     *
     * @var Wordproof_Helper
     */
    protected $wordproof;
    /**
     * The constructor for a watcher of WPSEO options.
     *
     * @param Wordproof_Helper $wordproof The WordProof helper instance.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Wordproof_Helper $wordproof)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Checks if the SEMrush integration is disabled; if so, deletes the tokens.
     *
     * We delete the tokens if the SEMrush integration is disabled, no matter if
     * the value has actually changed or not.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return bool Whether the SEMrush tokens have been deleted or not.
     */
    public function check_semrush_option_disabled($old_value, $new_value)
    {
    }
    /**
     * Checks if the Wincher integration is disabled; if so, deletes the tokens
     * and website id.
     *
     * We delete them if the Wincher integration is disabled, no matter if the
     * value has actually changed or not.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return bool Whether the Wincher tokens have been deleted or not.
     */
    public function check_wincher_option_disabled($old_value, $new_value)
    {
    }
    /**
     * Checks if the WordProof integration is disabled; if so, deletes the tokens
     *
     * We delete them if the WordProof integration is disabled, no matter if the
     * value has actually changed or not.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return bool Whether the WordProof tokens have been deleted or not.
     */
    public function check_wordproof_option_disabled($old_value, $new_value)
    {
    }
    /**
     * Checks if the usage tracking feature is toggled; if so, set an option to stop us from messing with it.
     *
     * @param array $old_value The old value of the option.
     * @param array $new_value The new value of the option.
     *
     * @return bool Whether the option is set.
     */
    public function check_toggle_usage_tracking($old_value, $new_value)
    {
    }
    /**
     * Checks if the passed integration is disabled; if so, deletes the tokens.
     *
     * We delete the tokens if the integration is disabled, no matter if
     * the value has actually changed or not.
     *
     * @param string $integration_option The intergration option name.
     * @param string $target_option      The target option to remove the tokens from.
     * @param array  $new_value          The new value of the option.
     *
     * @return bool Whether the tokens have been deleted or not.
     */
    protected function check_token_option_disabled($integration_option, $target_option, $new_value)
    {
    }
  }
  /**
   * Class Primary_Category_Quick_Edit_Watcher
   */
  class Primary_Category_Quick_Edit_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Holds the options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * Holds the primary term repository.
     *
     * @var Primary_Term_Repository
     */
    protected $primary_term_repository;
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $indexable_repository;
    /**
     * The indexable hierarchy builder.
     *
     * @var Indexable_Hierarchy_Builder
     */
    protected $indexable_hierarchy_builder;
    /**
     * Primary_Category_Quick_Edit_Watcher constructor.
     *
     * @param Options_Helper              $options_helper              The options helper.
     * @param Primary_Term_Repository     $primary_term_repository     The primary term repository.
     * @param Post_Type_Helper            $post_type_helper            The post type helper.
     * @param Indexable_Repository        $indexable_repository        The indexable repository.
     * @param Indexable_Hierarchy_Builder $indexable_hierarchy_builder The indexable hierarchy repository.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Repositories\Primary_Term_Repository $primary_term_repository, \Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository, \Yoast\WP\SEO\Builders\Indexable_Hierarchy_Builder $indexable_hierarchy_builder)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array The conditionals.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Validates if the current primary category is still present. If not just remove the post meta for it.
     *
     * @param int    $object_id Object ID.
     * @param array  $terms     Unused. An array of object terms.
     * @param array  $tt_ids    An array of term taxonomy IDs.
     * @param string $taxonomy  Taxonomy slug.
     */
    public function validate_primary_category($object_id, $terms, $tt_ids, $taxonomy)
    {
    }
    /**
     * Returns the primary term id of a post.
     *
     * @param int    $post_id       The post ID.
     * @param string $main_taxonomy The main taxonomy.
     *
     * @return int|false The ID of the primary term, or `false` if the post ID is invalid.
     */
    private function get_primary_term_id($post_id, $main_taxonomy)
    {
    }
    /**
     * Removes the primary category.
     *
     * @param int    $post_id       The post id to set primary taxonomy for.
     * @param string $main_taxonomy Name of the taxonomy that is set to be the primary one.
     */
    private function remove_primary_term($post_id, $main_taxonomy)
    {
    }
    /**
     * Builds the hierarchy for a post.
     *
     * @param WP_Post $post The post.
     */
    public function build_post_hierarchy($post)
    {
    }
  }
  /**
   * Primary Term watcher.
   *
   * Watches Posts to save the primary term when set.
   */
  class Primary_Term_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * The primary term repository.
     *
     * @var Primary_Term_Repository
     */
    protected $repository;
    /**
     * Represents the site helper.
     *
     * @var Site_Helper
     */
    protected $site;
    /**
     * The primary term helper.
     *
     * @var Primary_Term_Helper
     */
    protected $primary_term;
    /**
     * The primary term builder.
     *
     * @var Primary_Term_Builder
     */
    protected $primary_term_builder;
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Primary_Term_Watcher constructor.
     *
     * @codeCoverageIgnore It sets dependencies.
     *
     * @param Primary_Term_Repository $repository           The primary term repository.
     * @param Site_Helper             $site                 The site helper.
     * @param Primary_Term_Helper     $primary_term         The primary term helper.
     * @param Primary_Term_Builder    $primary_term_builder The primary term builder.
     */
    public function __construct(\Yoast\WP\SEO\Repositories\Primary_Term_Repository $repository, \Yoast\WP\SEO\Helpers\Site_Helper $site, \Yoast\WP\SEO\Helpers\Primary_Term_Helper $primary_term, \Yoast\WP\SEO\Builders\Primary_Term_Builder $primary_term_builder)
    {
    }
    /**
     * Initializes the integration.
     *
     * This is the place to register hooks and filters.
     */
    public function register_hooks()
    {
    }
    /**
     * Saves all selected primary terms.
     *
     * @param int $post_id Post ID to save primary terms for.
     */
    public function save_primary_terms($post_id)
    {
    }
    /**
     * Saves the primary term for a specific taxonomy.
     *
     * @param int     $post_id  Post ID to save primary term for.
     * @param WP_Term $taxonomy Taxonomy to save primary term for.
     */
    protected function save_primary_term($post_id, $taxonomy)
    {
    }
    /**
     * Deletes primary terms for a post.
     *
     * @param int $post_id The post to delete the terms of.
     *
     * @return void
     */
    public function delete_primary_terms($post_id)
    {
    }
  }
  /**
   * Shows a notification for users who have access for robots disabled.
   *
   * @class Search_Engines_Discouraged_Watcher
   */
  class Search_Engines_Discouraged_Watcher implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The notification ID.
     */
    const NOTIFICATION_ID = 'wpseo-search-engines-discouraged';
    /**
     * The Yoast notification center.
     *
     * @var Yoast_Notification_Center
     */
    protected $notification_center;
    /**
     * The notification helper.
     *
     * @var Notification_Helper
     */
    protected $notification_helper;
    /**
     * The search engines discouraged presenter.
     *
     * @var Search_Engines_Discouraged_Presenter
     */
    protected $presenter;
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    protected $current_page_helper;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The capability helper.
     *
     * @var Capability_Helper
     */
    protected $capability_helper;
    /**
     * Search_Engines_Discouraged_Watcher constructor.
     *
     * @param Yoast_Notification_Center $notification_center The notification center.
     * @param Notification_Helper       $notification_helper The notification helper.
     * @param Current_Page_Helper       $current_page_helper The current page helper.
     * @param Options_Helper            $options_helper      The options helper.
     * @param Capability_Helper         $capability_helper   The capability helper.
     */
    public function __construct(\Yoast_Notification_Center $notification_center, \Yoast\WP\SEO\Helpers\Notification_Helper $notification_helper, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page_helper, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Capability_Helper $capability_helper)
    {
    }
    /**
     * Initializes the integration.
     *
     * On admin_init, it is checked whether the notification about search engines being discouraged should be shown.
     * On admin_notices, the notice about the search engines being discouraged will be shown when necessary.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Manage the search engines discouraged notification.
     *
     * Shows the notification if needed and deletes it if needed.
     *
     * @return void
     */
    public function manage_search_engines_discouraged_notification()
    {
    }
    /**
     * Show the search engine discouraged notice when needed.
     *
     * @return void
     */
    public function maybe_show_search_engines_discouraged_notice()
    {
    }
    /**
     * Whether the search engines discouraged notification should be shown.
     *
     * @return bool
     */
    protected function should_show_search_engines_discouraged_notification()
    {
    }
    /**
     * Remove the search engines discouraged notification if it exists.
     *
     * @return void
     */
    protected function remove_search_engines_discouraged_notification_if_exists()
    {
    }
    /**
     * Add the search engines discouraged notification if it does not exist yet.
     *
     * @return void
     */
    protected function maybe_add_search_engines_discouraged_notification()
    {
    }
    /**
     * Checks whether search engines are discouraged from indexing the site.
     *
     * @return bool Whether search engines are discouraged from indexing the site.
     */
    protected function search_engines_are_discouraged()
    {
    }
    /**
     * Whether the search engines notice should be shown.
     *
     * @return bool
     */
    protected function should_show_search_engines_discouraged_notice()
    {
    }
    /**
     * Show the search engines discouraged notice.
     *
     * @return void
     */
    protected function show_search_engines_discouraged_notice()
    {
    }
    /**
     * Returns an instance of the notification.
     *
     * @return Yoast_Notification The notification to show.
     */
    protected function notification()
    {
    }
  }
}

namespace Yoast\WP\SEO\Integrations {
  /**
   * Noindexes the xmlrpc.php file and all ways to request it.
   *
   * @phpcs:disable Yoast.NamingConventions.ObjectNameDepth.MaxExceeded -- Known false positive with acronyms. Fix expected in YoastCS 3.x.
   */
  class XMLRPC implements \Yoast\WP\SEO\Integrations\Integration_Interface
  {
    /**
     * Returns the conditionals based on which this loadable should be active.
     *
     * In this case when the current request is an XML-RPC request.
     *
     * @return array The conditionals based on which this class should be loaded.
     */
    public static function get_conditionals()
    {
    }
    /**
     * Initializes the integration.
     *
     * @return void
     */
    public function register_hooks()
    {
    }
    /**
     * Sets a noindex, follow x-robots-tag header on all XMLRPC requests.
     *
     * @codeCoverageIgnore Basically impossible to test from the command line.
     *
     * @param array $methods The methods.
     *
     * @return array The methods.
     */
    public function robots_header($methods)
    {
    }
  }
}

namespace Yoast\WP\SEO {
  /**
   * Class that manages loading integrations if and only if all their conditionals are met.
   */
  class Loader
  {
    /**
     * The registered integrations.
     *
     * @var string[]
     */
    protected $integrations = [];
    /**
     * The registered integrations.
     *
     * @var string[]
     */
    protected $initializers = [];
    /**
     * The registered routes.
     *
     * @var string[]
     */
    protected $routes = [];
    /**
     * The registered commands.
     *
     * @var string[]
     */
    protected $commands = [];
    /**
     * The registered migrations.
     *
     * @var string[]
     */
    protected $migrations = [];
    /**
     * The dependency injection container.
     *
     * @var ContainerInterface
     */
    protected $container;
    /**
     * Loader constructor.
     *
     * @param ContainerInterface $container The dependency injection container.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container)
    {
    }
    /**
     * Registers an integration.
     *
     * @param string $integration_class The class name of the integration to be loaded.
     *
     * @return void
     */
    public function register_integration($integration_class)
    {
    }
    /**
     * Registers an initializer.
     *
     * @param string $initializer_class The class name of the initializer to be loaded.
     *
     * @return void
     */
    public function register_initializer($initializer_class)
    {
    }
    /**
     * Registers a route.
     *
     * @param string $route_class The class name of the route to be loaded.
     *
     * @return void
     */
    public function register_route($route_class)
    {
    }
    /**
     * Registers a command.
     *
     * @param string $command_class The class name of the command to be loaded.
     *
     * @return void
     */
    public function register_command($command_class)
    {
    }
    /**
     * Registers a migration.
     *
     * @param string $plugin          The plugin the migration belongs to.
     * @param string $version         The version of the migration.
     * @param string $migration_class The class name of the migration to be loaded.
     *
     * @return void
     */
    public function register_migration($plugin, $version, $migration_class)
    {
    }
    /**
     * Loads all registered classes if their conditionals are met.
     *
     * @return void
     */
    public function load()
    {
    }
    /**
     * Returns all registered migrations.
     *
     * @param string $plugin The plugin to get the migrations for.
     *
     * @return string[]|false The registered migrations. False if no migrations were registered.
     */
    public function get_migrations($plugin)
    {
    }
    /**
     * Loads all registered commands.
     *
     * @return void
     */
    protected function load_commands()
    {
    }
    /**
     * Loads all registered initializers if their conditionals are met.
     *
     * @return void
     */
    protected function load_initializers()
    {
    }
    /**
     * Loads all registered integrations if their conditionals are met.
     *
     * @return void
     */
    public function load_integrations()
    {
    }
    /**
     * Loads all registered routes if their conditionals are met.
     *
     * @return void
     */
    public function load_routes()
    {
    }
    /**
     * Checks if all conditionals of a given loadable are met.
     *
     * @param string $loadable_class The class name of the loadable.
     *
     * @return bool Whether all conditionals of the loadable are met.
     */
    protected function conditionals_are_met($loadable_class)
    {
    }
    /**
     * Gets a class from the container.
     *
     * @param string $class The class name.
     *
     * @return object|null The class or, in production environments, null if it does not exist.
     *
     * @throws Throwable If the class does not exist in development environments.
     * @throws Exception If the class does not exist in development environments.
     */
    protected function get_class($class)
    {
    }
  }
}

namespace YoastSEO_Vendor\Psr\Log {
  /**
   * Describes a logger instance.
   *
   * The message MUST be a string or object implementing __toString().
   *
   * The message MAY contain placeholders in the form: {foo} where foo
   * will be replaced by the context data in key "foo".
   *
   * The context array can contain arbitrary data. The only assumption that
   * can be made by implementors is that if an Exception instance is given
   * to produce a stack trace, it MUST be in a key named "exception".
   *
   * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md
   * for the full interface specification.
   */
  interface LoggerInterface
  {
    /**
     * System is unusable.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function emergency($message, array $context = array());
    /**
     * Action must be taken immediately.
     *
     * Example: Entire website down, database unavailable, etc. This should
     * trigger the SMS alerts and wake you up.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function alert($message, array $context = array());
    /**
     * Critical conditions.
     *
     * Example: Application component unavailable, unexpected exception.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function critical($message, array $context = array());
    /**
     * Runtime errors that do not require immediate action but should typically
     * be logged and monitored.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function error($message, array $context = array());
    /**
     * Exceptional occurrences that are not errors.
     *
     * Example: Use of deprecated APIs, poor use of an API, undesirable things
     * that are not necessarily wrong.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function warning($message, array $context = array());
    /**
     * Normal but significant events.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function notice($message, array $context = array());
    /**
     * Interesting events.
     *
     * Example: User logs in, SQL logs.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function info($message, array $context = array());
    /**
     * Detailed debug information.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function debug($message, array $context = array());
    /**
     * Logs with an arbitrary level.
     *
     * @param mixed  $level
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function log($level, $message, array $context = array());
  }
  /**
   * This is a simple Logger trait that classes unable to extend AbstractLogger
   * (because they extend another class, etc) can include.
   *
   * It simply delegates all log-level-specific methods to the `log` method to
   * reduce boilerplate code that a simple Logger that does the same thing with
   * messages regardless of the error level has to implement.
   */
  trait LoggerTrait
  {
    /**
     * System is unusable.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function emergency($message, array $context = array())
    {
    }
    /**
     * Action must be taken immediately.
     *
     * Example: Entire website down, database unavailable, etc. This should
     * trigger the SMS alerts and wake you up.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function alert($message, array $context = array())
    {
    }
    /**
     * Critical conditions.
     *
     * Example: Application component unavailable, unexpected exception.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function critical($message, array $context = array())
    {
    }
    /**
     * Runtime errors that do not require immediate action but should typically
     * be logged and monitored.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function error($message, array $context = array())
    {
    }
    /**
     * Exceptional occurrences that are not errors.
     *
     * Example: Use of deprecated APIs, poor use of an API, undesirable things
     * that are not necessarily wrong.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function warning($message, array $context = array())
    {
    }
    /**
     * Normal but significant events.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function notice($message, array $context = array())
    {
    }
    /**
     * Interesting events.
     *
     * Example: User logs in, SQL logs.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function info($message, array $context = array())
    {
    }
    /**
     * Detailed debug information.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function debug($message, array $context = array())
    {
    }
    /**
     * Logs with an arbitrary level.
     *
     * @param mixed  $level
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public abstract function log($level, $message, array $context = array());
  }
}

namespace Yoast\WP\SEO\Loggers {
  /**
   * Our logger class.
   */
  class Logger implements \YoastSEO_Vendor\Psr\Log\LoggerInterface
  {
    use \YoastSEO_Vendor\Psr\Log\LoggerTrait;
    /**
     * The logger object.
     *
     * @var LoggerInterface
     */
    protected $wrapped_logger;
    /**
     * Logger constructor.
     */
    public function __construct()
    {
    }
    /**
     * Logs with an arbitrary level.
     *
     * @param mixed  $level   The log level.
     * @param string $message The log message.
     * @param array  $context The log context.
     *
     * @return void
     */
    public function log($level, $message, array $context = [])
    {
    }
  }
}

namespace Yoast\WP\SEO {
  /**
   * Class Main.
   *
   * @property Classes_Surface $classes      The classes surface.
   * @property Meta_Surface    $meta         The meta surface.
   * @property Helpers_Surface $helpers      The helpers surface.
   */
  class Main extends \Yoast\WP\Lib\Abstract_Main
  {
    /**
     * The API namespace constant.
     *
     * @var string
     */
    const API_V1_NAMESPACE = 'yoast/v1';
    /**
     * The WP CLI namespace constant.
     *
     * @var string
     */
    const WP_CLI_NAMESPACE = 'yoast';
    /**
     * {@inheritDoc}
     */
    protected function get_container()
    {
    }
    /**
     * {@inheritDoc}
     */
    protected function get_name()
    {
    }
    /**
     * {@inheritDoc}
     */
    protected function get_surfaces()
    {
    }
  }
}

namespace Yoast\WP\SEO\Memoizers {
  /**
   * The meta tags context memoizer.
   */
  class Meta_Tags_Context_Memoizer
  {
    /**
     * The blocks helper.
     *
     * @var Blocks_Helper
     */
    protected $blocks;
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    protected $current_page;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    protected $repository;
    /**
     * The meta tags context.
     *
     * @var Meta_Tags_Context
     */
    protected $context_prototype;
    /**
     * The presentation memoizer.
     *
     * @var Presentation_Memoizer
     */
    protected $presentation_memoizer;
    /**
     * The meta tags context.
     *
     * @var Meta_Tags_Context[]
     */
    protected $cache = [];
    /**
     * Meta_Tags_Context_Memoizer constructor.
     *
     * @param Blocks_Helper         $blocks                The blocks helper.
     * @param Current_Page_Helper   $current_page          The current page helper.
     * @param Indexable_Repository  $repository            Indexable repository.
     * @param Meta_Tags_Context     $context_prototype     The meta tags context prototype.
     * @param Presentation_Memoizer $presentation_memoizer Memoizer for the presentation.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Blocks_Helper $blocks, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page, \Yoast\WP\SEO\Repositories\Indexable_Repository $repository, \Yoast\WP\SEO\Context\Meta_Tags_Context $context_prototype, \Yoast\WP\SEO\Memoizers\Presentation_Memoizer $presentation_memoizer)
    {
    }
    /**
     * Gets the meta tags context for the current page.
     * This function is memoized so every call will return the same result.
     *
     * @return Meta_Tags_Context The meta tags context.
     */
    public function for_current_page()
    {
    }
    /**
     * Gets the meta tags context given an indexable.
     * This function is memoized by the indexable so every call with the same indexable will yield the same result.
     *
     * @param Indexable $indexable The indexable.
     * @param string    $page_type The page type.
     *
     * @return Meta_Tags_Context The meta tags context.
     */
    public function get(\Yoast\WP\SEO\Models\Indexable $indexable, $page_type)
    {
    }
    /**
     * Clears the memoization of either a specific indexable or all indexables.
     *
     * @param Indexable|int|string|null $indexable Optional. The indexable or indexable id to clear the memoization of.
     */
    public function clear($indexable = null)
    {
    }
  }
  /**
   * The presentation memoizer.
   */
  class Presentation_Memoizer
  {
    /**
     * The service container.
     *
     * @var ContainerInterface
     */
    protected $container;
    /**
     * Cache with indexable presentations.
     *
     * @var Indexable_Presentation[]
     */
    protected $cache = [];
    /**
     * Presentation_Memoizer constructor.
     *
     * @param ContainerInterface $service_container The service container.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $service_container)
    {
    }
    /**
     * Gets the presentation of an indexable for a specific page type.
     * This function is memoized by the indexable so every call with the same indexable will yield the same result.
     *
     * @param Indexable         $indexable The indexable to get a presentation of.
     * @param Meta_Tags_Context $context   The current meta tags context.
     * @param string            $page_type The page type.
     *
     * @return Indexable_Presentation The indexable presentation.
     */
    public function get(\Yoast\WP\SEO\Models\Indexable $indexable, \Yoast\WP\SEO\Context\Meta_Tags_Context $context, $page_type)
    {
    }
    /**
     * Clears the memoization of either a specific indexable or all indexables.
     *
     * @param Indexable|int|null $indexable Optional. The indexable or indexable id to clear the memoization of.
     */
    public function clear($indexable = null)
    {
    }
  }
}

namespace Yoast\WP\SEO\Models {
  /**
   * Abstract class for indexable extensions.
   */
  abstract class Indexable_Extension extends \Yoast\WP\Lib\Model
  {
    /**
     * Holds the Indexable instance.
     *
     * @var Indexable
     */
    protected $indexable = null;
    /**
     * Returns the indexable this extension belongs to.
     *
     * @return Indexable The indexable.
     */
    public function indexable()
    {
    }
  }
  /**
   * Indexable Hierarchy model definition.
   *
   * @property int $indexable_id The ID of the indexable.
   * @property int $ancestor_id  The ID of the indexable's ancestor.
   * @property int $depth        The depth of the ancestry. 1 being a parent, 2 being a grandparent etc.
   * @property int $blog_id      Blog ID.
   */
  class Indexable_Hierarchy extends \Yoast\WP\Lib\Model
  {
    /**
     * Which columns contain int values.
     *
     * @var array
     */
    protected $int_columns = ['indexable_id', 'ancestor_id', 'depth', 'blog_id'];
  }
  /**
   * Indexable table definition.
   *
   * @property int    $id
   * @property int    $object_id
   * @property string $object_type
   * @property string $object_sub_type
   *
   * @property int    $author_id
   * @property int    $post_parent
   *
   * @property string $created_at
   * @property string $updated_at
   *
   * @property string $permalink
   * @property string $permalink_hash
   * @property string $canonical
   *
   * @property bool   $is_robots_noindex
   * @property bool   $is_robots_nofollow
   * @property bool   $is_robots_noarchive
   * @property bool   $is_robots_noimageindex
   * @property bool   $is_robots_nosnippet
   *
   * @property string $title
   * @property string $description
   * @property string $breadcrumb_title
   *
   * @property bool   $is_cornerstone
   *
   * @property string $primary_focus_keyword
   * @property int    $primary_focus_keyword_score
   *
   * @property int    $readability_score
   *
   * @property int    $link_count
   * @property int    $incoming_link_count
   * @property int    $number_of_pages
   *
   * @property string $open_graph_title
   * @property string $open_graph_description
   * @property string $open_graph_image
   * @property string $open_graph_image_id
   * @property string $open_graph_image_source
   * @property string $open_graph_image_meta
   *
   * @property string $twitter_title
   * @property string $twitter_description
   * @property string $twitter_image
   * @property string $twitter_image_id
   * @property string $twitter_image_source
   * @property string $twitter_card
   *
   * @property int    $prominent_words_version
   *
   * @property bool   $is_public
   * @property bool   $is_protected
   * @property string $post_status
   * @property bool   $has_public_posts
   *
   * @property int    $blog_id
   *
   * @property string $language
   * @property string $region
   *
   * @property string $schema_page_type
   * @property string $schema_article_type
   *
   * @property bool   $has_ancestors
   *
   * @property int    $estimated_reading_time_minutes
   *
   * @property string $object_last_modified
   * @property string $object_published_at
   *
   * @property int    $version
   */
  class Indexable extends \Yoast\WP\Lib\Model
  {
    /**
     * Holds the ancestors.
     *
     * @var Indexable[]
     */
    public $ancestors = [];
    /**
     * Whether nor this model uses timestamps.
     *
     * @var bool
     */
    protected $uses_timestamps = true;
    /**
     * Which columns contain boolean values.
     *
     * @var array
     */
    protected $boolean_columns = ['is_robots_noindex', 'is_robots_nofollow', 'is_robots_noarchive', 'is_robots_noimageindex', 'is_robots_nosnippet', 'is_cornerstone', 'is_public', 'is_protected', 'has_public_posts', 'has_ancestors'];
    /**
     * Which columns contain int values.
     *
     * @var array
     */
    protected $int_columns = ['id', 'object_id', 'author_id', 'post_parent', 'primary_focus_keyword_score', 'readability_score', 'link_count', 'incoming_link_count', 'number_of_pages', 'prominent_words_version', 'blog_id', 'estimated_reading_time_minutes', 'version'];
    /**
     * The loaded indexable extensions.
     *
     * @var Indexable_Extension[]
     */
    protected $loaded_extensions = [];
    /**
     * Returns an Indexable_Extension by its name.
     *
     * @param string $class_name The class name of the extension to load.
     *
     * @return Indexable_Extension|bool The extension.
     */
    public function get_extension($class_name)
    {
    }
    /**
     * Enhances the save method.
     *
     * @return bool True on success.
     */
    public function save()
    {
    }
    /**
     * Sanitizes the permalink.
     *
     * @return void
     */
    protected function sanitize_permalink()
    {
    }
  }
  /**
   * Primary Term model definition.
   *
   * @property int    $id       Identifier.
   * @property int    $post_id  Post ID.
   * @property int    $term_id  Term ID.
   * @property string $taxonomy Taxonomy.
   * @property int    $blog_id  Blog ID.
   *
   * @property string $created_at
   * @property string $updated_at
   */
  class Primary_Term extends \Yoast\WP\Lib\Model
  {
    /**
     * Whether nor this model uses timestamps.
     *
     * @var bool
     */
    protected $uses_timestamps = true;
    /**
     * Which columns contain int values.
     *
     * @var array
     */
    protected $int_columns = ['id', 'post_id', 'term_id', 'blog_id'];
  }
  /**
   * Table definition for the SEO Links table.
   *
   * @property int    $id
   * @property string $url
   * @property int    $post_id
   * @property int    $target_post_id
   * @property string $type
   * @property int    $indexable_id
   * @property int    $target_indexable_id
   * @property int    $height
   * @property int    $width
   * @property int    $size
   * @property string $language
   * @property string $region
   */
  class SEO_Links extends \Yoast\WP\Lib\Model
  {
    /**
     * Indicates that the link is external.
     *
     * @var string
     */
    const TYPE_INTERNAL = 'internal';
    /**
     * Indicates that the link is internal.
     *
     * @var string
     */
    const TYPE_EXTERNAL = 'external';
    /**
     * Indicates the link is an internal image.
     *
     * @var string
     */
    const TYPE_INTERNAL_IMAGE = 'image-in';
    /**
     * Indicates the link is an external image.
     *
     * @var string
     */
    const TYPE_EXTERNAL_IMAGE = 'image-ex';
    /**
     * Holds the parsed URL. May not be set.
     *
     * @var array
     */
    public $parsed_url;
    /**
     * Which columns contain int values.
     *
     * @var array
     */
    protected $int_columns = ['id', 'post_id', 'target_post_id', 'indexable_id', 'target_indexable_id', 'height', 'width', 'size'];
  }
  /**
   * Table definition for the SEO Meta table.
   *
   * @property int $object_id
   * @property int $internal_link_count
   * @property int $incoming_link_count
   */
  class SEO_Meta extends \Yoast\WP\Lib\Model
  {
    /**
     * Overwrites the default ID column name.
     *
     * @var string
     */
    public static $id_column = 'object_id';
    /**
     * Which columns contain int values.
     *
     * @var array
     */
    protected $int_columns = ['object_id', 'internal_link_count', 'incoming_link_count'];
  }
}

namespace Yoast\WP\SEO\Presentations {
  /**
   * Class Archive_Adjacent.
   *
   * Presentation object for indexables.
   *
   * @property Indexable         $model      The indexable.
   * @property Pagination_Helper $pagination The pagination helper. Should be defined in the parent
   *                                         class because of trait issues in PHP 5.6.
   *                                         For a detailed explanation of the issue, see
   *                                         {@link https://github.com/Yoast/wordpress-seo/pull/18820}.
   */
  trait Archive_Adjacent
  {
    /**
     * Sets the helpers for the trait.
     *
     * @required
     *
     * @codeCoverageIgnore
     *
     * @param Pagination_Helper $pagination The pagination helper.
     */
    public function set_archive_adjacent_helpers(\Yoast\WP\SEO\Helpers\Pagination_Helper $pagination)
    {
    }
    /**
     * Generates the rel prev.
     *
     * @return string
     */
    public function generate_rel_prev()
    {
    }
    /**
     * Generates the rel next.
     *
     * @return string
     */
    public function generate_rel_next()
    {
    }
  }
  /**
   * Class Indexable_Presentation.
   *
   * Presentation object for indexables.
   *
   * @property string       $title
   * @property string       $meta_description
   * @property array        $robots
   * @property string       $canonical
   * @property string       $rel_next
   * @property string       $rel_prev
   * @property string       $open_graph_type
   * @property string       $open_graph_title
   * @property string       $open_graph_description
   * @property array        $open_graph_images
   * @property int          $open_graph_image_id
   * @property string       $open_graph_image
   * @property string       $open_graph_url
   * @property string       $open_graph_site_name
   * @property string       $open_graph_article_publisher
   * @property string       $open_graph_article_author
   * @property string       $open_graph_article_published_time
   * @property string       $open_graph_article_modified_time
   * @property string       $open_graph_locale
   * @property string       $open_graph_fb_app_id
   * @property string       $permalink
   * @property array        $schema
   * @property string       $twitter_card
   * @property string       $twitter_title
   * @property string       $twitter_description
   * @property string       $twitter_image
   * @property string       $twitter_creator
   * @property string       $twitter_site
   * @property object|array $source
   * @property array        $breadcrumbs
   * @property int          $estimated_reading_time_minutes
   * @property array        $googlebot
   * @property array        $bingbot
   */
  class Indexable_Presentation extends \Yoast\WP\SEO\Presentations\Abstract_Presentation
  {
    /**
     * The indexable.
     *
     * @var Indexable
     */
    public $model;
    /**
     * The meta tags context.
     *
     * @var Meta_Tags_Context
     */
    public $context;
    /**
     * The Schema generator.
     *
     * @var Schema_Generator
     */
    protected $schema_generator;
    /**
     * The Open Graph image generator.
     *
     * @var Open_Graph_Image_Generator
     */
    protected $open_graph_image_generator;
    /**
     * The Twitter image generator.
     *
     * @var Twitter_Image_Generator
     */
    protected $twitter_image_generator;
    /**
     * The Open Graph locale generator.
     *
     * @var Open_Graph_Locale_Generator
     */
    private $open_graph_locale_generator;
    /**
     * The breadcrumbs generator.
     *
     * @var Breadcrumbs_Generator
     */
    private $breadcrumbs_generator;
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    protected $current_page;
    /**
     * The image helper.
     *
     * @var Image_Helper
     */
    protected $image;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options;
    /**
     * The URL helper.
     *
     * @var Url_Helper
     */
    protected $url;
    /**
     * The user helper.
     *
     * @var User_Helper
     */
    protected $user;
    /**
     * The indexable helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * The permalink helper.
     *
     * @var Permalink_Helper
     */
    protected $permalink_helper;
    /**
     * The values helper.
     *
     * @var Values_Helper
     */
    protected $values_helper;
    /**
     * Sets the generator dependencies.
     *
     * @required
     *
     * @param Schema_Generator            $schema_generator            The schema generator.
     * @param Open_Graph_Locale_Generator $open_graph_locale_generator The Open Graph locale generator.
     * @param Open_Graph_Image_Generator  $open_graph_image_generator  The Open Graph image generator.
     * @param Twitter_Image_Generator     $twitter_image_generator     The Twitter image generator.
     * @param Breadcrumbs_Generator       $breadcrumbs_generator       The breadcrumbs generator.
     */
    public function set_generators(\Yoast\WP\SEO\Generators\Schema_Generator $schema_generator, \Yoast\WP\SEO\Generators\Open_Graph_Locale_Generator $open_graph_locale_generator, \Yoast\WP\SEO\Generators\Open_Graph_Image_Generator $open_graph_image_generator, \Yoast\WP\SEO\Generators\Twitter_Image_Generator $twitter_image_generator, \Yoast\WP\SEO\Generators\Breadcrumbs_Generator $breadcrumbs_generator)
    {
    }
    /**
     * Used by dependency injection container to inject the helpers.
     *
     * @required
     *
     * @param Image_Helper        $image        The image helper.
     * @param Options_Helper      $options      The options helper.
     * @param Current_Page_Helper $current_page The current page helper.
     * @param Url_Helper          $url          The URL helper.
     * @param User_Helper         $user         The user helper.
     * @param Indexable_Helper    $indexable    The indexable helper.
     * @param Permalink_Helper    $permalink    The permalink helper.
     * @param Values_Helper       $values       The values helper.
     */
    public function set_helpers(\Yoast\WP\SEO\Helpers\Image_Helper $image, \Yoast\WP\SEO\Helpers\Options_Helper $options, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page, \Yoast\WP\SEO\Helpers\Url_Helper $url, \Yoast\WP\SEO\Helpers\User_Helper $user, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable, \Yoast\WP\SEO\Helpers\Permalink_Helper $permalink, \Yoast\WP\SEO\Helpers\Open_Graph\Values_Helper $values)
    {
    }
    /**
     * Gets the permalink from the indexable or generates it if dynamic permalinks are enabled.
     *
     * @return string The permalink.
     */
    public function generate_permalink()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
    /**
     * Generates the meta description.
     *
     * @return string The meta description.
     */
    public function generate_meta_description()
    {
    }
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Gets the base robots value.
     *
     * @return array The base robots value.
     */
    protected function get_base_robots()
    {
    }
    /**
     * Run the robots output content through the `wpseo_robots` filter.
     *
     * @param array $robots The meta robots values to filter.
     *
     * @return array The filtered meta robots values.
     */
    protected function filter_robots($robots)
    {
    }
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the rel prev.
     *
     * @return string The rel prev value.
     */
    public function generate_rel_prev()
    {
    }
    /**
     * Generates the rel next.
     *
     * @return string The rel prev next.
     */
    public function generate_rel_next()
    {
    }
    /**
     * Generates the Open Graph type.
     *
     * @return string The Open Graph type.
     */
    public function generate_open_graph_type()
    {
    }
    /**
     * Generates the open graph title.
     *
     * @return string The open graph title.
     */
    public function generate_open_graph_title()
    {
    }
    /**
     * Generates the open graph description.
     *
     * @return string The open graph description.
     */
    public function generate_open_graph_description()
    {
    }
    /**
     * Generates the open graph images.
     *
     * @return array The open graph images.
     */
    public function generate_open_graph_images()
    {
    }
    /**
     * Generates the open graph image ID.
     *
     * @return string The open graph image ID.
     */
    public function generate_open_graph_image_id()
    {
    }
    /**
     * Generates the open graph image URL.
     *
     * @return string The open graph image URL.
     */
    public function generate_open_graph_image()
    {
    }
    /**
     * Generates the open graph url.
     *
     * @return string The open graph url.
     */
    public function generate_open_graph_url()
    {
    }
    /**
     * Generates the open graph article publisher.
     *
     * @return string The open graph article publisher.
     */
    public function generate_open_graph_article_publisher()
    {
    }
    /**
     * Generates the open graph article author.
     *
     * @return string The open graph article author.
     */
    public function generate_open_graph_article_author()
    {
    }
    /**
     * Generates the open graph article published time.
     *
     * @return string The open graph article published time.
     */
    public function generate_open_graph_article_published_time()
    {
    }
    /**
     * Generates the open graph article modified time.
     *
     * @return string The open graph article modified time.
     */
    public function generate_open_graph_article_modified_time()
    {
    }
    /**
     * Generates the open graph locale.
     *
     * @return string The open graph locale.
     */
    public function generate_open_graph_locale()
    {
    }
    /**
     * Generates the open graph site name.
     *
     * @return string The open graph site name.
     */
    public function generate_open_graph_site_name()
    {
    }
    /**
     * Generates the Twitter card type.
     *
     * @return string The Twitter card type.
     */
    public function generate_twitter_card()
    {
    }
    /**
     * Generates the Twitter title.
     *
     * @return string The Twitter title.
     */
    public function generate_twitter_title()
    {
    }
    /**
     * Generates the Twitter description.
     *
     * @return string The Twitter description.
     */
    public function generate_twitter_description()
    {
    }
    /**
     * Generates the Twitter image.
     *
     * @return string The Twitter image.
     */
    public function generate_twitter_image()
    {
    }
    /**
     * Generates the Twitter creator.
     *
     * @return string The Twitter creator.
     */
    public function generate_twitter_creator()
    {
    }
    /**
     * Generates the Twitter site.
     *
     * @return string The Twitter site.
     */
    public function generate_twitter_site()
    {
    }
    /**
     * Generates the source.
     *
     * @return array The source.
     */
    public function generate_source()
    {
    }
    /**
     * Generates the schema for the page.
     *
     * @codeCoverageIgnore Wrapper method.
     *
     * @return array The Schema object.
     */
    public function generate_schema()
    {
    }
    /**
     * Generates the breadcrumbs for the page.
     *
     * @codeCoverageIgnore Wrapper method.
     *
     * @return array The breadcrumbs.
     */
    public function generate_breadcrumbs()
    {
    }
    /**
     * Generates the estimated reading time.
     *
     * @codeCoverageIgnore Wrapper method.
     *
     * @return int|null The estimated reading time.
     */
    public function generate_estimated_reading_time_minutes()
    {
    }
    /**
     * Strips all nested dependencies from the debug info.
     *
     * @return array
     */
    public function __debugInfo()
    {
    }
  }
  /**
   * Class Indexable_Author_Archive_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Author_Archive_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    use \Yoast\WP\SEO\Presentations\Archive_Adjacent;
    /**
     * Holds the post type helper instance.
     *
     * @var Post_Type_Helper
     */
    protected $post_type;
    /**
     * Holds the author archive helper instance.
     *
     * @var Author_Archive_Helper
     */
    protected $author_archive;
    /**
     * Holds the Pagination_Helper instance.
     *
     * @var Pagination_Helper
     */
    protected $pagination;
    /**
     * Indexable_Author_Archive_Presentation constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Post_Type_Helper      $post_type      The post type helper.
     * @param Author_Archive_Helper $author_archive The author archive helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type, \Yoast\WP\SEO\Helpers\Author_Archive_Helper $author_archive)
    {
    }
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
    /**
     * Generates the meta description.
     *
     * @return string The meta description.
     */
    public function generate_meta_description()
    {
    }
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Generates the Open Graph type.
     *
     * @return string The Open Graph type.
     */
    public function generate_open_graph_type()
    {
    }
    /**
     * Generates the open graph images.
     *
     * @return array The open graph images.
     */
    public function generate_open_graph_images()
    {
    }
    /**
     * Generates the source.
     *
     * @return array The source.
     */
    public function generate_source()
    {
    }
  }
  /**
   * Class Indexable_Date_Archive_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Date_Archive_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    /**
     * Holds the Pagination_Helper instance.
     *
     * @var Pagination_Helper
     */
    protected $pagination;
    /**
     * Indexable_Date_Archive_Presentation constructor.
     *
     * @param Pagination_Helper $pagination The pagination helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Pagination_Helper $pagination)
    {
    }
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
    /**
     * Generates the rel prev.
     *
     * @return string The rel prev value.
     */
    public function generate_rel_prev()
    {
    }
    /**
     * Generates the rel next.
     *
     * @return string The rel prev next.
     */
    public function generate_rel_next()
    {
    }
    /**
     * Generates the open graph url.
     *
     * @return string The open graph url.
     */
    public function generate_open_graph_url()
    {
    }
  }
  /**
   * Class Indexable_Error_Page_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Error_Page_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
  }
  /**
   * Class Indexable_Home_Page_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Home_Page_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    use \Yoast\WP\SEO\Presentations\Archive_Adjacent;
    /**
     * Holds the Pagination_Helper instance.
     *
     * @var Pagination_Helper
     */
    protected $pagination;
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the meta description.
     *
     * @return string The meta description.
     */
    public function generate_meta_description()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
  }
  /**
   * Class Indexable_Post_Type_Archive_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Post_Type_Archive_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    use \Yoast\WP\SEO\Presentations\Archive_Adjacent;
    /**
     * Holds the Pagination_Helper instance.
     *
     * @var Pagination_Helper
     */
    protected $pagination;
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
    /**
     * Generates the source.
     *
     * @return array The source.
     */
    public function generate_source()
    {
    }
  }
  /**
   * Class Indexable_Post_Type_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Post_Type_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    /**
     * Holds the Post_Type_Helper instance.
     *
     * @var Post_Type_Helper
     */
    protected $post_type;
    /**
     * Holds the Date_Helper instance.
     *
     * @var Date_Helper
     */
    protected $date;
    /**
     * Holds the Pagination_Helper instance.
     *
     * @var Pagination_Helper
     */
    protected $pagination;
    /**
     * Holds the Post_Helper instance.
     *
     * @var Post_Helper
     */
    protected $post;
    /**
     * Indexable_Post_Type_Presentation constructor.
     *
     * @codeCoverageIgnore
     *
     * @param Post_Type_Helper  $post_type  The post type helper.
     * @param Date_Helper       $date       The date helper.
     * @param Pagination_Helper $pagination The pagination helper.
     * @param Post_Helper       $post       The post helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type, \Yoast\WP\SEO\Helpers\Date_Helper $date, \Yoast\WP\SEO\Helpers\Pagination_Helper $pagination, \Yoast\WP\SEO\Helpers\Post_Helper $post)
    {
    }
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the rel prev.
     *
     * @return string The rel prev value.
     */
    public function generate_rel_prev()
    {
    }
    /**
     * Generates the rel next.
     *
     * @return string The rel prev next.
     */
    public function generate_rel_next()
    {
    }
    /**
     * Generates the open graph title.
     *
     * @return string The open graph title.
     */
    public function generate_title()
    {
    }
    /**
     * Generates the meta description.
     *
     * @return string The meta description.
     */
    public function generate_meta_description()
    {
    }
    /**
     * Generates the open graph description.
     *
     * @return string The open graph description.
     */
    public function generate_open_graph_description()
    {
    }
    /**
     * Generates the open graph images.
     *
     * @return array The open graph images.
     */
    public function generate_open_graph_images()
    {
    }
    /**
     * Generates the Open Graph type.
     *
     * @return string The Open Graph type.
     */
    public function generate_open_graph_type()
    {
    }
    /**
     * Generates the open graph article author.
     *
     * @return string The open graph article author.
     */
    public function generate_open_graph_article_author()
    {
    }
    /**
     * Generates the open graph article publisher.
     *
     * @return string The open graph article publisher.
     */
    public function generate_open_graph_article_publisher()
    {
    }
    /**
     * Generates the open graph article published time.
     *
     * @return string The open graph article published time.
     */
    public function generate_open_graph_article_published_time()
    {
    }
    /**
     * Generates the open graph article modified time.
     *
     * @return string The open graph article modified time.
     */
    public function generate_open_graph_article_modified_time()
    {
    }
    /**
     * Generates the source.
     *
     * @return array The source.
     */
    public function generate_source()
    {
    }
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Generates the Twitter description.
     *
     * @return string The Twitter description.
     */
    public function generate_twitter_description()
    {
    }
    /**
     * Generates the Twitter image.
     *
     * @return string The Twitter image.
     */
    public function generate_twitter_image()
    {
    }
    /**
     * Generates the Twitter creator.
     *
     * @return string The Twitter creator.
     */
    public function generate_twitter_creator()
    {
    }
    /**
     * Wraps the get_paginated_url pagination helper method.
     *
     * @codeCoverageIgnore A wrapper method.
     *
     * @param string $url  The un-paginated URL of the current archive.
     * @param string $page The page number to add on to $url for the $link tag.
     *
     * @return string The paginated URL.
     */
    protected function get_paginated_url($url, $page)
    {
    }
  }
  /**
   * Class Indexable_Search_Result_Page_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Search_Result_Page_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
    /**
     * Generates the Twitter title.
     *
     * @return string The Twitter title.
     */
    public function generate_twitter_title()
    {
    }
    /**
     * Generates the Open Graph URL.
     *
     * @return string The Open Graph URL.
     */
    public function generate_open_graph_url()
    {
    }
    /**
     * Generates the Open Graph type.
     *
     * @return string The Open Graph type.
     */
    public function generate_open_graph_type()
    {
    }
  }
  /**
   * Class Indexable_Static_Home_Page_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Static_Home_Page_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Post_Type_Presentation
  {
    /**
     * Wraps the get_paginated_url pagination helper method.
     *
     * @param string $url  The un-paginated URL of the current archive.
     * @param string $page The page number to add on to $url for the $link tag.
     *
     * @return string The paginated URL.
     */
    protected function get_paginated_url($url, $page)
    {
    }
    /**
     * Generates the Open Graph type.
     *
     * @return string The Open Graph type.
     */
    public function generate_open_graph_type()
    {
    }
  }
  /**
   * Class Indexable_Static_Posts_Page_Presentation.
   *
   * Presentation object for indexables.
   */
  class Indexable_Static_Posts_Page_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Post_Type_Presentation
  {
    use \Yoast\WP\SEO\Presentations\Archive_Adjacent;
    /**
     * The pagination helper.
     *
     * @var Pagination_Helper
     */
    protected $pagination;
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the Open Graph URL.
     *
     * @return string The Open Graph URL.
     */
    public function generate_open_graph_url()
    {
    }
  }
  /**
   * Class Indexable_Term_Archive_Presentation.
   *
   * Presentation object for indexables.
   *
   * @property WP_Term $source
   */
  class Indexable_Term_Archive_Presentation extends \Yoast\WP\SEO\Presentations\Indexable_Presentation
  {
    use \Yoast\WP\SEO\Presentations\Archive_Adjacent;
    /**
     * Holds the Pagination_Helper instance.
     *
     * @var Pagination_Helper
     */
    protected $pagination;
    /**
     * Holds the WP query wrapper instance.
     *
     * @var WP_Query_Wrapper
     */
    private $wp_query_wrapper;
    /**
     * Holds the taxonomy helper instance.
     *
     * @var Taxonomy_Helper
     */
    private $taxonomy;
    /**
     * Indexable_Post_Type_Presentation constructor.
     *
     * @codeCoverageIgnore
     *
     * @param WP_Query_Wrapper $wp_query_wrapper The wp query wrapper.
     * @param Taxonomy_Helper  $taxonomy         The Taxonomy helper.
     */
    public function __construct(\Yoast\WP\SEO\Wrappers\WP_Query_Wrapper $wp_query_wrapper, \Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy)
    {
    }
    /**
     * Generates the canonical.
     *
     * @return string The canonical.
     */
    public function generate_canonical()
    {
    }
    /**
     * Generates the meta description.
     *
     * @return string The meta description.
     */
    public function generate_meta_description()
    {
    }
    /**
     * Generates the source.
     *
     * @return array The source.
     */
    public function generate_source()
    {
    }
    /**
     * Generates the Open Graph description.
     *
     * @return string The Open Graph description.
     */
    public function generate_open_graph_description()
    {
    }
    /**
     * Generates the Twitter description.
     *
     * @return string The Twitter description.
     */
    public function generate_twitter_description()
    {
    }
    /**
     * Generates the robots value.
     *
     * @return array The robots value.
     */
    public function generate_robots()
    {
    }
    /**
     * Generates the title.
     *
     * @return string The title.
     */
    public function generate_title()
    {
    }
    /**
     * Generates the Open Graph type.
     *
     * @return string The Open Graph type.
     */
    public function generate_open_graph_type()
    {
    }
    /**
     * Checks if term archive query is for multiple terms (/term-1,term-2/ or /term-1+term-2/).
     *
     * @return bool Whether the query contains multiple terms.
     */
    protected function is_multiple_terms_query()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters {
  /**
   * Abstract_Presenter class.
   */
  abstract class Abstract_Presenter
  {
    /**
     * Returns the output as string.
     *
     * @return string The output.
     */
    public abstract function present();
    /**
     * Returns the output as string.
     *
     * @return string The output.
     */
    public function __toString()
    {
    }
  }
  /**
   * Abstract presenter class for indexable presentations.
   */
  abstract class Abstract_Indexable_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The WPSEO Replace Vars object.
     *
     * @var WPSEO_Replace_Vars
     */
    public $replace_vars;
    /**
     * The indexable presentation.
     *
     * @var Indexable_Presentation
     */
    public $presentation;
    /**
     * The helpers surface
     *
     * @var Helpers_Surface
     */
    public $helpers;
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'NO KEY PROVIDED';
    /**
     * Gets the raw value of a presentation.
     *
     * @return string|array The raw value.
     */
    public abstract function get();
    /**
     * Transforms an indexable presenter's key to a json safe key string.
     *
     * @return string|null
     */
    public function escape_key()
    {
    }
    /**
     * Returns the metafield's property key.
     *
     * @return string The property key.
     */
    public function get_key()
    {
    }
    /**
     * Replace replacement variables in a string.
     *
     * @param string $replacevar_string The string with replacement variables.
     *
     * @return string The string with replacement variables replaced.
     */
    protected function replace_vars($replacevar_string)
    {
    }
  }
  /**
   * Abstract presenter class for indexable tag presentations.
   *
   * @phpcs:disable Yoast.Files.FileName.InvalidClassFileName
   */
  abstract class Abstract_Indexable_Tag_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    const META_PROPERTY_CONTENT = '<meta property="%2$s" content="%1$s"%3$s />';
    const META_NAME_CONTENT = '<meta name="%2$s" content="%1$s"%3$s />';
    const LINK_REL_HREF = '<link rel="%2$s" href="%1$s"%3$s />';
    const DEFAULT_TAG_FORMAT = self::META_NAME_CONTENT;
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::DEFAULT_TAG_FORMAT;
    /**
     * The method of escaping to use.
     *
     * @var string
     */
    protected $escaping = 'attribute';
    /**
     * Returns a tag in the head.
     *
     * @return string The tag.
     */
    public function present()
    {
    }
    /**
     * Escaped the output.
     *
     * @param string $value The desired method of escaping; 'html', 'url' or 'attribute'.
     *
     * @return string The escaped value.
     */
    protected function escape_value($value)
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters\Admin {
  /**
   * Represents the presenter class for Alert boxes.
   */
  class Alert_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Content of the Alert.
     *
     * @var string
     */
    private $content = '';
    /**
     * The type of the Alert.
     *
     * Can be: "error", "info", "success" or "warning".
     * Controls the colours and icon of the Alert.
     *
     * @var string
     */
    private $type;
    /**
     * An instance of the WPSEO_Admin_Asset_Manager class.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * Alert_Presenter constructor.
     *
     * @param string $content Content of the Alert.
     * @param string $type    Type of the Alert (error/info/success/warning), default is warning.
     */
    public function __construct($content, $type = 'warning')
    {
    }
    /**
     * Presents the Alert.
     *
     * @return string The styled Alert.
     */
    public function present()
    {
    }
  }
  /**
   * Represents the presenter class for "New" badges.
   */
  class Badge_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Identifier of the badge.
     *
     * @var string
     */
    private $id;
    /**
     * Optional link of the badge.
     *
     * @var string
     */
    private $link;
    /**
     * Optional group which the badge belongs to.
     *
     * Each group has a fixed period after which the group will no longer be considered new and the badges will disappear.
     *
     * @var string
     */
    private $group;
    /**
     * Optional object storing the group names and expiration versions.
     *
     * The group names set in Yoast SEO are used by default, but they can be overridden to use custom ones for an add-on.
     *
     * @var Badge_Group_Names
     */
    private $badge_group_names;
    /**
     * Badge_Presenter constructor.
     *
     * @param string                 $id                Id of the badge.
     * @param string                 $link              Optional link of the badge.
     * @param string                 $group             Optional group which the badge belongs to.
     * @param Badge_Group_Names|null $badge_group_names Optional object storing the group names.
     */
    public function __construct($id, $link = '', $group = '', $badge_group_names = null)
    {
    }
    /**
     * Presents the New Badge. If a link has been passed, the badge is presented with the link.
     * Otherwise a static badge is presented.
     *
     * @return string The styled New Badge.
     */
    public function present()
    {
    }
    /**
     * Check whether the new badge should be shown according to the group it is in.
     *
     * @return bool True if still new.
     */
    public function is_group_still_new()
    {
    }
  }
  /**
   * Represents the presenter class for "Beta" badges.
   */
  class Beta_Badge_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Identifier of the badge.
     *
     * @var string
     */
    private $id;
    /**
     * Optional link of the badge.
     *
     * @var string
     */
    private $link;
    /**
     * Beta_Badge_Presenter constructor.
     *
     * @param string $id   Id of the badge.
     * @param string $link Optional link of the badge.
     */
    public function __construct($id, $link = '')
    {
    }
    /**
     * Presents the Beta Badge. If a link has been passed, the badge is presented with the link.
     * Otherwise a static badge is presented.
     *
     * @return string The styled Beta Badge.
     */
    public function present()
    {
    }
  }
  /**
   * Represents the presenter class for Help link.
   */
  class Help_Link_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Help link.
     *
     * @var string
     */
    private $link;
    /**
     * Help link visually hidden text.
     *
     * @var string
     */
    private $link_text;
    /**
     * Whether the Help link opens in a new browser tab.
     *
     * @var bool
     */
    private $opens_in_new_browser_tab;
    /**
     * An instance of the WPSEO_Admin_Asset_Manager class.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    private $asset_manager;
    /**
     * Help_Link_Presenter constructor.
     *
     * @param string $link                     Help link.
     * @param string $link_text                Help link visually hidden text.
     * @param bool   $opens_in_new_browser_tab Whether the link opens in a new browser tab. Default true.
     */
    public function __construct($link = '', $link_text = '', $opens_in_new_browser_tab = true)
    {
    }
    /**
     * Presents the Help link.
     *
     * @return string The styled Help link.
     */
    public function present()
    {
    }
  }
  /**
   * An error that should be shown when indexation has failed.
   */
  class Indexing_Error_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The short link helper.
     *
     * @var Short_Link_Helper
     */
    protected $short_link_helper;
    /**
     * The product helper
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $addon_manager;
    /**
     * Indexing_Error_Presenter constructor.
     *
     * @param Short_Link_Helper   $short_link_helper Represents the short link helper.
     * @param Product_Helper      $product_helper    The product helper.
     * @param WPSEO_Addon_Manager $addon_manager     The addon manager.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Short_Link_Helper $short_link_helper, \Yoast\WP\SEO\Helpers\Product_Helper $product_helper, \WPSEO_Addon_Manager $addon_manager)
    {
    }
    /**
     * Generates the first paragraph of the error message to show when indexing failed.
     *
     * The contents of the paragraph varies based on whether WordPress SEO Premium has a valid, activated subscription or not.
     *
     * @param bool $is_premium                     Whether WordPress SEO Premium is currently active.
     * @param bool $has_valid_premium_subscription Whether WordPress SEO Premium currently has a valid subscription.
     *
     * @return string
     */
    protected function generate_first_paragraph($is_premium, $has_valid_premium_subscription)
    {
    }
    /**
     * Generates the second paragraph of the error message to show when indexing failed.
     *
     * The error message varies based on whether WordPress SEO Premium has a valid, activated subscription or not.
     *
     * @param bool $is_premium                     Whether WordPress SEO Premium is currently active.
     * @param bool $has_valid_premium_subscription Whether WordPress SEO Premium currently has a valid subscription.
     *
     * @return string The second paragraph of the error message.
     */
    protected function generate_second_paragraph($is_premium, $has_valid_premium_subscription)
    {
    }
    /**
     * Presents the error message to show if SEO optimization failed.
     *
     * The error message varies based on whether WordPress SEO Premium has a valid, activated subscription or not.
     *
     * @return string The error message to show.
     */
    public function present()
    {
    }
  }
  /**
   * Class Indexing_Failed_Notification_Presenter.
   *
   * @package Yoast\WP\SEO\Presenters\Notifications
   */
  class Indexing_Failed_Notification_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The product helper.
     *
     * @var Product_Helper
     */
    protected $product_helper;
    /**
     * The addon manager.
     *
     * @var WPSEO_Addon_Manager
     */
    protected $class_addon_manager;
    /**
     * The short link helper.
     *
     * @var Short_Link_Helper
     */
    protected $short_link_helper;
    /**
     * Indexing_Failed_Notification_Presenter constructor.
     *
     * @param Product_Helper      $product_helper      The product helper.
     * @param Short_Link_Helper   $short_link_helper   The addon manager.
     * @param WPSEO_Addon_Manager $class_addon_manager The addon manager.
     */
    public function __construct($product_helper, $short_link_helper, $class_addon_manager)
    {
    }
    /**
     * Returns the notification as an HTML string.
     *
     * @return string The notification in an HTML string representation.
     */
    public function present()
    {
    }
    /**
     * Determines if the site has a valid Premium subscription.
     *
     * @return bool
     */
    protected function has_valid_premium_subscription()
    {
    }
  }
  /**
   * Class Indexing_List_Item_Presenter.
   *
   * @package Yoast\WP\SEO\Presenters\Admin
   */
  class Indexing_List_Item_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The short link helper.
     *
     * @var Short_Link_Helper
     */
    protected $short_link_helper;
    /**
     * Indexing_List_Item_Presenter constructor.
     *
     * @param Short_Link_Helper $short_link_helper Represents the short link helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Short_Link_Helper $short_link_helper)
    {
    }
    /**
     * Presents the list item for the tools menu.
     *
     * @return string The list item HTML.
     */
    public function present()
    {
    }
  }
  /**
   * Class Indexing_Notification_Presenter.
   *
   * @package Yoast\WP\SEO\Presenters\Admin
   */
  class Indexing_Notification_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The total number of unindexed objects.
     *
     * @var int
     */
    protected $total_unindexed;
    /**
     * The message to show in the notification.
     *
     * @var string
     */
    protected $reason;
    /**
     * The short link helper.
     *
     * @var Short_Link_Helper
     */
    protected $short_link_helper;
    /**
     * Indexing_Notification_Presenter constructor.
     *
     * @param Short_Link_Helper $short_link_helper The short link helper.
     * @param int               $total_unindexed   Total number of unindexed objects.
     * @param string            $reason            The reason to show in the notification.
     */
    public function __construct($short_link_helper, $total_unindexed, $reason)
    {
    }
    /**
     * Returns the notification as an HTML string.
     *
     * @return string The HTML string representation of the notification.
     */
    public function present()
    {
    }
    /**
     * Determines the message to show in the indexing notification.
     *
     * @param string $reason The reason identifier.
     *
     * @return string The message to show in the notification.
     */
    protected function get_message($reason)
    {
    }
    /**
     * Creates a time estimate based on the total number on unindexed objects.
     *
     * @param int $total_unindexed The total number of unindexed objects.
     *
     * @return string The time estimate as a HTML string.
     */
    protected function get_time_estimate($total_unindexed)
    {
    }
  }
  /**
   * Class Light_Switch_Presenter.
   *
   * @package Yoast\WP\SEO\Presenters\Admin
   */
  class Light_Switch_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The variable to create the checkbox for.
     *
     * @var string
     */
    protected $var;
    /**
     * The visual label text for the toggle.
     *
     * @var string
     */
    protected $label;
    /**
     * Array of two visual labels for the buttons.
     *
     * @var array
     */
    protected $buttons;
    /**
     * The name of the underlying checkbox.
     *
     * @var string
     */
    protected $name;
    /**
     * The variable current value.
     *
     * @var string|bool
     */
    protected $value;
    /**
     * Reverse order of buttons.
     *
     * @var bool
     */
    protected $reverse;
    /**
     * The inline Help HTML.
     *
     * @var string
     */
    protected $help;
    /**
     * Whether the visual label is displayed in strong text.
     *
     * @var bool
     */
    protected $strong;
    /**
     * The disabled attribute HTML.
     *
     * @var string
     */
    protected $disabled_attribute;
    /**
     * Light_Switch_Presenter constructor.
     *
     * @param string      $variable           The variable to create the checkbox for.
     * @param string      $label              The visual label text for the toggle.
     * @param array       $buttons            Array of two visual labels for the buttons (defaults Disabled/Enabled).
     * @param string      $name               The name of the underlying checkbox.
     * @param string|bool $value              The variable current value, to determine the checked attribute.
     * @param bool        $reverse            Optional. Reverse order of buttons (default true).
     * @param string      $help               Optional. Inline Help HTML that will be printed out before the toggle. Default is empty.
     * @param bool        $strong             Optional. Whether the visual label is displayed in strong text. Default is false.
     *                                        Starting from Yoast SEO 16.5, the visual label is forced to bold via CSS.
     * @param string      $disabled_attribute Optional. The disabled HTML attribute. Default is empty.
     */
    public function __construct($variable, $label, $buttons, $name, $value, $reverse = true, $help = '', $strong = false, $disabled_attribute = '')
    {
    }
    /**
     * Presents the light switch toggle.
     *
     * @return string The light switch's HTML.
     */
    public function present()
    {
    }
  }
  /**
   * Presenter class for meta fields in the post editor.
   *
   * Outputs the hidden fields for a particular field group and post.
   */
  class Meta_Fields_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The meta fields for which we are going to output hidden input.
     *
     * @var array
     */
    private $meta_fields;
    /**
     * The metabox post.
     *
     * @var WP_Post The metabox post.
     */
    private $post;
    /**
     * Meta_Fields_Presenter constructor.
     *
     * @param WP_Post $post        The metabox post.
     * @param string  $field_group The key under which a group of fields is grouped.
     * @param string  $post_type   The post type.
     */
    public function __construct($post, $field_group, $post_type = 'post')
    {
    }
    /**
     * Presents the Meta Fields.
     *
     * @return string The styled Alert.
     */
    public function present()
    {
    }
  }
  /**
   * Presenter class for the migration error.
   */
  class Migration_Error_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Holds the migration error.
     *
     * The array holds the following values if filled:
     * - int|false $time    The timestamp.
     * - string    $version The Yoast SEO version.
     * - string    $message The error message.
     *
     * @var array
     */
    protected $migration_error;
    /**
     * Migration_Error_Presenter constructor.
     *
     * @param array $migration_error The migration error.
     */
    public function __construct($migration_error)
    {
    }
    /**
     * Presents the migration error that occurred.
     *
     * @return string The error HTML.
     */
    public function present()
    {
    }
  }
  /**
   * Represents the presenter class for Yoast-styled WordPress admin notices.
   */
  class Notice_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * The title of the admin notice.
     *
     * @var string
     */
    private $title;
    /**
     * The content of the admin notice.
     *
     * @var string
     */
    private $content;
    /**
     * The filename of the image for the notice. Should be a file in the 'images' folder.
     *
     * @var string
     */
    private $image_filename;
    /**
     * HTML string to be displayed after the main content, usually a button.
     *
     * @var string
     */
    private $button;
    /**
     * Whether the notice should be dismissible.
     *
     * @var bool
     */
    private $is_dismissible;
    /**
     * The id for the div of the notice.
     *
     * @var string
     */
    private $id;
    /**
     * An instance of the WPSEO_Admin_Asset_Manager class.
     *
     * @var WPSEO_Admin_Asset_Manager
     */
    protected $asset_manager;
    /**
     * Notice_Presenter constructor.
     *
     * @param string      $title          Title of the admin notice.
     * @param string      $content        Content of the admin notice.
     * @param string|null $image_filename Optional. The filename of the image of the admin notice,
     *                                    should be inside the 'images' folder.
     * @param string|null $button         Optional. An HTML string to be displayed after the main content,
     *                                    usually a button.
     * @param bool        $is_dismissible Optional. Whether the admin notice should be dismissible.
     * @param string      $id             Optional. The id of the notice.
     */
    public function __construct($title, $content, $image_filename = null, $button = null, $is_dismissible = false, $id = '')
    {
    }
    /**
     * Presents the Notice.
     *
     * @return string The styled Notice.
     */
    public function present()
    {
    }
  }
  /**
   * Represents the presenter class for "Premium" badges.
   */
  class Premium_Badge_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Identifier of the badge.
     *
     * @var string
     */
    private $id;
    /**
     * Optional link of the badge.
     *
     * @var string
     */
    private $link;
    /**
     * Premium_Badge_Presenter constructor.
     *
     * @param string $id   Id of the badge.
     * @param string $link Optional link of the badge.
     */
    public function __construct($id, $link = '')
    {
    }
    /**
     * Presents the Premium Badge. If a link has been passed, the badge is presented with the link.
     * Otherwise a static badge is presented.
     *
     * @return string The styled Premium Badge.
     */
    public function present()
    {
    }
  }
  /**
   * Class Search_Engines_Discouraged_Presenter.
   */
  class Search_Engines_Discouraged_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Returns the notification as an HTML string.
     *
     * @return string The notification in an HTML string representation.
     */
    public function present()
    {
    }
    /**
     * Returns the message to show.
     *
     * @return string The message.
     */
    protected function get_message()
    {
    }
  }
  /**
   * Presenter class for the Yoast SEO sidebar.
   */
  class Sidebar_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Presents the sidebar.
     *
     * @return string The sidebar HTML.
     */
    public function present()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters {
  /**
   * Presenter class for the breadcrumbs.
   */
  class Breadcrumbs_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    /**
     * The id attribute.
     *
     * @var string
     */
    private $id;
    /**
     * The class name attribute.
     *
     * @var string
     */
    private $class;
    /**
     * The wrapper element name.
     *
     * @var string
     */
    private $wrapper;
    /**
     * Separator to use.
     *
     * @var string
     */
    private $separator;
    /**
     * The element.
     *
     * @var string
     */
    private $element;
    /**
     * Presents the breadcrumbs.
     *
     * @return string The breadcrumbs HTML.
     */
    public function present()
    {
    }
    /**
     * Gets the raw value of a presentation.
     *
     * @return array The raw value.
     */
    public function get()
    {
    }
    /**
     * Filters the output.
     *
     * @param string $output The HTML output.
     *
     * @return string The filtered output.
     */
    protected function filter($output)
    {
    }
    /**
     * Create a breadcrumb element string.
     *
     * @param array $breadcrumb Link info array containing the keys:
     *                          'text'                  => (string) link text.
     *                          'url'                   => (string) link url.
     *                          (optional) 'title'      => (string) link title attribute text.
     * @param int   $index      Index for the current breadcrumb.
     * @param int   $total      The total number of breadcrumbs.
     *
     * @return string The breadcrumb link.
     */
    protected function crumb_to_link($breadcrumb, $index, $total)
    {
    }
    /**
     * Retrieves HTML ID attribute.
     *
     * @return string The id attribute.
     */
    protected function get_id()
    {
    }
    /**
     * Retrieves HTML Class attribute.
     *
     * @return string The class attribute.
     */
    protected function get_class()
    {
    }
    /**
     * Retrieves the wrapper element name.
     *
     * @return string The wrapper element name.
     */
    protected function get_wrapper()
    {
    }
    /**
     * Retrieves the separator.
     *
     * @return string The separator.
     */
    protected function get_separator()
    {
    }
    /**
     * Retrieves the crumb element name.
     *
     * @return string The element to use.
     */
    protected function get_element()
    {
    }
  }
  /**
   * Presenter class for the canonical.
   */
  class Canonical_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'canonical';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::LINK_REL_HREF;
    /**
     * The method of escaping to use.
     *
     * @var string
     */
    protected $escaping = 'url';
    /**
     * Run the canonical content through the `wpseo_canonical` filter.
     *
     * @return string The filtered canonical.
     */
    public function get()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters\Debug {
  /**
   * Presenter class for the debug close marker.
   */
  final class Marker_Close_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    /**
     * Returns the debug close marker.
     *
     * @return string The debug close marker.
     */
    public function present()
    {
    }
    /**
     * Gets the raw value of a presentation.
     *
     * @return string The raw value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the debug open marker.
   */
  final class Marker_Open_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    /**
     * Returns the debug close marker.
     *
     * @return string The debug close marker.
     */
    public function present()
    {
    }
    /**
     * Gets the plugin version information, including the free version if Premium is used.
     *
     * @return string The constructed version information.
     */
    private function construct_version_info()
    {
    }
    /**
     * Gets the raw value of a presentation.
     *
     * @return string The raw value.
     */
    public function get()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters {
  /**
   * Presenter class for the meta author tag.
   */
  class Meta_Author_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'author';
    /**
     * Returns the author for a post in a meta author tag.
     *
     * @return string The meta author tag.
     */
    public function present()
    {
    }
    /**
     * Get the author's display name.
     *
     * @return string The author's display name.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the meta description.
   */
  class Meta_Description_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'description';
    /**
     * Returns the meta description for a post.
     *
     * @return string The meta description tag.
     */
    public function present()
    {
    }
    /**
     * Run the meta description content through replace vars, the `wpseo_metadesc` filter and sanitization.
     *
     * @return string The filtered meta description.
     */
    public function get()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters\Open_Graph {
  /**
   * Presenter class for the Open Graph article author.
   */
  class Article_Author_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'article:author';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Run the article author's Facebook URL through the `wpseo_opengraph_author_facebook` filter.
     *
     * @return string The filtered article author's Facebook URL.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph article modified time.
   */
  class Article_Modified_Time_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'article:modified_time';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Gets the raw value of a presentation.
     *
     * @return string The raw value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph article published time.
   */
  class Article_Published_Time_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'article:published_time';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Gets the raw value of a presentation.
     *
     * @return string The raw value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph article publisher.
   */
  class Article_Publisher_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'article:publisher';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Run the article publisher's Facebook URL through the `wpseo_og_article_publisher` filter.
     *
     * @return string The filtered article publisher's Facebook URL.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph description.
   */
  class Description_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'og:description';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Run the Open Graph description through replace vars and the `wpseo_opengraph_desc` filter and sanitization.
     *
     * @return string The filtered description.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph image.
   */
  class Image_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'og:image';
    /**
     * Image tags that we output for each image.
     *
     * @var array
     */
    protected static $image_tags = ['width' => 'width', 'height' => 'height', 'type' => 'type'];
    /**
     * Returns the image for a post.
     *
     * @return string The image tag.
     */
    public function present()
    {
    }
    /**
     * Gets the raw value of a presentation.
     *
     * @return array The raw value.
     */
    public function get()
    {
    }
    /**
     * Run the image content through the `wpseo_opengraph_image` filter.
     *
     * @param array $image The image.
     *
     * @return array The filtered image.
     */
    protected function filter($image)
    {
    }
  }
  /**
   * Final presenter class for the Open Graph locale.
   */
  final class Locale_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'og:locale';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Run the locale through the `wpseo_og_locale` filter.
     *
     * @return string The filtered locale.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph site name.
   */
  class Site_Name_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'og:site_name';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Runs the site name through the `wpseo_opengraph_site_name` filter.
     *
     * @return string The filtered site_name.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph title.
   */
  class Title_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'og:title';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Run the title content through replace vars, the `wpseo_opengraph_title` filter and sanitization.
     *
     * @return string The filtered title.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph type.
   */
  class Type_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'og:type';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * Run the opengraph type content through the `wpseo_opengraph_type` filter.
     *
     * @return string The filtered type.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Open Graph URL.
   */
  class Url_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'og:url';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::META_PROPERTY_CONTENT;
    /**
     * The method of escaping to use.
     *
     * @var string
     */
    protected $escaping = 'attribute';
    /**
     * Run the url content through the `wpseo_opengraph_url` filter.
     *
     * @return string The filtered url.
     */
    public function get()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters {
  /**
   * Presenter class for the rel next meta tag.
   */
  class Rel_Next_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'next';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::LINK_REL_HREF;
    /**
     * The method of escaping to use.
     *
     * @var string
     */
    protected $escaping = 'url';
    /**
     * Returns the rel next meta tag.
     *
     * @return string The rel next tag.
     */
    public function present()
    {
    }
    /**
     * Run the canonical content through the `wpseo_adjacent_rel_url` filter.
     *
     * @return string The filtered adjacent link.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the rel prev meta tag.
   */
  class Rel_Prev_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'prev';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = self::LINK_REL_HREF;
    /**
     * The method of escaping to use.
     *
     * @var string
     */
    protected $escaping = 'url';
    /**
     * Returns the rel prev meta tag.
     *
     * @param bool $output_tag Optional. Whether or not to output the HTML tag. Defaults to true.
     *
     * @return string The rel prev tag.
     */
    public function present($output_tag = true)
    {
    }
    /**
     * Run the rel prev content through the `wpseo_adjacent_rel_url` filter.
     *
     * @return string The filtered adjacent link.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the robots output.
   */
  class Robots_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'robots';
    /**
     * Returns the robots output.
     *
     * @return string The robots output tag.
     */
    public function present()
    {
    }
    /**
     * Gets the raw value of a presentation.
     *
     * @return array The raw value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the robots.txt file helper.
   */
  class Robots_Txt_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    const YOAST_OUTPUT_BEFORE_COMMENT = '# START YOAST BLOCK' . \PHP_EOL . '# ---------------------------' . \PHP_EOL;
    const YOAST_OUTPUT_AFTER_COMMENT = '# ---------------------------' . \PHP_EOL . '# END YOAST BLOCK';
    /**
     * Text to be outputted for the allow directive.
     *
     * @var string
     */
    const ALLOW_DIRECTIVE = 'Allow';
    /**
     * Text to be outputted for the disallow directive.
     *
     * @var string
     */
    const DISALLOW_DIRECTIVE = 'Disallow';
    /**
     * Text to be outputted for the user-agent rule.
     *
     * @var string
     */
    const USER_AGENT_FIELD = 'User-agent';
    /**
     * Text to be outputted for the sitemap rule.
     *
     * @var string
     */
    const SITEMAP_FIELD = 'Sitemap';
    /**
     * Holds the Robots_Txt_Helper.
     *
     * @var Robots_Txt_Helper
     */
    protected $robots_txt_helper;
    /**
     * Constructor.
     *
     * @param Robots_Txt_Helper $robots_txt_helper The robots txt helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Robots_Txt_Helper $robots_txt_helper)
    {
    }
    /**
     * Generate content to be placed in a robots.txt file.
     *
     * @return string Content to be placed in a robots.txt file.
     */
    public function present()
    {
    }
    /**
     * Adds user agent directives to the robots txt output string.
     *
     * @param array  $user_agents        The list if available user agents.
     * @param string $robots_txt_content The current working robots txt string.
     *
     * @return string
     */
    private function add_user_agent_directives($user_agents, $robots_txt_content)
    {
    }
    /**
     *  Adds user agent directives path content to the robots txt output string.
     *
     * @param string $robots_txt_content   The current working robots txt string.
     * @param array  $paths                The list of paths for which to add a txt entry.
     * @param string $directive_identifier The identifier for the directives. (Disallow of Allow).
     *
     * @return string
     */
    private function add_directive_path($robots_txt_content, $paths, $directive_identifier)
    {
    }
    /**
     * Handles adding user agent content to the robots txt content if there is any.
     *
     * @param string $robots_txt_content The current working robots txt string.
     *
     * @return string
     */
    private function handle_user_agents($robots_txt_content)
    {
    }
    /**
     * Handles adding sitemap content to the robots txt content.
     *
     * @param string $robots_txt_content The current working robots txt string.
     *
     * @return string
     */
    private function handle_site_maps($robots_txt_content)
    {
    }
  }
  /**
   * Presenter class for the schema object.
   */
  class Schema_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'schema';
    /**
     * Returns the schema output.
     *
     * @return string The schema tag.
     */
    public function present()
    {
    }
    /**
     * Gets the raw value of a presentation.
     *
     * @return array The raw value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for a score icon.
   */
  class Score_Icon_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * Holds the title.
     *
     * @var string
     */
    protected $title;
    /**
     * Holds the CSS class.
     *
     * @var string
     */
    protected $css_class;
    /**
     * Constructs a Score_Icon_Presenter.
     *
     * @param string $title     The title and screen reader text.
     * @param string $css_class The CSS class.
     */
    public function __construct($title, $css_class)
    {
    }
    /**
     * Presents the score icon.
     *
     * @return string The score icon.
     */
    public function present()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters\Slack {
  /**
   * Presenter class for the Slack enhanced data.
   */
  class Enhanced_Data_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'twitter:misc';
    /**
     * Presents the enhanced data for Slack
     *
     * @return string The Twitter tags for Slack.
     */
    public function present()
    {
    }
    /**
     * Gets the enhanced data array.
     *
     * @return array The enhanced data array
     */
    public function get()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters {
  /**
   * Presenter class for the document title.
   */
  class Title_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'title';
    /**
     * The tag format including placeholders.
     *
     * @var string
     */
    protected $tag_format = '<title>%s</title>';
    /**
     * The method of escaping to use.
     *
     * @var string
     */
    protected $escaping = 'html';
    /**
     * Gets the raw value of a presentation.
     *
     * @return string The raw value.
     */
    public function get()
    {
    }
    /**
     * Returns a tag in the head.
     *
     * @return string The tag.
     */
    public function present()
    {
    }
    /**
     * Returns the presentation title.
     *
     * @return string The title.
     */
    public function get_title()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters\Twitter {
  /**
   * Presenter class for the Twitter Card tag.
   */
  class Card_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'twitter:card';
    /**
     * Runs the card type through the `wpseo_twitter_card_type` filter.
     *
     * @return string The filtered card type.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Twitter creator.
   */
  class Creator_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'twitter:creator';
    /**
     * Gets the raw value of a presentation.
     *
     * @return string The raw value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Twitter description.
   */
  class Description_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'twitter:description';
    /**
     * Run the Twitter description through replace vars and the `wpseo_twitter_description` filter.
     *
     * @return string The filtered Twitter description.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Twitter image.
   */
  class Image_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'twitter:image';
    /**
     * The method of escaping to use.
     *
     * @var string
     */
    protected $escaping = 'url';
    /**
     * Run the Twitter image value through the `wpseo_twitter_image` filter.
     *
     * @return string The filtered Twitter image.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Twitter site tag.
   */
  class Site_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'twitter:site';
    /**
     * Run the Twitter site through the `wpseo_twitter_site` filter.
     *
     * @return string The filtered Twitter site.
     */
    public function get()
    {
    }
    /**
     * Checks if the given id is actually an id or a url and if url, distills the id from it.
     *
     * Solves issues with filters returning urls and theme's/other plugins also adding a user meta
     * twitter field which expects url rather than an id (which is what we expect).
     *
     * @param string $id Twitter ID or url.
     *
     * @return string|bool Twitter ID or false if it failed to get a valid Twitter ID.
     */
    private function get_twitter_id($id)
    {
    }
  }
  /**
   * Presenter class for the Twitter title.
   */
  class Title_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'twitter:title';
    /**
     * Run the Twitter title through replace vars and the `wpseo_twitter_title` filter.
     *
     * @return string The filtered Twitter title.
     */
    public function get()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters {
  /**
   * Presenter class for the URL list.
   */
  class Url_List_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Presenter
  {
    /**
     * A list of arrays containing titles and URLs.
     *
     * @var array
     */
    private $links;
    /**
     * Classname for the URL list.
     *
     * @var string
     */
    private $class_name;
    /**
     * Url_List_Presenter constructor.
     *
     * @param array  $links      A list of arrays containing titles and urls.
     * @param string $class_name Classname for the url list.
     */
    public function __construct($links, $class_name = 'yoast-url-list')
    {
    }
    /**
     * Presents the URL list.
     *
     * @return string The URL list.
     */
    public function present()
    {
    }
  }
}

namespace Yoast\WP\SEO\Presenters\Webmaster {
  /**
   * Presenter class for the Baidu Webmaster Tools verification setting.
   */
  class Baidu_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'baidu-site-verification';
    /**
     * Retrieves the webmaster tool site verification value from the settings.
     *
     * @return string The webmaster tool site verification value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Bing Webmaster verification setting.
   */
  class Bing_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'msvalidate.01';
    /**
     * Retrieves the webmaster tool site verification value from the settings.
     *
     * @return string The webmaster tool site verification value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Google Search Console verification setting.
   */
  class Google_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'google-site-verification';
    /**
     * Retrieves the webmaster tool site verification value from the settings.
     *
     * @return string The webmaster tool site verification value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Pinterest Webmaster verification setting.
   */
  class Pinterest_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'p:domain_verify';
    /**
     * Retrieves the webmaster tool site verification value from the settings.
     *
     * @return string The webmaster tool site verification value.
     */
    public function get()
    {
    }
  }
  /**
   * Presenter class for the Yandex Webmaster verification setting.
   */
  class Yandex_Presenter extends \Yoast\WP\SEO\Presenters\Abstract_Indexable_Tag_Presenter
  {
    /**
     * The tag key name.
     *
     * @var string
     */
    protected $key = 'yandex-verification';
    /**
     * Retrieves the webmaster tool site verification value from the settings.
     *
     * @return string The webmaster tool site verification value.
     */
    public function get()
    {
    }
  }
}

namespace Yoast\WP\SEO\Repositories {
  /**
   * Class Indexable_Hierarchy_Repository.
   */
  class Indexable_Hierarchy_Repository
  {
    /**
     * Represents the indexable hierarchy builder.
     *
     * @var Indexable_Hierarchy_Builder
     */
    protected $builder;
    /**
     * Sets the hierarchy builder.
     *
     * @required
     *
     * @param Indexable_Hierarchy_Builder $builder The indexable hierarchy builder.
     */
    public function set_builder(\Yoast\WP\SEO\Builders\Indexable_Hierarchy_Builder $builder)
    {
    }
    /**
     * Removes all ancestors for an indexable.
     *
     * @param int $indexable_id The indexable id.
     *
     * @return bool Whether or not the indexables were successfully deleted.
     */
    public function clear_ancestors($indexable_id)
    {
    }
    /**
     * Adds an ancestor to an indexable.
     *
     * @param int $indexable_id The indexable id.
     * @param int $ancestor_id  The ancestor id.
     * @param int $depth        The depth.
     *
     * @return bool Whether or not the ancestor was added successfully.
     */
    public function add_ancestor($indexable_id, $ancestor_id, $depth)
    {
    }
    /**
     * Retrieves the ancestors. Create them when empty.
     *
     * @param Indexable $indexable The indexable to get the ancestors for.
     *
     * @return int[] The indexable id's of the ancestors in order of grandparent to child.
     */
    public function find_ancestors(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Finds the children for a given indexable.
     *
     * @param Indexable $indexable The indexable to find the children for.
     *
     * @return array Array with indexable id's for the children.
     */
    public function find_children(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Starts a query for this repository.
     *
     * @return ORM
     */
    public function query()
    {
    }
    /**
     * Finds all the children by given ancestor id's.
     *
     * @param array $object_ids List of id's to get the children for.
     *
     * @return array List of indexable id's for the children.
     */
    public function find_children_by_ancestor_ids(array $object_ids)
    {
    }
  }
  /**
   * Class Indexable_Repository.
   */
  class Indexable_Repository
  {
    /**
     * The indexable builder.
     *
     * @var Indexable_Builder
     */
    private $builder;
    /**
     * Represents the hierarchy repository.
     *
     * @var Indexable_Hierarchy_Repository
     */
    protected $hierarchy_repository;
    /**
     * The current page helper.
     *
     * @var Current_Page_Helper
     */
    protected $current_page;
    /**
     * The logger object.
     *
     * @var LoggerInterface
     */
    protected $logger;
    /**
     * The WordPress database.
     *
     * @var wpdb
     */
    protected $wpdb;
    /**
     * Represents the indexable helper.
     *
     * @var Indexable_Helper
     */
    protected $indexable_helper;
    /**
     * Checks if Indexables are up to date.
     *
     * @var Indexable_Version_Manager
     */
    protected $version_manager;
    /**
     * Returns the instance of this class constructed through the ORM Wrapper.
     *
     * @param Indexable_Builder              $builder              The indexable builder.
     * @param Current_Page_Helper            $current_page         The current post helper.
     * @param Logger                         $logger               The logger.
     * @param Indexable_Hierarchy_Repository $hierarchy_repository The hierarchy repository.
     * @param wpdb                           $wpdb                 The WordPress database instance.
     * @param Indexable_Version_Manager      $version_manager      The indexable version manager.
     */
    public function __construct(\Yoast\WP\SEO\Builders\Indexable_Builder $builder, \Yoast\WP\SEO\Helpers\Current_Page_Helper $current_page, \Yoast\WP\SEO\Loggers\Logger $logger, \Yoast\WP\SEO\Repositories\Indexable_Hierarchy_Repository $hierarchy_repository, \wpdb $wpdb, \Yoast\WP\SEO\Services\Indexables\Indexable_Version_Manager $version_manager)
    {
    }
    /**
     * Starts a query for this repository.
     *
     * @return ORM
     */
    public function query()
    {
    }
    /**
     * Attempts to find the indexable for the current WordPress page. Returns false if no indexable could be found.
     * This may be the result of the indexable not existing or of being unable to determine what type of page the
     * current page is.
     *
     * @return bool|Indexable The indexable. If no indexable is found returns an empty indexable. Returns false if there is a database error.
     */
    public function for_current_page()
    {
    }
    /**
     * Retrieves an indexable by its permalink.
     *
     * @param string $permalink The indexable permalink.
     *
     * @return bool|Indexable The indexable, false if none could be found.
     */
    public function find_by_permalink($permalink)
    {
    }
    /**
     * Retrieves all the indexable instances of a certain object type.
     *
     * @param string $object_type The object type.
     *
     * @return Indexable[] The array with all the indexable instances of a certain object type.
     */
    public function find_all_with_type($object_type)
    {
    }
    /**
     * Retrieves all the indexable instances of a certain object subtype.
     *
     * @param string $object_type     The object type.
     * @param string $object_sub_type The object subtype.
     *
     * @return Indexable[] The array with all the indexable instances of a certain object subtype.
     */
    public function find_all_with_type_and_sub_type($object_type, $object_sub_type)
    {
    }
    /**
     * Retrieves the homepage indexable.
     *
     * @param bool $auto_create Optional. Create the indexable if it does not exist.
     *
     * @return bool|Indexable Instance of indexable.
     */
    public function find_for_home_page($auto_create = true)
    {
    }
    /**
     * Retrieves the date archive indexable.
     *
     * @param bool $auto_create Optional. Create the indexable if it does not exist.
     *
     * @return bool|Indexable Instance of indexable.
     */
    public function find_for_date_archive($auto_create = true)
    {
    }
    /**
     * Retrieves an indexable for a post type archive.
     *
     * @param string $post_type   The post type.
     * @param bool   $auto_create Optional. Create the indexable if it does not exist.
     *
     * @return bool|Indexable The indexable, false if none could be found.
     */
    public function find_for_post_type_archive($post_type, $auto_create = true)
    {
    }
    /**
     * Retrieves the indexable for a system page.
     *
     * @param string $object_sub_type The type of system page.
     * @param bool   $auto_create     Optional. Create the indexable if it does not exist.
     *
     * @return bool|Indexable Instance of indexable.
     */
    public function find_for_system_page($object_sub_type, $auto_create = true)
    {
    }
    /**
     * Retrieves an indexable by its ID and type.
     *
     * @param int    $object_id   The indexable object ID.
     * @param string $object_type The indexable object type.
     * @param bool   $auto_create Optional. Create the indexable if it does not exist.
     *
     * @return bool|Indexable Instance of indexable.
     */
    public function find_by_id_and_type($object_id, $object_type, $auto_create = true)
    {
    }
    /**
     * Retrieves multiple indexables at once by their id's and type.
     *
     * @param int[]  $object_ids  The array of indexable object id's.
     * @param string $object_type The indexable object type.
     * @param bool   $auto_create Optional. Create the indexable if it does not exist.
     *
     * @return Indexable[] An array of indexables.
     */
    public function find_by_multiple_ids_and_type($object_ids, $object_type, $auto_create = true)
    {
    }
    /**
     * Finds the indexables by id's.
     *
     * @param array $indexable_ids The indexable id's.
     *
     * @return Indexable[] The found indexables.
     */
    public function find_by_ids(array $indexable_ids)
    {
    }
    /**
     * Returns all ancestors of a given indexable.
     *
     * @param Indexable $indexable The indexable to find the ancestors of.
     *
     * @return Indexable[] All ancestors of the given indexable.
     */
    public function get_ancestors(\Yoast\WP\SEO\Models\Indexable $indexable)
    {
    }
    /**
     * Returns all subpages with a given post_parent.
     *
     * @param int   $post_parent The post parent.
     * @param array $exclude_ids The id's to exclude.
     *
     * @return Indexable[] array of indexables.
     */
    public function get_subpages_by_post_parent($post_parent, $exclude_ids = [])
    {
    }
    /**
     * Updates the incoming link count for an indexable without first fetching it.
     *
     * @param int $indexable_id The indexable id.
     * @param int $count        The incoming link count.
     *
     * @return bool Whether or not the update was succeful.
     */
    public function update_incoming_link_count($indexable_id, $count)
    {
    }
    /**
     * Ensures that the given indexable has a permalink.
     *
     * Will be deprecated in 17.3 - Use upgrade_indexable instead.
     *
     * @codeCoverageIgnore
     *
     * @param Indexable $indexable The indexable.
     *
     * @return bool|Indexable The indexable.
     */
    public function ensure_permalink($indexable)
    {
    }
    /**
     * Checks if an Indexable is outdated, and rebuilds it when necessary.
     *
     * @param Indexable $indexable The indexable.
     *
     * @return Indexable The indexable.
     */
    public function upgrade_indexable($indexable)
    {
    }
    /**
     * Resets the permalinks of the passed object type and subtype.
     *
     * @param string|null $type    The type of the indexable. Can be null.
     * @param string|null $subtype The subtype. Can be null.
     *
     * @return int|bool The number of permalinks changed if the query was succesful. False otherwise.
     */
    public function reset_permalink($type = null, $subtype = null)
    {
    }
    /**
     * Gets the total number of stored indexables.
     *
     * @return int The total number of stored indexables.
     */
    public function get_total_number_of_indexables()
    {
    }
  }
  /**
   * Class Primary_Term_Repository.
   */
  class Primary_Term_Repository
  {
    /**
     * Starts a query for this repository.
     *
     * @return ORM
     */
    public function query()
    {
    }
    /**
     * Retrieves a primary term by a post ID and taxonomy.
     *
     * @param int    $post_id     The post the indexable is based upon.
     * @param string $taxonomy    The taxonomy the indexable belongs to.
     * @param bool   $auto_create Optional. Creates an indexable if it does not exist yet.
     *
     * @return Primary_Term|null Instance of a primary term.
     */
    public function find_by_post_id_and_taxonomy($post_id, $taxonomy, $auto_create = true)
    {
    }
  }
  /**
   * Class SEO_Links_Repository.
   */
  class SEO_Links_Repository
  {
    /**
     * Starts a query for this repository.
     *
     * @return ORM
     */
    public function query()
    {
    }
    /**
     * Finds all SEO Links by post ID.
     *
     * @param int $post_id The post ID.
     *
     * @return SEO_Links[] The SEO Links.
     */
    public function find_all_by_post_id($post_id)
    {
    }
    /**
     * Finds all SEO Links by indexable ID.
     *
     * @param int $indexable_id The indexable ID.
     *
     * @return SEO_Links[] The SEO Links.
     */
    public function find_all_by_indexable_id($indexable_id)
    {
    }
    /**
     * Retrieves an SEO Link by url.
     *
     * @param string $url The SEO Link's url.
     *
     * @return SEO_Links|false The SEO Link, or false if none found.
     */
    public function find_one_by_url($url)
    {
    }
    /**
     * Retrieves all SEO Links by target post ID.
     *
     * @param string $target_post_id The SEO Link's target post ID.
     *
     * @return SEO_Links[] The SEO Links.
     */
    public function find_all_by_target_post_id($target_post_id)
    {
    }
    /**
     * Updates the ID of the target indexable of a link.
     *
     * @param int $link_id             The ID of the link to be updated.
     * @param int $target_indexable_id The ID of the target indexable.
     *
     * @return bool Whether or not the update was succeful.
     */
    public function update_target_indexable_id($link_id, $target_indexable_id)
    {
    }
    /**
     * Clears all SEO Links by post ID.
     *
     * @param int $post_id The post ID.
     *
     * @return bool Whether or not the delete was succesfull.
     */
    public function delete_all_by_post_id($post_id)
    {
    }
    /**
     * Clears all SEO Links by post ID where the indexable id is null.
     *
     * @param int $post_id The post ID.
     *
     * @return bool Whether or not the delete was succesfull.
     */
    public function delete_all_by_post_id_where_indexable_id_null($post_id)
    {
    }
    /**
     * Clears all SEO Links by indexable ID.
     *
     * @param int $indexable_id The indexable ID.
     *
     * @return bool Whether or not the delete was succesfull.
     */
    public function delete_all_by_indexable_id($indexable_id)
    {
    }
    /**
     * Returns incoming link counts for a number of posts.
     *
     * @param array $post_ids The post IDs.
     *
     * @return array An array of associative arrays, each containing a post id and incoming property.
     */
    public function get_incoming_link_counts_for_post_ids($post_ids)
    {
    }
    /**
     * Returns incoming link counts for a number of indexables.
     *
     * @param array $indexable_ids The indexable IDs.
     *
     * @return array An array of associative arrays, each containing a indexable id and incoming property.
     */
    public function get_incoming_link_counts_for_indexable_ids($indexable_ids)
    {
    }
    /**
     * Deletes all seo links for the given ids.
     *
     * @param int[] $ids The seo link ids.
     *
     * @return bool Whether or not the delete was succesfull.
     */
    public function delete_many_by_id($ids)
    {
    }
    /**
     * Insert multiple seo links.
     *
     * @param SEO_Links[] $links The seo links to be inserted.
     *
     * @return bool Whether or not the insert was succesfull.
     */
    public function insert_many($links)
    {
    }
  }
}

namespace Yoast\WP\SEO\Routes {
  /**
   * Route interface.
   */
  interface Route_Interface extends \Yoast\WP\SEO\Loadable_Interface
  {
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes();
  }
  /**
   * Abstract_Action_Route class.
   *
   * Abstract class for action routes.
   */
  abstract class Abstract_Action_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    /**
     * Responds to an indexing request.
     *
     * @param array  $objects  The objects that have been indexed.
     * @param string $next_url The url that should be called to continue reindexing. False if done.
     *
     * @return WP_REST_Response The response.
     */
    protected function respond_with($objects, $next_url)
    {
    }
  }
  /**
   * Abstract_Indexation_Route class.
   *
   * Reindexing route for indexables.
   */
  abstract class Abstract_Indexation_Route extends \Yoast\WP\SEO\Routes\Abstract_Action_Route
  {
    /**
     * Runs an indexing action and returns the response.
     *
     * @param Indexation_Action_Interface $indexation_action The indexing action.
     * @param string                      $url               The url of the indexing route.
     *
     * @return WP_REST_Response The response.
     */
    protected function run_indexation_action(\Yoast\WP\SEO\Actions\Indexing\Indexation_Action_Interface $indexation_action, $url)
    {
    }
  }
  /**
   * Class Alert_Dismissal_Route.
   */
  class Alert_Dismissal_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Represents the alerts route prefix.
     *
     * @var string
     */
    const ROUTE_PREFIX = 'alerts';
    /**
     * Represents the dismiss route.
     *
     * @var string
     */
    const DISMISS_ROUTE = self::ROUTE_PREFIX . '/dismiss';
    /**
     * Represents the full dismiss route.
     *
     * @var string
     */
    const FULL_DISMISS_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::DISMISS_ROUTE;
    /**
     * Represents the alert dismissal action.
     *
     * @var Alert_Dismissal_Action
     */
    protected $alert_dismissal_action;
    /**
     * Constructs Alert_Dismissal_Route.
     *
     * @param Alert_Dismissal_Action $alert_dismissal_action The alert dismissal action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Alert_Dismissal_Action $alert_dismissal_action)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Dismisses an alert.
     *
     * @param WP_REST_Request $request The request. This request should have a key param set.
     *
     * @return WP_REST_Response The response.
     */
    public function dismiss(\WP_REST_Request $request)
    {
    }
    /**
     * Whether or not the current user is allowed to dismiss alerts.
     *
     * @return bool Whether or not the current user is allowed to dismiss alerts.
     */
    public function can_dismiss()
    {
    }
  }
  /**
   * First_Time_Configuration_Route class.
   */
  class First_Time_Configuration_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Represents the first time configuration route.
     *
     * @var string
     */
    const CONFIGURATION_ROUTE = '/configuration';
    /**
     * Represents a site representation route.
     *
     * @var string
     */
    const SITE_REPRESENTATION_ROUTE = '/site_representation';
    /**
     * Represents a social profiles route.
     *
     * @var string
     */
    const SOCIAL_PROFILES_ROUTE = '/social_profiles';
    /**
     * Represents a person's social profiles route.
     *
     * @deprecated 20.2
     * @var string
     */
    const PERSON_SOCIAL_PROFILES_ROUTE = '/person_social_profiles';
    /**
     * Represents a route to enable/disable tracking.
     *
     * @var string
     */
    const ENABLE_TRACKING_ROUTE = '/enable_tracking';
    /**
     * Represents a route to check if current user has the correct capabilities to edit another user's profile.
     *
     * @var string
     */
    const CHECK_CAPABILITY_ROUTE = '/check_capability';
    /**
     * Represents a route to save the first time configuration state.
     *
     * @var string
     */
    const SAVE_CONFIGURATION_STATE_ROUTE = '/save_configuration_state';
    /**
     * Represents a route to save the first time configuration state.
     *
     * @var string
     */
    const GET_CONFIGURATION_STATE_ROUTE = '/get_configuration_state';
    /**
     *  The first tinme configuration action.
     *
     * @var First_Time_Configuration_Action
     */
    private $first_time_configuration_action;
    /**
     * First_Time_Configuration_Route constructor.
     *
     * @param First_Time_Configuration_Action $first_time_configuration_action The first-time configuration action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Configuration\First_Time_Configuration_Action $first_time_configuration_action)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Sets the site representation values.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function set_site_representation(\WP_REST_Request $request)
    {
    }
    /**
     * Sets the social profiles values.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function set_social_profiles(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if the current user has the correct capability to edit a specific user.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function check_capability(\WP_REST_Request $request)
    {
    }
    /**
     * Enables or disables tracking.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function set_enable_tracking(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if the current user has the right capability.
     *
     * @return bool
     */
    public function can_manage_options()
    {
    }
    /**
     * Checks if the current user has the capability to edit a specific user.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return bool
     */
    public function can_edit_user(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if the current user has the capability to edit posts of other users.
     *
     * @return bool
     */
    public function can_edit_other_posts()
    {
    }
    /**
     * Saves the first time configuration state.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function save_configuration_state(\WP_REST_Request $request)
    {
    }
    /**
     * Returns the first time configuration state.
     *
     * @return WP_REST_Response the state of the configuration.
     */
    public function get_configuration_state()
    {
    }
    /*** DEPRECATED METHODS ***/
    /**
     * Gets a person's social profiles values.
     *
     * @deprecated 20.2
     * @codeCoverageIgnore
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function get_person_social_profiles(\WP_REST_Request $request)
    {
    }
    /**
     * Sets a person's social profiles values.
     *
     * @deprecated 20.2
     * @codeCoverageIgnore
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function set_person_social_profiles(\WP_REST_Request $request)
    {
    }
  }
  /**
   * Importing_Route class.
   *
   * Importing route for importing from other SEO plugins.
   */
  class Importing_Route extends \Yoast\WP\SEO\Routes\Abstract_Action_Route
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The import route constant.
     *
     * @var string
     */
    const ROUTE = '/import/(?P<plugin>[\\w-]+)/(?P<type>[\\w-]+)';
    /**
     * List of available importers.
     *
     * @var Importing_Action_Interface[]
     */
    protected $importers = [];
    /**
     * The importable detector service.
     *
     * @var Importable_Detector_Service
     */
    protected $importable_detector;
    /**
     * Importing_Route constructor.
     *
     * @param Importable_Detector_Service $importable_detector The importable detector service.
     * @param Importing_Action_Interface  ...$importers        All available importers.
     */
    public function __construct(\Yoast\WP\SEO\Services\Importing\Importable_Detector_Service $importable_detector, \Yoast\WP\SEO\Actions\Importing\Importing_Action_Interface ...$importers)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Executes the rest request, but only if the respective action is enabled.
     *
     * @param mixed $data The request parameters.
     *
     * @return WP_REST_Response|false Response or false on non-existent route.
     */
    public function execute($data)
    {
    }
    /**
     * Gets the right importer for the given arguments.
     *
     * @param string $plugin The plugin to import from.
     * @param string $type   The type of entity to import.
     *
     * @return Importing_Action_Interface|false The importer, or false if no importer was found.
     */
    protected function get_importer($plugin, $type)
    {
    }
    /**
     * Gets the right endpoint for the given arguments.
     *
     * @param string $plugin The plugin to import from.
     * @param string $type   The type of entity to import.
     *
     * @return string|false The endpoint for the given action or false on failure of finding the one.
     */
    public function get_endpoint($plugin, $type)
    {
    }
    /**
     * Whether or not the current user is allowed to import.
     *
     * @return bool Whether or not the current user is allowed to import.
     */
    public function is_user_permitted_to_import()
    {
    }
  }
  /**
   * Head route for indexables.
   */
  class Indexables_Head_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    /**
     * The posts route constant.
     *
     * @var string
     */
    const HEAD_FOR_URL_ROUTE = 'get_head';
    /**
     * The full posts route constant.
     *
     * @var string
     */
    const FULL_HEAD_FOR_URL_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::HEAD_FOR_URL_ROUTE;
    /**
     * The head action.
     *
     * @var Indexable_Head_Action
     */
    private $head_action;
    /**
     * Indexable_Indexation_Route constructor.
     *
     * @param Indexable_Head_Action $head_action The head action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Indexables\Indexable_Head_Action $head_action)
    {
    }
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Gets the head of a page for a given URL.
     *
     * @param WP_REST_Request $request The request. This request should have a url param set.
     *
     * @return WP_REST_Response The response.
     */
    public function get_head(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if a url is a valid url.
     *
     * @param string $url The url to check.
     *
     * @return bool Whether or not the url is valid.
     */
    public function is_valid_url($url)
    {
    }
  }
  /**
   * Indexing_Route class.
   *
   * Indexing route for indexables.
   */
  class Indexing_Route extends \Yoast\WP\SEO\Routes\Abstract_Indexation_Route
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * The indexing complete route constant.
     *
     * @var string
     */
    const COMPLETE_ROUTE = 'indexing/complete';
    /**
     * The full indexing complete route constant.
     *
     * @var string
     */
    const FULL_COMPLETE_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::COMPLETE_ROUTE;
    /**
     * The indexables complete route constant.
     *
     * @var string
     */
    const INDEXABLES_COMPLETE_ROUTE = 'indexing/indexables-complete';
    /**
     * The full indexing complete route constant.
     *
     * @var string
     */
    const FULL_INDEXABLES_COMPLETE_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::INDEXABLES_COMPLETE_ROUTE;
    /**
     * The indexing prepare route constant.
     *
     * @var string
     */
    const PREPARE_ROUTE = 'indexing/prepare';
    /**
     * The full indexing prepare route constant.
     *
     * @var string
     */
    const FULL_PREPARE_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::PREPARE_ROUTE;
    /**
     * The posts route constant.
     *
     * @var string
     */
    const POSTS_ROUTE = 'indexing/posts';
    /**
     * The full posts route constant.
     *
     * @var string
     */
    const FULL_POSTS_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::POSTS_ROUTE;
    /**
     * The terms route constant.
     *
     * @var string
     */
    const TERMS_ROUTE = 'indexing/terms';
    /**
     * The full terms route constant.
     *
     * @var string
     */
    const FULL_TERMS_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::TERMS_ROUTE;
    /**
     * The terms route constant.
     *
     * @var string
     */
    const POST_TYPE_ARCHIVES_ROUTE = 'indexing/post-type-archives';
    /**
     * The full terms route constant.
     *
     * @var string
     */
    const FULL_POST_TYPE_ARCHIVES_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::POST_TYPE_ARCHIVES_ROUTE;
    /**
     * The general route constant.
     *
     * @var string
     */
    const GENERAL_ROUTE = 'indexing/general';
    /**
     * The full general route constant.
     *
     * @var string
     */
    const FULL_GENERAL_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::GENERAL_ROUTE;
    /**
     * The posts route constant.
     *
     * @var string
     */
    const POST_LINKS_INDEXING_ROUTE = 'link-indexing/posts';
    /**
     * The full posts route constant.
     *
     * @var string
     */
    const FULL_POST_LINKS_INDEXING_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::POST_LINKS_INDEXING_ROUTE;
    /**
     * The terms route constant.
     *
     * @var string
     */
    const TERM_LINKS_INDEXING_ROUTE = 'link-indexing/terms';
    /**
     * The full terms route constant.
     *
     * @var string
     */
    const FULL_TERM_LINKS_INDEXING_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::TERM_LINKS_INDEXING_ROUTE;
    /**
     * The post indexing action.
     *
     * @var Indexable_Post_Indexation_Action
     */
    protected $post_indexation_action;
    /**
     * The term indexing action.
     *
     * @var Indexable_Term_Indexation_Action
     */
    protected $term_indexation_action;
    /**
     * The post type archive indexing action.
     *
     * @var Indexable_Post_Type_Archive_Indexation_Action
     */
    protected $post_type_archive_indexation_action;
    /**
     * Represents the general indexing action.
     *
     * @var Indexable_General_Indexation_Action
     */
    protected $general_indexation_action;
    /**
     * The prepare indexing action.
     *
     * @var Indexing_Prepare_Action
     */
    protected $prepare_indexing_action;
    /**
     * The indexable indexing complete action.
     *
     * @var Indexable_Indexing_Complete_Action
     */
    protected $indexable_indexing_complete_action;
    /**
     * The indexing complete action.
     *
     * @var Indexing_Complete_Action
     */
    protected $indexing_complete_action;
    /**
     * The post link indexing action.
     *
     * @var Post_Link_Indexing_Action
     */
    protected $post_link_indexing_action;
    /**
     * The term link indexing action.
     *
     * @var Term_Link_Indexing_Action
     */
    protected $term_link_indexing_action;
    /**
     * The options helper.
     *
     * @var Options_Helper
     */
    protected $options_helper;
    /**
     * The indexing helper.
     *
     * @var Indexing_Helper
     */
    protected $indexing_helper;
    /**
     * Indexing_Route constructor.
     *
     * @param Indexable_Post_Indexation_Action              $post_indexation_action              The post indexing action.
     * @param Indexable_Term_Indexation_Action              $term_indexation_action              The term indexing action.
     * @param Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation_action The post type archive indexing action.
     * @param Indexable_General_Indexation_Action           $general_indexation_action           The general indexing action.
     * @param Indexable_Indexing_Complete_Action            $indexable_indexing_complete_action  The complete indexing action.
     * @param Indexing_Complete_Action                      $indexing_complete_action            The complete indexing action.
     * @param Indexing_Prepare_Action                       $prepare_indexing_action             The prepare indexing action.
     * @param Post_Link_Indexing_Action                     $post_link_indexing_action           The post link indexing action.
     * @param Term_Link_Indexing_Action                     $term_link_indexing_action           The term link indexing action.
     * @param Options_Helper                                $options_helper                      The options helper.
     * @param Indexing_Helper                               $indexing_helper                     The indexing helper.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Indexation_Action $post_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_Term_Indexation_Action $term_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_Post_Type_Archive_Indexation_Action $post_type_archive_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_General_Indexation_Action $general_indexation_action, \Yoast\WP\SEO\Actions\Indexing\Indexable_Indexing_Complete_Action $indexable_indexing_complete_action, \Yoast\WP\SEO\Actions\Indexing\Indexing_Complete_Action $indexing_complete_action, \Yoast\WP\SEO\Actions\Indexing\Indexing_Prepare_Action $prepare_indexing_action, \Yoast\WP\SEO\Actions\Indexing\Post_Link_Indexing_Action $post_link_indexing_action, \Yoast\WP\SEO\Actions\Indexing\Term_Link_Indexing_Action $term_link_indexing_action, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper, \Yoast\WP\SEO\Helpers\Indexing_Helper $indexing_helper)
    {
    }
    /**
     * Registers the routes used to index indexables.
     */
    public function register_routes()
    {
    }
    /**
     * Indexes a number of unindexed posts.
     *
     * @return WP_REST_Response The response.
     */
    public function index_posts()
    {
    }
    /**
     * Indexes a number of unindexed terms.
     *
     * @return WP_REST_Response The response.
     */
    public function index_terms()
    {
    }
    /**
     * Indexes a number of unindexed post type archive pages.
     *
     * @return WP_REST_Response The response.
     */
    public function index_post_type_archives()
    {
    }
    /**
     * Indexes a number of unindexed general items.
     *
     * @return WP_REST_Response The response.
     */
    public function index_general()
    {
    }
    /**
     * Indexes a number of posts for post links.
     *
     * @return WP_REST_Response The response.
     */
    public function index_post_links()
    {
    }
    /**
     * Indexes a number of terms for term links.
     *
     * @return WP_REST_Response The response.
     */
    public function index_term_links()
    {
    }
    /**
     * Prepares the indexation.
     *
     * @return WP_REST_Response The response.
     */
    public function prepare()
    {
    }
    /**
     * Completes the indexable indexation.
     *
     * @return WP_REST_Response The response.
     */
    public function indexables_complete()
    {
    }
    /**
     * Completes the indexation.
     *
     * @return WP_REST_Response The response.
     */
    public function complete()
    {
    }
    /**
     * Whether or not the current user is allowed to index.
     *
     * @return bool Whether or not the current user is allowed to index.
     */
    public function can_index()
    {
    }
    /**
     * Runs an indexing action and returns the response.
     *
     * @param Indexation_Action_Interface $indexation_action The indexing action.
     * @param string                      $url               The url of the indexing route.
     *
     * @return WP_REST_Response|WP_Error The response, or an error when running the indexing action failed.
     */
    protected function run_indexation_action(\Yoast\WP\SEO\Actions\Indexing\Indexation_Action_Interface $indexation_action, $url)
    {
    }
  }
  /**
   * Integrations_Route class.
   */
  class Integrations_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Represents the integrations route.
     *
     * @var string
     */
    const INTEGRATIONS_ROUTE = '/integrations';
    /**
     * Represents a route to set the state of an integration.
     *
     * @var string
     */
    const SET_ACTIVE_ROUTE = '/set_active';
    /**
     *  The integrations action.
     *
     * @var Integrations_Action
     */
    private $integrations_action;
    /**
     * Integrations_Route constructor.
     *
     * @param Integrations_Action $integrations_action The integrations action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Integrations_Action $integrations_action)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Checks if the current user has the right capability.
     *
     * @return bool
     */
    public function can_manage_options()
    {
    }
    /**
     * Sets integration state.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return WP_REST_Response
     */
    public function set_integration_active(\WP_REST_Request $request)
    {
    }
  }
  /**
   * Meta_Search_Route class
   */
  class Meta_Search_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Represents meta search route.
     *
     * @var string
     */
    const META_SEARCH_ROUTE = '/meta/search';
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Performs the permission check.
     *
     * @param WP_REST_Request $request The request.
     *
     * @return bool
     */
    public function permission_check($request)
    {
    }
    /**
     * Searches meta fields of a given post.
     *
     * @param WP_REST_Request $request The REST request.
     *
     * @return WP_REST_Response
     */
    public function search_meta($request)
    {
    }
  }
  /**
   * SEMrush_Route class.
   */
  class SEMrush_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    /**
     * The SEMrush route prefix.
     *
     * @var string
     */
    const ROUTE_PREFIX = 'semrush';
    /**
     * The authenticate route constant.
     *
     * @var string
     */
    const AUTHENTICATION_ROUTE = self::ROUTE_PREFIX . '/authenticate';
    /**
     * The country code option route constant.
     *
     * @var string
     */
    const COUNTRY_CODE_OPTION_ROUTE = self::ROUTE_PREFIX . '/country_code';
    /**
     * The request related keyphrases route constant.
     *
     * @var string
     */
    const RELATED_KEYPHRASES_ROUTE = self::ROUTE_PREFIX . '/related_keyphrases';
    /**
     * The full login route constant.
     *
     * @var string
     */
    const FULL_AUTHENTICATION_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::AUTHENTICATION_ROUTE;
    /**
     * The full country code option route constant.
     *
     * @var string
     */
    const FULL_COUNTRY_CODE_OPTION_ROUTE = \Yoast\WP\SEO\Main::API_V1_NAMESPACE . '/' . self::COUNTRY_CODE_OPTION_ROUTE;
    /**
     * The login action.
     *
     * @var SEMrush_Login_Action
     */
    private $login_action;
    /**
     * The options action.
     *
     * @var SEMrush_Options_Action
     */
    private $options_action;
    /**
     * The phrases action.
     *
     * @var SEMrush_Phrases_Action
     */
    private $phrases_action;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * SEMrush_Route constructor.
     *
     * @param SEMrush_Login_Action   $login_action   The login action.
     * @param SEMrush_Options_Action $options_action The options action.
     * @param SEMrush_Phrases_Action $phrases_action The phrases action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\SEMrush\SEMrush_Login_Action $login_action, \Yoast\WP\SEO\Actions\SEMrush\SEMrush_Options_Action $options_action, \Yoast\WP\SEO\Actions\SEMrush\SEMrush_Phrases_Action $phrases_action)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Authenticates with SEMrush.
     *
     * @param WP_REST_Request $request The request. This request should have a code param set.
     *
     * @return WP_REST_Response The response.
     */
    public function authenticate(\WP_REST_Request $request)
    {
    }
    /**
     * Sets the SEMrush country code option.
     *
     * @param WP_REST_Request $request The request. This request should have a country code param set.
     *
     * @return WP_REST_Response The response.
     */
    public function set_country_code_option(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if a valid code was returned.
     *
     * @param string $code The code to check.
     *
     * @return bool Whether or not the code is valid.
     */
    public function has_valid_code($code)
    {
    }
    /**
     * Checks if a valid keyphrase is provided.
     *
     * @param string $keyphrase The keyphrase to check.
     *
     * @return bool Whether or not the keyphrase is valid.
     */
    public function has_valid_keyphrase($keyphrase)
    {
    }
    /**
     * Gets the related keyphrases based on the passed keyphrase and database code.
     *
     * @param WP_REST_Request $request The request. This request should have a keyphrase and country_code param set.
     *
     * @return WP_REST_Response The response.
     */
    public function get_related_keyphrases(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if a valid country code was submitted.
     *
     * @param string $country_code The country code to check.
     *
     * @return bool Whether or not the country code is valid.
     */
    public function has_valid_country_code($country_code)
    {
    }
    /**
     * Whether or not the current user is allowed to edit post/pages and thus use the SEMrush integration.
     *
     * @return bool Whether or not the current user is allowed to use SEMrush.
     */
    public function can_use_semrush()
    {
    }
  }
  /**
   * Settings_Introduction_Route class.
   */
  class Settings_Introduction_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    /**
     * Represents the Settings_Introduction_Route prefix.
     *
     * @var string
     */
    const ROUTE_PREFIX = '/settings_introduction';
    /**
     * Represents the Wistia embed permission.
     *
     * @var string
     */
    const WISTIA_EMBED_PERMISSION = self::ROUTE_PREFIX . '/wistia_embed_permission';
    /**
     * Represents showing the introduction.
     *
     * @var string
     */
    const SHOW = self::ROUTE_PREFIX . '/show';
    /**
     * Holds the Settings_Introduction_Action.
     *
     * @var Settings_Introduction_Action
     */
    private $settings_introduction_action;
    /**
     * Constructs Settings_Introduction_Route.
     *
     * @param Settings_Introduction_Action $settings_introduction_action The $settings_introduction_action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Settings_Introduction_Action $settings_introduction_action)
    {
    }
    /**
     * {@inheritDoc}
     */
    public static function get_conditionals()
    {
    }
    /**
     * Permission callback.
     *
     * @return bool True when user has 'wpseo_manage_options' permission.
     */
    public static function permission_manage_options()
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Gets the value of the wistia embed permission.
     *
     * @return WP_REST_Response|WP_Error The response, or an error.
     */
    public function get_wistia_embed_permission()
    {
    }
    /**
     * Sets the value of the wistia embed permission.
     *
     * @param WP_REST_Request $request The request object.
     *
     * @return WP_REST_Response|WP_Error The success or failure response.
     */
    public function set_wistia_embed_permission(\WP_REST_Request $request)
    {
    }
    /**
     * Gets the value of show.
     *
     * @return WP_REST_Response|WP_Error The response, or an error.
     */
    public function get_show()
    {
    }
    /**
     * Sets the value of show.
     *
     * @param WP_REST_Request $request The request object.
     *
     * @return WP_REST_Response|WP_Error The success or failure response.
     */
    public function set_show(\WP_REST_Request $request)
    {
    }
  }
  /**
   * Supported_Features_Route class.
   */
  class Supported_Features_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    /**
     * Represents the supported features route.
     *
     * @var string
     */
    const SUPPORTED_FEATURES_ROUTE = '/supported-features';
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Returns a list of features supported by this yoast seo installation.
     *
     * @return WP_REST_Response a list of features supported by this yoast seo installation.
     */
    public function get_supported_features()
    {
    }
  }
  /**
   * Wincher_Route class.
   */
  class Wincher_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    /**
     * The Wincher route prefix.
     *
     * @var string
     */
    const ROUTE_PREFIX = 'wincher';
    /**
     * The authorize route constant.
     *
     * @var string
     */
    const AUTHORIZATION_URL_ROUTE = self::ROUTE_PREFIX . '/authorization-url';
    /**
     * The authenticate route constant.
     *
     * @var string
     */
    const AUTHENTICATION_ROUTE = self::ROUTE_PREFIX . '/authenticate';
    /**
     * The track bulk keyphrases route constant.
     *
     * @var string
     */
    const KEYPHRASES_TRACK_ROUTE = self::ROUTE_PREFIX . '/keyphrases/track';
    /**
     * The keyphrases route constant.
     *
     * @var string
     */
    const TRACKED_KEYPHRASES_ROUTE = self::ROUTE_PREFIX . '/keyphrases';
    /**
     * The untrack keyphrase route constant.
     *
     * @var string
     */
    const UNTRACK_KEYPHRASE_ROUTE = self::ROUTE_PREFIX . '/keyphrases/untrack';
    /**
     * The login action.
     *
     * @var Wincher_Login_Action
     */
    private $login_action;
    /**
     * The account action.
     *
     * @var Wincher_Account_Action
     */
    private $account_action;
    /**
     * The keyphrases action.
     *
     * @var Wincher_Keyphrases_Action
     */
    private $keyphrases_action;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Wincher_Route constructor.
     *
     * @param Wincher_Login_Action      $login_action      The login action.
     * @param Wincher_Account_Action    $account_action    The account action.
     * @param Wincher_Keyphrases_Action $keyphrases_action The keyphrases action.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Wincher\Wincher_Login_Action $login_action, \Yoast\WP\SEO\Actions\Wincher\Wincher_Account_Action $account_action, \Yoast\WP\SEO\Actions\Wincher\Wincher_Keyphrases_Action $keyphrases_action)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Returns the authorization URL.
     *
     * @return WP_REST_Response The response.
     */
    public function get_authorization_url()
    {
    }
    /**
     * Authenticates with Wincher.
     *
     * @param WP_REST_Request $request The request. This request should have a code param set.
     *
     * @return WP_REST_Response The response.
     */
    public function authenticate(\WP_REST_Request $request)
    {
    }
    /**
     * Posts keyphrases to track.
     *
     * @param WP_REST_Request $request The request. This request should have a code param set.
     *
     * @return WP_REST_Response The response.
     */
    public function track_keyphrases(\WP_REST_Request $request)
    {
    }
    /**
     * Gets the tracked keyphrases via POST.
     * This is done via POST, so we don't potentially run into URL limit issues when a lot of long keyphrases are tracked.
     *
     * @param WP_REST_Request $request The request. This request should have a code param set.
     *
     * @return WP_REST_Response The response.
     */
    public function get_tracked_keyphrases(\WP_REST_Request $request)
    {
    }
    /**
     * Untracks the tracked keyphrase.
     *
     * @param WP_REST_Request $request The request. This request should have a code param set.
     *
     * @return WP_REST_Response The response.
     */
    public function untrack_keyphrase(\WP_REST_Request $request)
    {
    }
    /**
     * Checks if a valid code was returned.
     *
     * @param string $code The code to check.
     *
     * @return bool Whether the code is valid.
     */
    public function has_valid_code($code)
    {
    }
    /**
     * Checks if a valid website_id was returned.
     *
     * @param int $website_id The website_id to check.
     *
     * @return bool Whether the website_id is valid.
     */
    public function has_valid_website_id($website_id)
    {
    }
    /**
     * Whether the current user is allowed to publish post/pages and thus use the Wincher integration.
     *
     * @return bool Whether the current user is allowed to use Wincher.
     */
    public function can_use_wincher()
    {
    }
  }
  /**
   * Workouts_Route class.
   */
  class Workouts_Route implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    use \Yoast\WP\SEO\Conditionals\No_Conditionals;
    /**
     * Represents workouts route.
     *
     * @var string
     */
    const WORKOUTS_ROUTE = '/workouts';
    /**
     * The Options helper.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * Workouts_Route constructor.
     *
     * @param Options_Helper $options_helper The options helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Returns the workouts as configured for the site.
     *
     * @return WP_REST_Response the configuration of the workouts.
     */
    public function get_workouts()
    {
    }
    /**
     * Sets the workout configuration.
     *
     * @param WP_REST_Request $request The request object.
     *
     * @return WP_REST_Response the configuration of the workouts.
     */
    public function set_workouts($request)
    {
    }
    /**
     * Gets the args for all the registered workouts.
     *
     * @return array
     */
    private function get_workouts_routes_args()
    {
    }
  }
  /**
   * Yoast_Head_REST_Field class.
   *
   * Registers the yoast head REST field.
   * Not technically a route but behaves the same so is included here.
   */
  class Yoast_Head_REST_Field implements \Yoast\WP\SEO\Routes\Route_Interface
  {
    /**
     * The name of the Yoast head field.
     *
     * @var string
     */
    const YOAST_HEAD_ATTRIBUTE_NAME = 'yoast_head';
    /**
     * The name of the Yoast head JSON field.
     *
     * @var string
     */
    const YOAST_JSON_HEAD_ATTRIBUTE_NAME = 'yoast_head_json';
    /**
     * The post type helper.
     *
     * @var Post_Type_Helper
     */
    protected $post_type_helper;
    /**
     * The taxonomy helper.
     *
     * @var Taxonomy_Helper
     */
    protected $taxonomy_helper;
    /**
     * The post helper.
     *
     * @var Post_Helper
     */
    protected $post_helper;
    /**
     * The head action.
     *
     * @var Indexable_Head_Action
     */
    protected $head_action;
    /**
     * Returns the conditionals based in which this loadable should be active.
     *
     * @return array
     */
    public static function get_conditionals()
    {
    }
    /**
     * Yoast_Head_REST_Field constructor.
     *
     * @param Post_Type_Helper      $post_type_helper The post type helper.
     * @param Taxonomy_Helper       $taxonomy_helper  The taxonomy helper.
     * @param Post_Helper           $post_helper      The post helper.
     * @param Indexable_Head_Action $head_action      The head action.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Post_Type_Helper $post_type_helper, \Yoast\WP\SEO\Helpers\Taxonomy_Helper $taxonomy_helper, \Yoast\WP\SEO\Helpers\Post_Helper $post_helper, \Yoast\WP\SEO\Actions\Indexables\Indexable_Head_Action $head_action)
    {
    }
    /**
     * Registers routes with WordPress.
     *
     * @return void
     */
    public function register_routes()
    {
    }
    /**
     * Returns the head for a post.
     *
     * @param array  $params The rest request params.
     * @param string $format The desired output format.
     *
     * @return string|null The head.
     */
    public function for_post($params, $format = self::YOAST_HEAD_ATTRIBUTE_NAME)
    {
    }
    /**
     * Returns the head for a term.
     *
     * @param array  $params The rest request params.
     * @param string $format The desired output format.
     *
     * @return string|null The head.
     */
    public function for_term($params, $format = self::YOAST_HEAD_ATTRIBUTE_NAME)
    {
    }
    /**
     * Returns the head for an author.
     *
     * @param array  $params The rest request params.
     * @param string $format The desired output format.
     *
     * @return string|null The head.
     */
    public function for_author($params, $format = self::YOAST_HEAD_ATTRIBUTE_NAME)
    {
    }
    /**
     * Returns the head for a post type archive.
     *
     * @param array  $params The rest request params.
     * @param string $format The desired output format.
     *
     * @return string|null The head.
     */
    public function for_post_type_archive($params, $format = self::YOAST_HEAD_ATTRIBUTE_NAME)
    {
    }
    /**
     * Registers the Yoast rest fields.
     *
     * @param string $object_type The object type.
     * @param string $callback    The function name of the callback.
     *
     * @return void
     */
    protected function register_rest_fields($object_type, $callback)
    {
    }
    /**
     * Returns the correct property for the Yoast head.
     *
     * @param stdObject $head   The Yoast head.
     * @param string    $format The format to return.
     *
     * @return string|array|null The output value. String if HTML was requested, array otherwise.
     */
    protected function render_object($head, $format = self::YOAST_HEAD_ATTRIBUTE_NAME)
    {
    }
  }
}

namespace Yoast\WP\SEO\Services\Health_Check {
  /**
   * Abstract class for all health checks. Provides a uniform interface for the Health_Check_Integration.
   */
  abstract class Health_Check
  {
    /**
     * The prefix to add to the test identifier. Used to differentiate between Yoast's health checks, and other health checks.
     */
    const TEST_IDENTIFIER_PREFIX = 'yoast-';
    /**
     * The object that runs the actual health check.
     *
     * @var Runner_Interface
     */
    private $runner;
    /**
     * The health check implementation sets the runner so this class can start a health check.
     *
     * @param  Runner_Interface $runner The health check runner.
     * @return void
     */
    protected function set_runner($runner)
    {
    }
    /**
     * Returns the identifier of health check implementation. WordPress needs this to manage the health check (https://developer.wordpress.org/reference/hooks/site_status_tests/).
     *
     * @return string The identifier that WordPress requires.
     */
    public function get_test_identifier()
    {
    }
    /**
     * Returns the name of health check implementation that the user can see. WordPress needs this to manage the health check (https://developer.wordpress.org/reference/hooks/site_status_tests/).
     *
     * @return string A human-readable label for the health check.
     */
    public abstract function get_test_label();
    /**
     * Runs the health check, and returns its result in the format that WordPress requires to show the results to the user (https://developer.wordpress.org/reference/hooks/site_status_test_result/).
     *
     * @return string[] The array containing a WordPress site status report.
     */
    public function run_and_get_result()
    {
    }
    /**
     * Gets the result from the health check implementation.
     *
     * @return string[] The array containing a WordPress site status report.
     */
    protected abstract function get_result();
  }
  /**
   * Passes when the tagline is set to something other than the WordPress default tagline.
   */
  class Default_Tagline_Check extends \Yoast\WP\SEO\Services\Health_Check\Health_Check
  {
    /**
     * Runs the health check.
     *
     * @var Default_Tagline_Runner
     */
    private $runner;
    /**
     * Generates WordPress-friendly health check results.
     *
     * @var Default_Tagline_Reports
     */
    private $reports;
    /**
     * Constructor.
     *
     * @param  Default_Tagline_Runner  $runner  The object that implements the actual health check.
     * @param  Default_Tagline_Reports $reports The object that generates WordPress-friendly results.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Runner $runner, \Yoast\WP\SEO\Services\Health_Check\Default_Tagline_Reports $reports)
    {
    }
    /**
     * Returns a human-readable label for this health check.
     *
     * @return string The human-readable label.
     */
    public function get_test_label()
    {
    }
    /**
     * Returns the WordPress-friendly health check result.
     *
     * @return string[] The WordPress-friendly health check result.
     */
    protected function get_result()
    {
    }
  }
  /**
   * Used by classes that use a health check Report_Builder.
   */
  trait Reports_Trait
  {
    /**
     * The factory for the builder object that generates WordPress-friendly test results.
     *
     * @var Report_Builder_Factory
     */
    private $report_builder_factory;
    /**
     * The test identifier that's set on the Report_Builder.
     *
     * @var string
     */
    private $test_identifier = '';
    /**
     * Sets the name that WordPress uses to identify this health check.
     *
     * @param  string $test_identifier The identifier.
     * @return void
     */
    public function set_test_identifier($test_identifier)
    {
    }
    /**
     * Returns a new Report_Builder instance using the set test identifier.
     *
     * @return Report_Builder
     */
    private function get_report_builder()
    {
    }
  }
  /**
   * Presents a set of different messages for the Default_Tagline health check.
   */
  class Default_Tagline_Reports
  {
    use \Yoast\WP\SEO\Services\Health_Check\Reports_Trait;
    /**
     * Constructor
     *
     * @param  Report_Builder_Factory $report_builder_factory The factory for result builder objects.
     *                                                        This class uses the report builder to generate WordPress-friendly
     *                                                        health check results.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Report_Builder_Factory $report_builder_factory)
    {
    }
    /**
     * Returns the message for a successful health check.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_success_result()
    {
    }
    /**
     * Returns the message for a failed health check. In this case, when the user still has the default WordPress tagline set.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_has_default_tagline_result()
    {
    }
    /**
     * Returns the actions that the user should take when his tagline is still set to the WordPress default.
     *
     * @return string The actions as an HTML string.
     */
    private function get_actions()
    {
    }
  }
  /**
   * Interface for the health check runner. The abstract Health_Check uses this to run a health check.
   */
  interface Runner_Interface
  {
    /**
     * Runs the health check.
     *
     * @return void
     */
    public function run();
  }
  /**
   * Runs the Default_Tagline health check.
   */
  class Default_Tagline_Runner implements \Yoast\WP\SEO\Services\Health_Check\Runner_Interface
  {
    /**
     * The default WordPress tagline.
     */
    const DEFAULT_BLOG_DESCRIPTION = 'Just another WordPress site';
    /**
     * Is set to true when the default tagline is set.
     *
     * @var bool
     */
    private $has_default_tagline = true;
    /**
     * Runs the health check. Checks if the tagline is set to WordPress' default tagline, or to its set translation.
     *
     * @return void
     */
    public function run()
    {
    }
    /**
     * Returns true if the tagline is set to a non-default tagline.
     *
     * @return bool The boolean indicating if the health check was succesful.
     */
    public function is_successful()
    {
    }
  }
  /**
   * Passes when the links table is accessible.
   */
  class Links_Table_Check extends \Yoast\WP\SEO\Services\Health_Check\Health_Check
  {
    /**
     * Runs the health check.
     *
     * @var Links_Table_Runner
     */
    private $runner;
    /**
     * Generates WordPress-friendly health check results.
     *
     * @var Links_Table_Reports
     */
    private $reports;
    /**
     * Constructor.
     *
     * @param Links_Table_Runner  $runner  The object that implements the actual health check.
     * @param Links_Table_Reports $reports The object that generates WordPress-friendly results.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Links_Table_Runner $runner, \Yoast\WP\SEO\Services\Health_Check\Links_Table_Reports $reports)
    {
    }
    /**
     * Returns a human-readable label for this health check.
     *
     * @return string The human-readable label.
     */
    public function get_test_label()
    {
    }
    /**
     * Returns the WordPress-friendly health check result.
     *
     * @return string[] The WordPress-friendly health check result.
     */
    protected function get_result()
    {
    }
  }
  /**
   * Presents a set of different messages for the Links_Table health check.
   */
  class Links_Table_Reports
  {
    use \Yoast\WP\SEO\Services\Health_Check\Reports_Trait;
    /**
     * Shortlinker object used to create short links for reports.
     *
     * @var WPSEO_Shortlinker
     */
    private $shortlinker;
    /**
     * Constructor
     *
     * @param  Report_Builder_Factory $report_builder_factory The factory for result builder objects.
     *                                                        This class uses the report builder to generate WordPress-friendly
     *                                                        health check results.
     * @param  WPSEO_Shortlinker      $shortlinker            Object used to add short links to the report description.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Report_Builder_Factory $report_builder_factory, \WPSEO_Shortlinker $shortlinker)
    {
    }
    /**
     * Returns the message for a successful health check.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_success_result()
    {
    }
    /**
     * Returns the message for a failed health check.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_links_table_not_accessible_result()
    {
    }
    /**
     * Returns the description for when the health check was successful.
     *
     * @return string The description as a string.
     */
    private function get_success_description()
    {
    }
    /**
     * Returns the description for when the health couldn't access the links table.
     *
     * @return string The description as a string.
     */
    private function get_links_table_not_accessible_description()
    {
    }
    /**
     * Returns the actions that the user should take when the links table is not accessible.
     *
     * @return string The actions as a string.
     */
    private function get_actions()
    {
    }
  }
  /**
   * Runs the Links_Table health check.
   */
  class Links_Table_Runner implements \Yoast\WP\SEO\Services\Health_Check\Runner_Interface
  {
    /**
     * Is set to true when the links table is accessible.
     *
     * @var bool
     */
    private $links_table_accessible = false;
    /**
     * The Migration_Status object used to determine whether the links table is accessible.
     *
     * @var Migration_Status
     */
    private $migration_status;
    /**
     * The Options_Helper object used to determine whether the health check should run or not.
     *
     * @var Options_Helper
     */
    private $options_helper;
    /**
     * Constructor.
     *
     * @param Migration_Status $migration_status Object used to determine whether the links table is accessible.
     * @param Options_Helper   $options_helper   Object used to determine whether the health check should run.
     */
    public function __construct(\Yoast\WP\SEO\Config\Migration_Status $migration_status, \Yoast\WP\SEO\Helpers\Options_Helper $options_helper)
    {
    }
    /**
     * Runs the health check. Checks if the tagline is set to WordPress' default tagline, or to its set translation.
     *
     * @return void
     */
    public function run()
    {
    }
    /**
     * Determines whether the health check should run or not.
     *
     * @return bool True if the text link counter feature is enabled.
     */
    public function should_run()
    {
    }
    /**
     * Returns true if the links table is accessible
     *
     * @return bool The boolean indicating if the health check was succesful.
     */
    public function is_successful()
    {
    }
  }
  /**
   * Creates WPSEO_MyYoast_Api_Request objects.
   */
  class MyYoast_Api_Request_Factory
  {
    /**
     * Creates a new WPSEO_MyYoast_API_Request.
     *
     * @param string $url  The URL for the request.
     * @param array  $args Optional arguments for the request.
     * @return WPSEO_MyYoast_Api_Request
     */
    public function create($url, $args = [])
    {
    }
  }
  /**
   * Paasses when comments are set to be on a single page.
   */
  class Page_Comments_Check extends \Yoast\WP\SEO\Services\Health_Check\Health_Check
  {
    /**
     * Runs the health check.
     *
     * @var Page_Comments_Runner
     */
    private $runner;
    /**
     * Generates WordPress-friendly health check results.
     *
     * @var Page_Comments_Reports
     */
    private $reports;
    /**
     * Constructor.
     *
     * @param  Page_Comments_Runner  $runner  The object that implements the actual health check.
     * @param  Page_Comments_Reports $reports The object that generates WordPress-friendly results.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Page_Comments_Runner $runner, \Yoast\WP\SEO\Services\Health_Check\Page_Comments_Reports $reports)
    {
    }
    /**
     * Returns a human-readable label for this health check.
     *
     * @return string The human-readable label.
     */
    public function get_test_label()
    {
    }
    /**
     * Returns the WordPress-friendly health check result.
     *
     * @return string[] The WordPress-friendly health check result.
     */
    protected function get_result()
    {
    }
  }
  /**
   * Presents a set of different messages for the Page_Comments health check.
   */
  class Page_Comments_Reports
  {
    use \Yoast\WP\SEO\Services\Health_Check\Reports_Trait;
    /**
     * Constructor.
     *
     * @param  Report_Builder_Factory $report_builder_factory The factory for result builder objects.
     *                                                        This class uses the report builder to generate WordPress-friendly
     *                                                        health check results.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Report_Builder_Factory $report_builder_factory)
    {
    }
    /**
     * Returns the report for when comments are set to be all on one page.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_success_result()
    {
    }
    /**
     * Returns the report for when comments are set to be broken up across multiple pages.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_has_comments_on_multiple_pages_result()
    {
    }
    /**
     * Returns the actions for when the comments are set to be broken up across multiple pages.
     *
     * @return string The actions as a string.
     */
    private function get_has_comments_on_multiple_pages_actions()
    {
    }
  }
  /**
   * Runs the Page_Comments health check.
   */
  class Page_Comments_Runner implements \Yoast\WP\SEO\Services\Health_Check\Runner_Interface
  {
    /**
     * Is set to true when comments are set to display on a single page.
     *
     * @var bool
     */
    private $comments_on_single_page;
    /**
     * Constructor.
     */
    public function __construct()
    {
    }
    /**
     * Runs the health check. Checks if comments are displayed on a single page.
     *
     * @return void
     */
    public function run()
    {
    }
    /**
     * Returns true if comments are displayed on a single page.
     *
     * @return bool True if comments are displayed on a single page.
     */
    public function is_successful()
    {
    }
  }
  /**
   * Paasses when permalinks are set to contain the post name.
   */
  class Postname_Permalink_Check extends \Yoast\WP\SEO\Services\Health_Check\Health_Check
  {
    /**
     * Runs the health check.
     *
     * @var Postname_Permalink_Runner
     */
    private $runner;
    /**
     * Generates WordPress-friendly health check results.
     *
     * @var Postname_Permalink_Reports
     */
    private $reports;
    /**
     * Constructor.
     *
     * @param  Postname_Permalink_Runner  $runner  The object that implements the actual health check.
     * @param  Postname_Permalink_Reports $reports The object that generates WordPress-friendly results.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Runner $runner, \Yoast\WP\SEO\Services\Health_Check\Postname_Permalink_Reports $reports)
    {
    }
    /**
     * Returns a human-readable label for this health check.
     *
     * @return string The human-readable label.
     */
    public function get_test_label()
    {
    }
    /**
     * Returns the WordPress-friendly health check result.
     *
     * @return string[] The WordPress-friendly health check result.
     */
    protected function get_result()
    {
    }
  }
  /**
   * Presents a set of different messages for the Postname_Permalink health check.
   */
  class Postname_Permalink_Reports
  {
    use \Yoast\WP\SEO\Services\Health_Check\Reports_Trait;
    /**
     * Constructor.
     *
     * @param  Report_Builder_Factory $report_builder_factory The factory for result builder objects.
     *                                                        This class uses the report builder to generate WordPress-friendly
     *                                                        health check results.
     */
    public function __construct(\Yoast\WP\SEO\Services\Health_Check\Report_Builder_Factory $report_builder_factory)
    {
    }
    /**
     * Returns the report for when permalinks are set to contain the post name.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_success_result()
    {
    }
    /**
     * Returns the report for when permalinks are not set to contain the post name.
     *
     * @return string[] The message as a WordPress site status report.
     */
    public function get_has_no_postname_in_permalink_result()
    {
    }
    /**
     * Returns the description for when permalinks are not set to contain the post name.
     *
     * @return string The description as a string.
     */
    private function get_has_no_postname_in_permalink_description()
    {
    }
    /**
     * Returns the actions for when permalinks are not set to contain the post name.
     *
     * @return string The actions as a string.
     */
    private function get_has_no_postname_in_permalink_actions()
    {
    }
  }
  /**
   * Runs the Postname_Permalink health check.
   */
  class Postname_Permalink_Runner implements \Yoast\WP\SEO\Services\Health_Check\Runner_Interface
  {
    /**
     * Is set to true when permalinks are set to contain the post name
     *
     * @var bool
     */
    private $permalinks_contain_postname;
    /**
     * Constructor.
     */
    public function __construct()
    {
    }
    /**
     * Runs the health check. Checks if permalinks are set to contain the post name.
     *
     * @return void
     */
    public function run()
    {
    }
    /**
     * Returns true if permalinks are set to contain the post name.
     *
     * @return bool True if permalinks are set to contain the post name.
     */
    public function is_successful()
    {
    }
  }
  /**
   * Creates Report_Builder instances.
   */
  class Report_Builder_Factory
  {
    /**
     * Creates a new Report_Builder instance.
     *
     * @param string $test_identifier The test identifier as a string.
     * @return Report_Builder The new Report_Builder instance.
     */
    public function create($test_identifier)
    {
    }
  }
  /**
   * Provides an interface to build WordPress-friendly health check results.
   */
  class Report_Builder
  {
    /**
     * Passed health check.
     */
    const STATUS_GOOD = 'good';
    /**
     * Changes are recommended but not necessary.
     */
    const STATUS_RECOMMENDED = 'recommended';
    /**
     * Significant issues that the user should consider fixing.
     */
    const STATUS_CRITICAL = 'critical';
    /**
     * The user-facing label.
     *
     * @var string
     */
    private $label = '';
    /**
     * The identifier that WordPress uses for the health check.
     *
     * @var string
     */
    private $test_identifier = '';
    /**
     * The test status (good, recommended, critical).
     *
     * @var string
     */
    private $status = '';
    /**
     * The short description for the result.
     *
     * @var string
     */
    private $description = '';
    /**
     * Actions that the user can take to solve the health check result.
     *
     * @var string
     */
    private $actions = '';
    /**
     * Sets the label for the health check that the user can see.
     *
     * @param  string $label The label that the user can see.
     * @return Report_Builder This builder.
     */
    public function set_label($label)
    {
    }
    /**
     * Sets the name for the test that the plugin uses to identify the test.
     *
     * @param  string $test_identifier The identifier for the health check.
     * @return Report_Builder This builder.
     */
    public function set_test_identifier($test_identifier)
    {
    }
    /**
     * Sets the status of the test result to GOOD (green label).
     *
     * @return Report_Builder This builder.
     */
    public function set_status_good()
    {
    }
    /**
     * Sets the status of the test result to RECOMMENDED (orange label).
     *
     * @return Report_Builder This builder.
     */
    public function set_status_recommended()
    {
    }
    /**
     * Sets the status of the test result to CRITICAL (red label).
     *
     * @return Report_Builder This builder.
     */
    public function set_status_critical()
    {
    }
    /**
     * Sets a description for the test result. This will be the heading for the result in the user interface.
     *
     * @param  string $description The description for the test result.
     * @return Report_Builder This builder.
     */
    public function set_description($description)
    {
    }
    /**
     * Sets a text that describes how the user can solve the failed health check.
     *
     * @param  string $actions The descriptive text.
     * @return Report_Builder This builder.
     */
    public function set_actions($actions)
    {
    }
    /**
     * Builds an array of strings in the format that WordPress uses to display health checks (https://developer.wordpress.org/reference/hooks/site_status_test_result/).
     *
     * @return array The report in WordPress' site status report format.
     */
    public function build()
    {
    }
    /**
     * Generates a badge that the user can see.
     *
     * @return string[] The badge.
     */
    private function get_badge()
    {
    }
    /**
     * Generates the label for a badge.
     *
     * @return string The badge label.
     */
    private function get_badge_label()
    {
    }
    /**
     * Generates the color for the badge using the current status.
     *
     * @return string The color for the badge's outline.
     */
    private function get_badge_color()
    {
    }
    /**
     * Concatenates the set actions with Yoast's signature.
     *
     * @return string A string containing the set actions and Yoast's signature.
     */
    private function get_actions_with_signature()
    {
    }
    /**
     * Generates Yoast's signature that's displayed at the bottom of the health check result.
     *
     * @return string Yoast's signature as an HTML string.
     */
    private function get_signature()
    {
    }
  }
}

namespace Yoast\WP\SEO\Services\Importing\Aioseo {
  /**
   * Replaces AISOEO replacevars with Yoast ones.
   */
  class Aioseo_Replacevar_Service
  {
    /**
     * Mapping between the AiOSEO replace vars and the Yoast replace vars.
     *
     * @var array
     *
     * @see https://yoast.com/help/list-available-snippet-variables-yoast-seo/
     */
    protected $replace_vars_map = [
      // The key is the AiOSEO replace var, the value is the Yoast replace var (see class-wpseo-replace-vars).
      '#archive_title' => '%%archive_title%%',
      '#archive_date' => '%%date%%',
      '#attachment_caption' => '%%caption%%',
      '#author_bio' => '%%user_description%%',
      '#author_first_name' => '%%author_first_name%%',
      '#author_last_name' => '%%author_last_name%%',
      '#author_name' => '%%name%%',
      '#blog_title' => '%%sitename%%',
      // Same with #site_title.
      '#categories' => '%%category%%',
      '#current_date' => '%%currentdate%%',
      '#current_day' => '%%currentday%%',
      '#current_month' => '%%currentmonth%%',
      '#current_year' => '%%currentyear%%',
      '#parent_title' => '%%parent_title%%',
      '#page_number' => '%%pagenumber%%',
      '#permalink' => '%%permalink%%',
      '#post_content' => '%%post_content%%',
      '#post_date' => '%%date%%',
      '#post_day' => '%%post_day%%',
      '#post_month' => '%%post_month%%',
      '#post_title' => '%%title%%',
      '#post_year' => '%%post_year%%',
      '#post_excerpt_only' => '%%excerpt_only%%',
      '#post_excerpt' => '%%excerpt%%',
      '#search_term' => '%%searchphrase%%',
      '#separator_sa' => '%%sep%%',
      '#site_title' => '%%sitename%%',
      '#tagline' => '%%sitedesc%%',
      '#taxonomy_title' => '%%category_title%%',
      '#taxonomy_description' => '%%term_description%%',
    ];
    /**
     * Edits the replace_vars map of the class.
     *
     * @param string $aioseo_var The AIOSEO replacevar.
     * @param string $yoast_var  The Yoast replacevar.
     *
     * @return void
     */
    public function compose_map($aioseo_var, $yoast_var)
    {
    }
    /**
     * Transforms AIOSEO replacevars into Yoast replacevars.
     *
     * @param string $aioseo_replacevar The AIOSEO replacevar.
     *
     * @return string The Yoast replacevar.
     */
    public function transform($aioseo_replacevar)
    {
    }
  }
  /**
   * Provides AISOEO search appearance robot settings.
   */
  class Aioseo_Robots_Provider_Service
  {
    /**
     * The AIOSEO helper.
     *
     * @var Aioseo_Helper
     */
    protected $aioseo_helper;
    /**
     * Class constructor.
     *
     * @param Aioseo_Helper $aioseo_helper The AIOSEO helper.
     */
    public function __construct(\Yoast\WP\SEO\Helpers\Aioseo_Helper $aioseo_helper)
    {
    }
    /**
     * Retrieves the robot setting set globally in AIOSEO.
     *
     * @param string $setting_name The name of the robot setting, eg. noindex.
     *
     * @return bool Whether global robot settings enable or not the specific setting.
     */
    public function get_global_robot_settings($setting_name)
    {
    }
    /**
     * Gets the subtype's robot setting from the db.
     *
     * @param array $mapping The mapping of the setting we're working with.
     *
     * @return bool The robot setting.
     */
    public function get_subtype_robot_setting($mapping)
    {
    }
  }
  /**
   * Transforms AISOEO search appearance robot settings.
   */
  class Aioseo_Robots_Transformer_Service
  {
    /**
     * The robots transfomer service.
     *
     * @var Aioseo_Robots_Provider_Service
     */
    protected $robots_provider;
    /**
     * Class constructor.
     *
     * @param Aioseo_Robots_Provider_Service $robots_provider The robots provider service.
     */
    public function __construct(\Yoast\WP\SEO\Services\Importing\Aioseo\Aioseo_Robots_Provider_Service $robots_provider)
    {
    }
    /**
     * Transforms the robot setting, taking into consideration whether they defer to global defaults.
     *
     * @param string $setting_name  The name of the robot setting, eg. noindex.
     * @param bool   $setting_value The value of the robot setting.
     * @param array  $mapping       The mapping of the setting we're working with.
     *
     * @return bool The transformed robot setting.
     */
    public function transform_robot_setting($setting_name, $setting_value, $mapping)
    {
    }
  }
}

namespace Yoast\WP\SEO\Services\Importing {
  /**
   * Detects plugin conflicts.
   */
  class Conflicting_Plugins_Service
  {
    /**
     * Detects the conflicting plugins.
     *
     * @return array A list of all active conflicting plugins.
     */
    public function detect_conflicting_plugins()
    {
    }
    /**
     * Deactivates the specified plugin(s) if any, or the entire list of known conflicting plugins.
     *
     * @param string|array|false $plugins Optional. The plugin filename, or array of plugin filenames, to deactivate.
     */
    public function deactivate_conflicting_plugins($plugins = false)
    {
    }
    /**
     * Loop through the list of known conflicting plugins to check if one of the plugins is active.
     *
     * @param array $all_active_plugins All plugins loaded by WordPress.
     *
     * @return array The array of activated conflicting plugins.
     */
    protected function get_active_conflicting_plugins($all_active_plugins)
    {
    }
    /**
     * Get a list of all plugins active in the current WordPress instance.
     *
     * @return false|array The names of all active plugins.
     */
    protected function get_active_plugins()
    {
    }
    /**
     * While deactivating a plugin, we should ignore the plugin currently being deactivated.
     *
     * @param array $all_active_plugins All plugins currently loaded by WordPress.
     *
     * @return array The remaining active plugins.
     */
    protected function ignore_deactivating_plugin($all_active_plugins)
    {
    }
  }
  /**
   * Detects if any data from other SEO plugins is available for importing.
   */
  class Importable_Detector_Service
  {
    /**
     * All known import actions
     *
     * @var array|Importing_Action_Interface[]
     */
    protected $importers;
    /**
     * Importable_Detector_Service constructor.
     *
     * @param Importing_Action_Interface ...$importers All of the known importers.
     */
    public function __construct(\Yoast\WP\SEO\Actions\Importing\Importing_Action_Interface ...$importers)
    {
    }
    /**
     * Returns the detected importers that have data to work with.
     *
     * @param string|null $plugin The plugin name of the importer.
     * @param string|null $type   The type of the importer.
     *
     * @return array The detected importers that have data to work with.
     */
    public function detect_importers($plugin = null, $type = null)
    {
    }
    /**
     * Returns the detected cleanups that have data to work with.
     *
     * @param string|null $plugin The plugin name of the cleanup.
     *
     * @return array The detected importers that have data to work with.
     */
    public function detect_cleanups($plugin = null)
    {
    }
    /**
     * Filters all import actions from a list that do not match the given Plugin or Type.
     *
     * @param Importing_Action_Interface[] $all_actions The complete list of actions.
     * @param string|null                  $plugin      The Plugin name whose actions to keep.
     * @param string|null                  $type        The type of actions to keep.
     *
     * @return array
     */
    public function filter_actions($all_actions, $plugin = null, $type = null)
    {
    }
  }
}

namespace Yoast\WP\SEO\Services\Indexables {
  /**
   * Handles version control for Indexables.
   */
  class Indexable_Version_Manager
  {
    /**
     * Stores the version of each Indexable type.
     *
     * @var Indexable_Builder_Versions The current versions of all indexable builders.
     */
    protected $indexable_builder_versions;
    /**
     * Indexable_Version_Manager constructor.
     *
     * @param Indexable_Builder_Versions $indexable_builder_versions The current versions of all indexable builders.
     */
    public function __construct(\Yoast\WP\SEO\Values\Indexables\Indexable_Builder_Versions $indexable_builder_versions)
    {
    }
    /**
     * Determines if an Indexable has a lower version than the builder for that Indexable's type.
     *
     * @param Indexable $indexable The Indexable to check.
     *
     * @return bool True if the given version is older than the current latest version.
     */
    public function indexable_needs_upgrade($indexable)
    {
    }
    /**
     * Determines if an Indexable version for the type is lower than the current version for that Indexable type.
     *
     * @param string $object_type       The Indexable's object type.
     * @param int    $indexable_version The Indexable's version.
     *
     * @return bool True if the given version is older than the current latest version.
     */
    protected function needs_upgrade($object_type, $indexable_version)
    {
    }
    /**
     * Sets an Indexable's version to the latest version.
     *
     * @param Indexable $indexable The Indexable to update.
     *
     * @return Indexable
     */
    public function set_latest($indexable)
    {
    }
  }
}

namespace Yoast\WP\SEO\Surfaces {
  /**
   * Class Classes_Surface.
   *
   * Surface for the indexables.
   */
  class Classes_Surface
  {
    /**
     * The dependency injection container.
     *
     * @var ContainerInterface
     */
    public $container;
    /**
     * Loader constructor.
     *
     * @param ContainerInterface $container The dependency injection container.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container)
    {
    }
    /**
     * Returns the instance of a class. Handy for unhooking things.
     *
     * @param string $class_name The class to get the instance of.
     *
     * @return mixed The instance of the class.
     */
    public function get($class_name)
    {
    }
  }
  /**
   * Class Helpers_Surface.
   *
   * Surface for the indexables.
   *
   * @property Helpers\Asset_Helper                           $asset
   * @property Helpers\Author_Archive_Helper                  $author_archive
   * @property Helpers\Blocks_Helper                          $blocks
   * @property Helpers\Capability_Helper                      $capability
   * @property Helpers\Current_Page_Helper                    $current_page
   * @property Helpers\Date_Helper                            $date
   * @property Helpers\Environment_Helper                     $environment
   * @property Helpers\First_Time_Configuration_Notice_Helper $first_time_configuration_notice
   * @property Helpers\Home_Url_Helper                        $home_url
   * @property Helpers\Image_Helper                           $image
   * @property Helpers\Indexable_Helper                       $indexable
   * @property Helpers\Indexing_Helper                        $indexing
   * @property Helpers\Input_Helper                           $input
   * @property Helpers\Language_Helper                        $language
   * @property Helpers\Meta_Helper                            $meta
   * @property Helpers\Notification_Helper                    $notification
   * @property Helpers\Options_Helper                         $options
   * @property Helpers\Pagination_Helper                      $pagination
   * @property Helpers\Permalink_Helper                       $permalink
   * @property Helpers\Post_Helper                            $post
   * @property Helpers\Post_Type_Helper                       $post_type
   * @property Helpers\Primary_Term_Helper                    $primary_term
   * @property Helpers\Product_Helper                         $product
   * @property Helpers\Redirect_Helper                        $redirect
   * @property Helpers\Request_Helper                         $request
   * @property Helpers\Require_File_Helper                    $require_file
   * @property Helpers\Robots_Helper                          $robots
   * @property Helpers\Short_Link_Helper                      $short_link
   * @property Helpers\Site_Helper                            $site
   * @property Helpers\String_Helper                          $string
   * @property Helpers\Social_Profiles_Helper                 $social_profiles
   * @property Helpers\Taxonomy_Helper                        $taxonomy
   * @property Helpers\Url_Helper                             $url
   * @property Helpers\User_Helper                            $user
   * @property Helpers\Woocommerce_Helper                     $woocommerce
   * @property Helpers\Wordpress_Helper                       $wordpress
   */
  class Helpers_Surface
  {
    /**
     * The DI container.
     *
     * @var ContainerInterface
     */
    private $container;
    /**
     * The open_graph helper namespace
     *
     * @var Open_Graph_Helpers_Surface
     */
    public $open_graph;
    /**
     * The schema helper namespace
     *
     * @var Schema_Helpers_Surface
     */
    public $schema;
    /**
     * The twitter helper namespace
     *
     * @var Twitter_Helpers_Surface
     */
    public $twitter;
    /**
     * Loader constructor.
     *
     * @param ContainerInterface         $container  The dependency injection container.
     * @param Open_Graph_Helpers_Surface $open_graph The OpenGraph helpers surface.
     * @param Schema_Helpers_Surface     $schema     The Schema helpers surface.
     * @param Twitter_Helpers_Surface    $twitter    The Twitter helpers surface.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container, \Yoast\WP\SEO\Surfaces\Open_Graph_Helpers_Surface $open_graph, \Yoast\WP\SEO\Surfaces\Schema_Helpers_Surface $schema, \Yoast\WP\SEO\Surfaces\Twitter_Helpers_Surface $twitter)
    {
    }
    /**
     * Magic getter for getting helper classes.
     *
     * @param string $helper The helper to get.
     *
     * @return mixed The helper class.
     */
    public function __get($helper)
    {
    }
    /**
     * Magic isset for ensuring helper exists.
     *
     * @param string $helper The helper to get.
     *
     * @return bool Whether the helper exists.
     */
    public function __isset($helper)
    {
    }
    /**
     * Prevents setting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name  The property name.
     * @param mixed  $value The property value.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Set is never meant to be called.
     */
    public function __set($name, $value)
    {
    }
    /**
     * Prevents unsetting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name The property name.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Unset is never meant to be called.
     */
    public function __unset($name)
    {
    }
    /**
     * Get the class name from a helper slug
     *
     * @param string $helper The name of the helper.
     *
     * @return string
     */
    protected function get_helper_class($helper)
    {
    }
  }
  /**
   * Meta_Surface class.
   *
   * Surface for the indexables.
   */
  class Meta_Surface
  {
    /**
     * The container.
     *
     * @var ContainerInterface
     */
    private $container;
    /**
     * The memoizer for the meta tags context.
     *
     * @var Meta_Tags_Context_Memoizer
     */
    private $context_memoizer;
    /**
     * The indexable repository.
     *
     * @var Indexable_Repository
     */
    private $repository;
    /**
     * Holds the WP rewrite wrapper instance.
     *
     * @var WP_Rewrite_Wrapper
     */
    private $wp_rewrite_wrapper;
    /**
     * The indexable helper.
     *
     * @var Indexable_Helper
     */
    private $indexable_helper;
    /**
     * Meta_Surface constructor.
     *
     * @param ContainerInterface         $container            The DI container.
     * @param Meta_Tags_Context_Memoizer $context_memoizer     The meta tags context memoizer.
     * @param Indexable_Repository       $indexable_repository The indexable repository.
     * @param WP_Rewrite_Wrapper         $wp_rewrite_wrapper   The WP rewrite wrapper.
     * @param Indexable_Helper           $indexable_helper     The indexable helper.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container, \Yoast\WP\SEO\Memoizers\Meta_Tags_Context_Memoizer $context_memoizer, \Yoast\WP\SEO\Repositories\Indexable_Repository $indexable_repository, \Yoast\WP\SEO\Wrappers\WP_Rewrite_Wrapper $wp_rewrite_wrapper, \Yoast\WP\SEO\Helpers\Indexable_Helper $indexable_helper)
    {
    }
    /**
     * Returns the meta tags context for the current page.
     *
     * @return Meta The meta values.
     */
    public function for_current_page()
    {
    }
    /**
     * Returns the meta tags context for the home page.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_home_page()
    {
    }
    /**
     * Returns the meta tags context for the posts page.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_posts_page()
    {
    }
    /**
     * Returns the meta tags context for a post type archive.
     *
     * @param string|null $post_type Optional. The post type to get the archive meta for. Defaults to the current post type.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_post_type_archive($post_type = null)
    {
    }
    /**
     * Returns the meta tags context for the search result page.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_search_result()
    {
    }
    /**
     * Returns the meta tags context for the search result page.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_404()
    {
    }
    /**
     * Returns the meta tags context for a post.
     *
     * @param int $id The ID of the post.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_post($id)
    {
    }
    /**
     * Returns the meta tags context for a number of posts.
     *
     * @param int[] $ids The IDs of the posts.
     *
     * @return Meta[]|false The meta values. False if none could be found.
     */
    public function for_posts($ids)
    {
    }
    /**
     * Returns the meta tags context for a term.
     *
     * @param int $id The ID of the term.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_term($id)
    {
    }
    /**
     * Returns the meta tags context for an author.
     *
     * @param int $id The ID of the author.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_author($id)
    {
    }
    /**
     * Returns the meta for an indexable.
     *
     * @param Indexable   $indexable The indexable.
     * @param string|null $page_type Optional. The page type if already known.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_indexable($indexable, $page_type = null)
    {
    }
    /**
     * Returns the meta for an indexable.
     *
     * @param Indexable[] $indexables The indexables.
     * @param string|null $page_type  Optional. The page type if already known.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_indexables($indexables, $page_type = null)
    {
    }
    /**
     * Returns the meta tags context for a url.
     *
     * @param string $url The url of the page. Required to be relative to the site url.
     *
     * @return Meta|false The meta values. False if none could be found.
     */
    public function for_url($url)
    {
    }
    /**
     * Checks if a given URL is a date archive URL.
     *
     * @param string $url The url.
     *
     * @return bool
     */
    protected function is_date_archive_url($url)
    {
    }
    /**
     * Creates a new meta value object
     *
     * @param Meta_Tags_Context $context The meta tags context.
     *
     * @return Meta The meta value
     */
    protected function build_meta(\Yoast\WP\SEO\Context\Meta_Tags_Context $context)
    {
    }
  }
  /**
   * Class Open_Graph_Helpers_Surface.
   *
   * Surface for the indexables.
   *
   * @property Open_Graph\Image_Helper $image
   */
  class Open_Graph_Helpers_Surface
  {
    /**
     * The DI container.
     *
     * @var ContainerInterface
     */
    private $container;
    /**
     * Loader constructor.
     *
     * @param ContainerInterface $container The dependency injection container.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container)
    {
    }
    /**
     * Magic getter for getting helper classes.
     *
     * @param string $helper The helper to get.
     *
     * @return mixed The helper class.
     */
    public function __get($helper)
    {
    }
    /**
     * Magic isset for ensuring helper exists.
     *
     * @param string $helper The helper to get.
     *
     * @return bool Whether the helper exists.
     */
    public function __isset($helper)
    {
    }
    /**
     * Prevents setting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name  The property name.
     * @param mixed  $value The property value.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Set is never meant to be called.
     */
    public function __set($name, $value)
    {
    }
    /**
     * Prevents unsetting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name The property name.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Unset is never meant to be called.
     */
    public function __unset($name)
    {
    }
    /**
     * Get the class name from a helper slug
     *
     * @param string $helper The name of the helper.
     *
     * @return string
     */
    protected function get_helper_class($helper)
    {
    }
  }
  /**
   * Class Schema_Helpers_Surface.
   *
   * Surface for the indexables.
   *
   * @property Schema\Article_Helper $article
   * @property Schema\HTML_Helper $html
   * @property Schema\ID_Helper $id
   * @property Schema\Image_Helper $image
   * @property Schema\Language_Helper $language
   */
  class Schema_Helpers_Surface
  {
    /**
     * The DI container.
     *
     * @var ContainerInterface
     */
    private $container;
    /**
     * Helpers that should be fully capitalized.
     *
     * @var array
     */
    private $capitalized_helpers = ['html', 'id'];
    /**
     * Loader constructor.
     *
     * @param ContainerInterface $container The dependency injection container.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container)
    {
    }
    /**
     * Magic getter for getting helper classes.
     *
     * @param string $helper The helper to get.
     *
     * @return mixed The helper class.
     */
    public function __get($helper)
    {
    }
    /**
     * Magic isset for ensuring helper exists.
     *
     * @param string $helper The helper to get.
     *
     * @return bool Whether the helper exists.
     */
    public function __isset($helper)
    {
    }
    /**
     * Prevents setting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name  The property name.
     * @param mixed  $value The property value.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Set is never meant to be called.
     */
    public function __set($name, $value)
    {
    }
    /**
     * Prevents unsetting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name The property name.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Unset is never meant to be called.
     */
    public function __unset($name)
    {
    }
    /**
     * Get the class name from a helper slug
     *
     * @param string $helper The name of the helper.
     *
     * @return string
     */
    protected function get_helper_class($helper)
    {
    }
  }
  /**
   * Class Twitter_Helpers_Surface.
   *
   * Surface for the indexables.
   *
   * @property Twitter\Image_Helper $image
   */
  class Twitter_Helpers_Surface
  {
    /**
     * The DI container.
     *
     * @var ContainerInterface
     */
    private $container;
    /**
     * Loader constructor.
     *
     * @param ContainerInterface $container The dependency injection container.
     */
    public function __construct(\YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container)
    {
    }
    /**
     * Magic getter for getting helper classes.
     *
     * @param string $helper The helper to get.
     *
     * @return mixed The helper class.
     */
    public function __get($helper)
    {
    }
    /**
     * Magic isset for ensuring helper exists.
     *
     * @param string $helper The helper to get.
     *
     * @return bool Whether the helper exists.
     */
    public function __isset($helper)
    {
    }
    /**
     * Prevents setting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name  The property name.
     * @param mixed  $value The property value.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Set is never meant to be called.
     */
    public function __set($name, $value)
    {
    }
    /**
     * Prevents unsetting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name The property name.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Unset is never meant to be called.
     */
    public function __unset($name)
    {
    }
    /**
     * Get the class name from a helper slug
     *
     * @param string $helper The name of the helper.
     *
     * @return string
     */
    protected function get_helper_class($helper)
    {
    }
  }
}

namespace Yoast\WP\SEO\Surfaces\Values {
  /**
   * Meta value object.
   *
   * @property array       $breadcrumbs                       The breadcrumbs array for the current page.
   * @property string      $canonical                         The canonical URL for the current page.
   * @property string      $company_name                      The company name from the Knowledge graph settings.
   * @property int         $company_logo_id                   The attachment ID for the company logo.
   * @property string      $description                       The meta description for the current page, if set.
   * @property int         $estimated_reading_time_minutes    The estimated reading time in minutes for posts.
   * @property Indexable   $indexable                         The indexable object.
   * @property string      $main_schema_id                    Schema ID that points to the main Schema thing on the page, usually the webpage or article Schema piece.
   * @property string      $meta_description                  The meta description for the current page, if set.
   * @property string      $open_graph_article_author         The article:author value.
   * @property string      $open_graph_article_modified_time  The article:modified_time value.
   * @property string      $open_graph_article_published_time The article:published_time value.
   * @property string      $open_graph_article_publisher      The article:publisher value.
   * @property string      $open_graph_description            The og:description.
   * @property bool        $open_graph_enabled                Whether OpenGraph is enabled on this site.
   * @property string      $open_graph_fb_app_id              The Facebook App ID.
   * @property array       $open_graph_images                 The array of images we have for this page.
   * @property string      $open_graph_locale                 The og:locale for the current page.
   * @property string      $open_graph_publisher              The OpenGraph publisher reference.
   * @property string      $open_graph_site_name              The og:site_name.
   * @property string      $open_graph_title                  The og:title.
   * @property string      $open_graph_type                   The og:type.
   * @property string      $open_graph_url                    The og:url.
   * @property string      $page_type                         The Schema page type.
   * @property array       $robots                            An array of the robots values set for the current page.
   * @property string      $rel_next                          The next page in the series, if any.
   * @property string      $rel_prev                          The previous page in the series, if any.
   * @property array       $schema                            The entire Schema array for the current page.
   * @property string      $schema_page_type                  The Schema page type.
   * @property string      $site_name                         The site name from the Yoast SEO settings.
   * @property string      $site_represents                   Whether the site represents a 'person' or a 'company'.
   * @property array|false $site_represents_reference         The schema reference ID for what this site represents.
   * @property string      $site_url                          The site's main URL.
   * @property int         $site_user_id                      If the site represents a 'person', this is the ID of the accompanying user profile.
   * @property string      $title                             The SEO title for the current page.
   * @property string      $twitter_card                      The Twitter card type for the current page.
   * @property string      $twitter_creator                   The Twitter card author for the current page.
   * @property string      $twitter_description               The Twitter card description for the current page.
   * @property string      $twitter_image                     The Twitter card image for the current page.
   * @property string      $twitter_site                      The Twitter card site reference for the current page.
   * @property string      $twitter_title                     The Twitter card title for the current page.
   * @property string      $wordpress_site_name               The site name from the WordPress settings.
   */
  class Meta
  {
    /**
     * The container.
     *
     * @var ContainerInterface
     */
    protected $container;
    /**
     * The meta tags context.
     *
     * @var Meta_Tags_Context
     */
    protected $context;
    /**
     * The front end integration.
     *
     * @var Front_End_Integration
     */
    protected $front_end;
    /**
     * The helpers surface.
     *
     * @var Helpers_Surface
     */
    protected $helpers;
    /**
     * The replace vars helper
     *
     * @var WPSEO_Replace_Vars
     */
    protected $replace_vars;
    /**
     * Collection of properties dynamically set via the magic __get() method.
     *
     * @var array<string, mixed> Key is the property name.
     */
    private $properties_bin = [];
    /**
     * Create a meta value object.
     *
     * @param Meta_Tags_Context  $context   The indexable presentation.
     * @param ContainerInterface $container The DI container.
     */
    public function __construct(\Yoast\WP\SEO\Context\Meta_Tags_Context $context, \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ContainerInterface $container)
    {
    }
    /**
     * Returns the output as would be presented in the head.
     *
     * @return object The HTML and JSON presentation of the head metadata.
     */
    public function get_head()
    {
    }
    /**
     * Magic getter for presenting values through the appropriate presenter, if it exists.
     *
     * @param string $name The property to get.
     *
     * @return mixed The value, as presented by the appropriate presenter.
     */
    public function __get($name)
    {
    }
    /**
     * Magic isset for ensuring properties on the presentation are recognised.
     *
     * @param string $name The property to get.
     *
     * @return bool Whether or not the requested property exists.
     */
    public function __isset($name)
    {
    }
    /**
     * Prevents setting dynamic properties and overwriting the value of declared properties
     * from an inaccessible context.
     *
     * @param string $name  The property name.
     * @param mixed  $value The property value.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Set is never meant to be called.
     */
    public function __set($name, $value)
    {
    }
    /**
     * Prevents unsetting dynamic properties and unsetting declared properties
     * from an inaccessible context.
     *
     * @param string $name The property name.
     *
     * @return void
     *
     * @throws Forbidden_Property_Mutation_Exception Unset is never meant to be called.
     */
    public function __unset($name)
    {
    }
    /**
     * Strips all nested dependencies from the debug info.
     *
     * @return array
     */
    public function __debugInfo()
    {
    }
    /**
     * Returns all presenters.
     *
     * @return Abstract_Indexable_Presenter[]
     */
    protected function get_presenters()
    {
    }
    /**
     * Uses the presenter to create a line of HTML.
     *
     * @param Abstract_Indexable_Presenter $presenter The presenter.
     *
     * @return string
     */
    protected function create_html_presentation($presenter)
    {
    }
    /**
     * Converts a presenter's key and value to JSON.
     *
     * @param Abstract_Indexable_Presenter $presenter The presenter whose key and value are to be converted to JSON.
     *
     * @return object|null
     */
    protected function create_json_field($presenter)
    {
    }
  }
}

namespace Yoast\WP\SEO\Values\Indexables {
  /**
   * Class Indexable_Builder_Versions
   */
  class Indexable_Builder_Versions
  {
    const DEFAULT_INDEXABLE_BUILDER_VERSION = 1;
    /**
     * The list of indexable builder versions defined by Yoast SEO Free.
     * If the key is not in this list, the indexable type will not be managed.
     * These numbers should be increased if one of the builders implements a new feature.
     *
     * @var array
     */
    protected $indexable_builder_versions_by_type = ['date-archive' => self::DEFAULT_INDEXABLE_BUILDER_VERSION, 'general' => self::DEFAULT_INDEXABLE_BUILDER_VERSION, 'home-page' => 2, 'post' => 2, 'post-type-archive' => 2, 'term' => 2, 'user' => 2, 'system-page' => self::DEFAULT_INDEXABLE_BUILDER_VERSION];
    /**
     * Provides the most recent version number for an Indexable's object type.
     *
     * @param string $object_type The Indexable type for which you want to know the most recent version.
     *
     * @return int The most recent version number for the type, or 1 if the version doesn't exist.
     */
    public function get_latest_version_for_type($object_type)
    {
    }
  }
}

namespace Yoast\WP\SEO\Values\OAuth {
  /**
   * Class OAuth_Token
   */
  class OAuth_Token
  {
    /**
     * The access token.
     *
     * @var string
     */
    public $access_token;
    /**
     * The refresh token.
     *
     * @var string
     */
    public $refresh_token;
    /**
     * The expiration date.
     *
     * @var int
     */
    public $expires;
    /**
     * Whether or not the token has expired.
     *
     * @var bool
     */
    public $has_expired;
    /**
     * The timestamp at which the token was created.
     *
     * @var int
     */
    public $created_at;
    /**
     * The number of times we've gotten an error trying to refresh this token.
     *
     * @var int
     */
    public $error_count;
    /**
     * OAuth_Token constructor.
     *
     * @param string $access_token  The access token.
     * @param string $refresh_token The refresh token.
     * @param int    $expires       The date and time at which the token will expire.
     * @param bool   $has_expired   Whether or not the token has expired.
     * @param int    $created_at    The timestamp of when the token was created.
     * @param int    $error_count   The number of times we've gotten an error trying to refresh this token.
     *
     * @throws Empty_Property_Exception Exception thrown if a token property is empty.
     */
    public function __construct($access_token, $refresh_token, $expires, $has_expired, $created_at, $error_count = 0)
    {
    }
    /**
     * Creates a new instance based on the passed response.
     *
     * @param AccessTokenInterface $response The response object to create a new instance from.
     *
     * @return OAuth_Token The token object.
     *
     * @throws Empty_Property_Exception Exception thrown if a token property is empty.
     */
    public static function from_response(\YoastSEO_Vendor\League\OAuth2\Client\Token\AccessTokenInterface $response)
    {
    }
    /**
     * Determines whether or not the token has expired.
     *
     * @return bool Whether or not the token has expired.
     */
    public function has_expired()
    {
    }
    /**
     * Converts the object to an array.
     *
     * @return array The converted object.
     */
    public function to_array()
    {
    }
  }
}

namespace Yoast\WP\SEO\Values\Robots {
  /**
   * Class Directive
   */
  class Directive
  {
    /**
     * Paths list.
     *
     * @var array All paths affected by this directive.
     */
    private $paths;
    /**
     * Sets up the path array
     */
    public function __construct()
    {
    }
    /**
     * Adds a path to the directive path list.
     *
     * @param string $path A path to add in the path list.
     *
     * @return void
     */
    public function add_path($path)
    {
    }
    /**
     * Returns all paths.
     *
     * @return array
     */
    public function get_paths()
    {
    }
  }
  /**
   * Class User_Agent_List
   */
  class User_Agent_List
  {
    /**
     * The list of user agents.
     *
     * @var array
     */
    private $user_agent_list;
    /**
     * User Agent list constructor.
     */
    public function __construct()
    {
    }
    /**
     * Checks if given user_agent is already registered.
     *
     * @param string $user_agent The user agent identifier.
     *
     * @return bool
     */
    public function has_user_agent($user_agent)
    {
    }
    /**
     * Gets the user agent object. If it is not yet registered it creates it.
     *
     * @param string $user_agent The user agent identifier.
     *
     * @return User_Agent
     */
    public function get_user_agent($user_agent)
    {
    }
    /**
     * Gets the list of user agents.
     *
     * @return array
     */
    public function get_user_agents()
    {
    }
    /**
     * Gets a list of all disallow directives by user agent.
     *
     * @return array
     */
    public function get_disallow_directives()
    {
    }
    /**
     * Gets a list of all sallow directives by user agent.
     *
     * @return array
     */
    public function get_allow_directives()
    {
    }
  }
  /**
   * Class Directive
   */
  class User_Agent
  {
    /**
     * The user agent identifier.
     *
     * @var string
     */
    private $user_agent;
    /**
     * All directives that are allowed for this user agent.
     *
     * @var Directive
     */
    private $allow_directive;
    /**
     * All directives that are disallowed for this user agent.
     *
     * @var Directive
     */
    private $disallow_directive;
    /**
     * Constructor of the user agent value object.
     *
     * @param string $user_agent The user agent identifier.
     */
    public function __construct($user_agent)
    {
    }
    /**
     * Gets the user agent identifier.
     *
     * @return string
     */
    public function get_user_agent()
    {
    }
    /**
     * Adds a path to the directive object.
     *
     * @param string $path The path to add to the disallow directive.
     *
     * @return void
     */
    public function add_disallow_directive($path)
    {
    }
    /**
     * Adds a path to the directive object.
     *
     * @param string $path The path to add to the allow directive.
     *
     * @return void
     */
    public function add_allow_directive($path)
    {
    }
    /**
     * Gets all disallow paths for this user agent.
     *
     * @return array
     */
    public function get_disallow_paths()
    {
    }
    /**
     * Gets all sallow paths for this user agent.
     *
     * @return array
     */
    public function get_allow_paths()
    {
    }
  }
}

namespace Yoast\WP\SEO\WordPress {
  /**
   * Wrapper class for WordPress globals.
   *
   * This consists of factory functions to inject WP globals into the dependency container.
   */
  class Wrapper
  {
    /**
     * Wrapper method for returning the wpdb object for use in dependency injection.
     *
     * @return wpdb The wpdb global.
     */
    public static function get_wpdb()
    {
    }
    /**
     * Factory function for replace vars helper.
     *
     * @return WPSEO_Replace_Vars The replace vars helper.
     */
    public static function get_replace_vars()
    {
    }
    /**
     * Factory function for the admin asset manager.
     *
     * @return WPSEO_Admin_Asset_Manager The admin asset manager.
     */
    public static function get_admin_asset_manager()
    {
    }
    /**
     * Factory function for the addon manager.
     *
     * @return WPSEO_Addon_Manager The addon manager.
     */
    public static function get_addon_manager()
    {
    }
    /**
     * Factory function for the shortlinker.
     *
     * @return WPSEO_Shortlinker
     */
    public static function get_shortlinker()
    {
    }
    /**
     * Factory function for the utils class.
     *
     * @return WPSEO_Utils
     */
    public static function get_utils()
    {
    }
  }
}

namespace Yoast\WP\SEO\Wrappers {
  /**
   * Wrapper for WP_Query.
   */
  class WP_Query_Wrapper
  {
    /**
     * Returns the global WP_Query object.
     *
     * @return WP_Query The WP_Query object.
     */
    public function get_query()
    {
    }
    /**
     * Returns the global main WP_Query object.
     *
     * @return WP_Query The WP_Query object.
     */
    public function get_main_query()
    {
    }
    /**
     * Sets the global WP_Query object.
     *
     * @param WP_Query $wp_query The WP Query.
     */
    public function set_query(\WP_Query $wp_query)
    {
    }
    /**
     * Resets the global WP_Query object.
     */
    public function reset_query()
    {
    }
  }
  /**
   * Wraps wp_remote_get in an interface compatible with Guzzle.
   */
  class WP_Remote_Handler
  {
    /**
     * Calls the handler.
     * Cookies are currently not supported as they are not used by OAuth.
     * Writing responses to files is also not supported for the same reason.
     *
     * @param RequestInterface $request The request.
     * @param array            $options The request options.
     *
     * @return PromiseInterface The promise interface.
     *
     * @throws Exception If the request fails.
     */
    public function __invoke(\YoastSEO_Vendor\Psr\Http\Message\RequestInterface $request, array $options)
    {
    }
  }
  /**
   * Wrapper for WP_Rewrite.
   */
  class WP_Rewrite_Wrapper
  {
    /**
     * Returns the global WP_Rewrite_Wrapper object.
     *
     * @return WP_Rewrite The WP_Query object.
     */
    public function get()
    {
    }
  }
}

namespace YoastSEO_Vendor\League\OAuth2\Client\Provider\Exception {
  /**
   * Exception thrown if the provider response contains errors.
   */
  class IdentityProviderException extends \Exception
  {
    /**
     * @var mixed
     */
    protected $response;
    /**
     * @param string $message
     * @param int $code
     * @param array|string $response The response body
     */
    public function __construct($message, $code, $response)
    {
    }
    /**
     * Returns the exception's response body.
     *
     * @return array|string
     */
    public function getResponseBody()
    {
    }
  }
}

namespace YoastSEO_Vendor\League\OAuth2\Client\Provider {
  /**
   * Classes implementing `ResourceOwnerInterface` may be used to represent
   * the resource owner authenticated with a service provider.
   */
  interface ResourceOwnerInterface
  {
    /**
     * Returns the identifier of the authorized resource owner.
     *
     * @return mixed
     */
    public function getId();
    /**
     * Return all of the owner details available as an array.
     *
     * @return array
     */
    public function toArray();
  }
  /**
   * Represents a generic resource owner for use with the GenericProvider.
   */
  class GenericResourceOwner implements \YoastSEO_Vendor\League\OAuth2\Client\Provider\ResourceOwnerInterface
  {
    /**
     * @var array
     */
    protected $response;
    /**
     * @var string
     */
    protected $resourceOwnerId;
    /**
     * @param array $response
     * @param string $resourceOwnerId
     */
    public function __construct(array $response, $resourceOwnerId)
    {
    }
    /**
     * Returns the identifier of the authorized resource owner.
     *
     * @return mixed
     */
    public function getId()
    {
    }
    /**
     * Returns the raw resource owner response.
     *
     * @return array
     */
    public function toArray()
    {
    }
  }
}

namespace YoastSEO_Vendor\League\OAuth2\Client\Tool {
  /**
   * Enables `MAC` header authorization for providers.
   *
   * @link http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-05 Message Authentication Code (MAC) Tokens
   */
  trait MacAuthorizationTrait
  {
    /**
     * Returns the id of this token for MAC generation.
     *
     * @param  AccessToken $token
     * @return string
     */
    protected abstract function getTokenId(\YoastSEO_Vendor\League\OAuth2\Client\Token\AccessToken $token);
    /**
     * Returns the MAC signature for the current request.
     *
     * @param  string $id
     * @param  integer $ts
     * @param  string $nonce
     * @return string
     */
    protected abstract function getMacSignature($id, $ts, $nonce);
    /**
     * Returns a new random string to use as the state parameter in an
     * authorization flow.
     *
     * @param  int $length Length of the random string to be generated.
     * @return string
     */
    protected abstract function getRandomState($length = 32);
    /**
     * Returns the authorization headers for the 'mac' grant.
     *
     * @param  AccessTokenInterface|string|null $token Either a string or an access token instance
     * @return array
     * @codeCoverageIgnore
     *
     * @todo This is currently untested and provided only as an example. If you
     * complete the implementation, please create a pull request for
     * https://github.com/thephpleague/oauth2-client
     */
    protected function getAuthorizationHeaders($token = null)
    {
    }
  }
  trait ProviderRedirectTrait
  {
    /**
     * Maximum number of times to follow provider initiated redirects
     *
     * @var integer
     */
    protected $redirectLimit = 2;
    /**
     * Retrieves a response for a given request and retrieves subsequent
     * responses, with authorization headers, if a redirect is detected.
     *
     * @param  RequestInterface $request
     * @return ResponseInterface
     * @throws BadResponseException
     */
    protected function followRequestRedirects(\YoastSEO_Vendor\Psr\Http\Message\RequestInterface $request)
    {
    }
    /**
     * Returns the HTTP client instance.
     *
     * @return GuzzleHttp\ClientInterface
     */
    public abstract function getHttpClient();
    /**
     * Retrieves current redirect limit.
     *
     * @return integer
     */
    public function getRedirectLimit()
    {
    }
    /**
     * Determines if a given response is a redirect.
     *
     * @param  ResponseInterface  $response
     *
     * @return boolean
     */
    protected function isRedirect(\YoastSEO_Vendor\Psr\Http\Message\ResponseInterface $response)
    {
    }
    /**
     * Sends a request instance and returns a response instance.
     *
     * WARNING: This method does not attempt to catch exceptions caused by HTTP
     * errors! It is recommended to wrap this method in a try/catch block.
     *
     * @param  RequestInterface $request
     * @return ResponseInterface
     */
    public function getResponse(\YoastSEO_Vendor\Psr\Http\Message\RequestInterface $request)
    {
    }
    /**
     * Updates the redirect limit.
     *
     * @param integer $limit
     * @return League\OAuth2\Client\Provider\AbstractProvider
     * @throws InvalidArgumentException
     */
    public function setRedirectLimit($limit)
    {
    }
  }
  /**
   * Used to produce PSR-7 Request instances.
   *
   * @link https://github.com/guzzle/guzzle/pull/1101
   */
  class RequestFactory
  {
    /**
     * Creates a PSR-7 Request instance.
     *
     * @param  null|string $method HTTP method for the request.
     * @param  null|string $uri URI for the request.
     * @param  array $headers Headers for the message.
     * @param  string|resource|StreamInterface $body Message body.
     * @param  string $version HTTP protocol version.
     *
     * @return Request
     */
    public function getRequest($method, $uri, array $headers = [], $body = null, $version = '1.1')
    {
    }
    /**
     * Parses simplified options.
     *
     * @param array $options Simplified options.
     *
     * @return array Extended options for use with getRequest.
     */
    protected function parseOptions(array $options)
    {
    }
    /**
     * Creates a request using a simplified array of options.
     *
     * @param  null|string $method
     * @param  null|string $uri
     * @param  array $options
     *
     * @return Request
     */
    public function getRequestWithOptions($method, $uri, array $options = [])
    {
    }
  }
  /**
   * Provides functionality to check for required parameters.
   */
  trait RequiredParameterTrait
  {
    /**
     * Checks for a required parameter in a hash.
     *
     * @throws BadMethodCallException
     * @param  string $name
     * @param  array  $params
     * @return void
     */
    private function checkRequiredParameter($name, array $params)
    {
    }
    /**
     * Checks for multiple required parameters in a hash.
     *
     * @throws InvalidArgumentException
     * @param  array $names
     * @param  array $params
     * @return void
     */
    private function checkRequiredParameters(array $names, array $params)
    {
    }
  }
}

namespace YoastSEO_Vendor\Psr\Container {
  /**
   * Base interface representing a generic exception in a container.
   */
  interface ContainerExceptionInterface
  {
  }
  /**
   * No entry was found in the container.
   */
  interface NotFoundExceptionInterface extends \YoastSEO_Vendor\Psr\Container\ContainerExceptionInterface
  {
  }
}

namespace YoastSEO_Vendor\Psr\Log {
  /**
   * This is a simple Logger implementation that other Loggers can inherit from.
   *
   * It simply delegates all log-level-specific methods to the `log` method to
   * reduce boilerplate code that a simple Logger that does the same thing with
   * messages regardless of the error level has to implement.
   */
  abstract class AbstractLogger implements \YoastSEO_Vendor\Psr\Log\LoggerInterface
  {
    /**
     * System is unusable.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function emergency($message, array $context = array())
    {
    }
    /**
     * Action must be taken immediately.
     *
     * Example: Entire website down, database unavailable, etc. This should
     * trigger the SMS alerts and wake you up.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function alert($message, array $context = array())
    {
    }
    /**
     * Critical conditions.
     *
     * Example: Application component unavailable, unexpected exception.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function critical($message, array $context = array())
    {
    }
    /**
     * Runtime errors that do not require immediate action but should typically
     * be logged and monitored.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function error($message, array $context = array())
    {
    }
    /**
     * Exceptional occurrences that are not errors.
     *
     * Example: Use of deprecated APIs, poor use of an API, undesirable things
     * that are not necessarily wrong.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function warning($message, array $context = array())
    {
    }
    /**
     * Normal but significant events.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function notice($message, array $context = array())
    {
    }
    /**
     * Interesting events.
     *
     * Example: User logs in, SQL logs.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function info($message, array $context = array())
    {
    }
    /**
     * Detailed debug information.
     *
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function debug($message, array $context = array())
    {
    }
  }
  class InvalidArgumentException extends \InvalidArgumentException
  {
  }
  /**
   * Describes log levels.
   */
  class LogLevel
  {
    const EMERGENCY = 'emergency';
    const ALERT = 'alert';
    const CRITICAL = 'critical';
    const ERROR = 'error';
    const WARNING = 'warning';
    const NOTICE = 'notice';
    const INFO = 'info';
    const DEBUG = 'debug';
  }
  /**
   * Describes a logger-aware instance.
   */
  interface LoggerAwareInterface
  {
    /**
     * Sets a logger instance on the object.
     *
     * @param LoggerInterface $logger
     *
     * @return void
     */
    public function setLogger(\YoastSEO_Vendor\Psr\Log\LoggerInterface $logger);
  }
  /**
   * Basic Implementation of LoggerAwareInterface.
   */
  trait LoggerAwareTrait
  {
    /**
     * The logger instance.
     *
     * @var LoggerInterface
     */
    protected $logger;
    /**
     * Sets a logger.
     *
     * @param LoggerInterface $logger
     */
    public function setLogger(\YoastSEO_Vendor\Psr\Log\LoggerInterface $logger)
    {
    }
  }
  /**
   * This Logger can be used to avoid conditional log calls.
   *
   * Logging should always be optional, and if no logger is provided to your
   * library creating a NullLogger instance to have something to throw logs at
   * is a good way to avoid littering your code with `if ($this->logger) { }`
   * blocks.
   */
  class NullLogger extends \YoastSEO_Vendor\Psr\Log\AbstractLogger
  {
    /**
     * Logs with an arbitrary level.
     *
     * @param mixed  $level
     * @param string $message
     * @param array  $context
     *
     * @return void
     */
    public function log($level, $message, array $context = array())
    {
    }
  }
}

namespace YoastSEO_Vendor\Symfony\Component\DependencyInjection\Argument {
  /**
   * @internal
   */
  class RewindableGenerator implements \IteratorAggregate, \Countable
  {
    private $generator;
    private $count;
    /**
     * @param int|callable $count
     */
    public function __construct(callable $generator, $count)
    {
    }
    public function getIterator()
    {
    }
    public function count()
    {
    }
  }
}

namespace YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception {
  /**
   * Base ExceptionInterface for Dependency Injection component.
   *
   * @author Fabien Potencier <fabien@symfony.com>
   * @author Bulat Shakirzyanov <bulat@theopenskyproject.com>
   */
  interface ExceptionInterface extends \YoastSEO_Vendor\Psr\Container\ContainerExceptionInterface
  {
  }
  /**
   * Base InvalidArgumentException for Dependency Injection component.
   *
   * @author Bulat Shakirzyanov <bulat@theopenskyproject.com>
   */
  class InvalidArgumentException extends \InvalidArgumentException implements \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception\ExceptionInterface
  {
  }
  /**
   * This exception is thrown when an environment variable is not found.
   *
   * @author Nicolas Grekas <p@tchwork.com>
   */
  class EnvNotFoundException extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException
  {
    public function __construct($name)
    {
    }
  }
  /**
   * Base LogicException for Dependency Injection component.
   */
  class LogicException extends \LogicException implements \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception\ExceptionInterface
  {
  }
  /**
   * Base RuntimeException for Dependency Injection component.
   *
   * @author Johannes M. Schmitt <schmittjoh@gmail.com>
   */
  class RuntimeException extends \RuntimeException implements \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception\ExceptionInterface
  {
  }
  /**
   * This exception is thrown when a circular reference in a parameter is detected.
   *
   * @author Fabien Potencier <fabien@symfony.com>
   */
  class ParameterCircularReferenceException extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception\RuntimeException
  {
    private $parameters;
    public function __construct($parameters, \Exception $previous = null)
    {
    }
    public function getParameters()
    {
    }
  }
  /**
   * This exception is thrown when a circular reference is detected.
   *
   * @author Johannes M. Schmitt <schmittjoh@gmail.com>
   */
  class ServiceCircularReferenceException extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception\RuntimeException
  {
    private $serviceId;
    private $path;
    public function __construct($serviceId, array $path, \Exception $previous = null)
    {
    }
    public function getServiceId()
    {
    }
    public function getPath()
    {
    }
  }
  /**
   * This exception is thrown when a non-existent service is requested.
   *
   * @author Johannes M. Schmitt <schmittjoh@gmail.com>
   */
  class ServiceNotFoundException extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException implements \YoastSEO_Vendor\Psr\Container\NotFoundExceptionInterface
  {
    private $id;
    private $sourceId;
    private $alternatives;
    public function __construct($id, $sourceId = null, \Exception $previous = null, array $alternatives = [], $msg = null)
    {
    }
    public function getId()
    {
    }
    public function getSourceId()
    {
    }
    public function getAlternatives()
    {
    }
  }
}

namespace YoastSEO_Vendor\Symfony\Component\DependencyInjection\ParameterBag {
  /**
   * ParameterBagInterface.
   *
   * @author Fabien Potencier <fabien@symfony.com>
   */
  interface ParameterBagInterface
  {
    /**
     * Clears all parameters.
     *
     * @throws LogicException if the ParameterBagInterface can not be cleared
     */
    public function clear();
    /**
     * Adds parameters to the service container parameters.
     *
     * @param array $parameters An array of parameters
     *
     * @throws LogicException if the parameter can not be added
     */
    public function add(array $parameters);
    /**
     * Gets the service container parameters.
     *
     * @return array An array of parameters
     */
    public function all();
    /**
     * Gets a service container parameter.
     *
     * @param string $name The parameter name
     *
     * @return mixed The parameter value
     *
     * @throws ParameterNotFoundException if the parameter is not defined
     */
    public function get($name);
    /**
     * Removes a parameter.
     *
     * @param string $name The parameter name
     */
    public function remove($name);
    /**
     * Sets a service container parameter.
     *
     * @param string $name  The parameter name
     * @param mixed  $value The parameter value
     *
     * @throws LogicException if the parameter can not be set
     */
    public function set($name, $value);
    /**
     * Returns true if a parameter name is defined.
     *
     * @param string $name The parameter name
     *
     * @return bool true if the parameter name is defined, false otherwise
     */
    public function has($name);
    /**
     * Replaces parameter placeholders (%name%) by their values for all parameters.
     */
    public function resolve();
    /**
     * Replaces parameter placeholders (%name%) by their values.
     *
     * @param mixed $value A value
     *
     * @throws ParameterNotFoundException if a placeholder references a parameter that does not exist
     */
    public function resolveValue($value);
    /**
     * Escape parameter placeholders %.
     *
     * @param mixed $value
     *
     * @return mixed
     */
    public function escapeValue($value);
    /**
     * Unescape parameter placeholders %.
     *
     * @param mixed $value
     *
     * @return mixed
     */
    public function unescapeValue($value);
  }
  /**
   * Holds parameters.
   *
   * @author Fabien Potencier <fabien@symfony.com>
   */
  class ParameterBag implements \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface
  {
    protected $parameters = [];
    protected $resolved = \false;
    private $normalizedNames = [];
    /**
     * @param array $parameters An array of parameters
     */
    public function __construct(array $parameters = [])
    {
    }
    /**
     * Clears all parameters.
     */
    public function clear()
    {
    }
    /**
     * Adds parameters to the service container parameters.
     *
     * @param array $parameters An array of parameters
     */
    public function add(array $parameters)
    {
    }
    /**
     * {@inheritdoc}
     */
    public function all()
    {
    }
    /**
     * {@inheritdoc}
     */
    public function get($name)
    {
    }
    /**
     * Sets a service container parameter.
     *
     * @param string $name  The parameter name
     * @param mixed  $value The parameter value
     */
    public function set($name, $value)
    {
    }
    /**
     * {@inheritdoc}
     */
    public function has($name)
    {
    }
    /**
     * Removes a parameter.
     *
     * @param string $name The parameter name
     */
    public function remove($name)
    {
    }
    /**
     * {@inheritdoc}
     */
    public function resolve()
    {
    }
    /**
     * Replaces parameter placeholders (%name%) by their values.
     *
     * @param mixed $value     A value
     * @param array $resolving An array of keys that are being resolved (used internally to detect circular references)
     *
     * @return mixed The resolved value
     *
     * @throws ParameterNotFoundException          if a placeholder references a parameter that does not exist
     * @throws ParameterCircularReferenceException if a circular reference if detected
     * @throws RuntimeException                    when a given parameter has a type problem
     */
    public function resolveValue($value, array $resolving = [])
    {
    }
    /**
     * Resolves parameters inside a string.
     *
     * @param string $value     The string to resolve
     * @param array  $resolving An array of keys that are being resolved (used internally to detect circular references)
     *
     * @return mixed The resolved string
     *
     * @throws ParameterNotFoundException          if a placeholder references a parameter that does not exist
     * @throws ParameterCircularReferenceException if a circular reference if detected
     * @throws RuntimeException                    when a given parameter has a type problem
     */
    public function resolveString($value, array $resolving = [])
    {
    }
    public function isResolved()
    {
    }
    /**
     * {@inheritdoc}
     */
    public function escapeValue($value)
    {
    }
    /**
     * {@inheritdoc}
     */
    public function unescapeValue($value)
    {
    }
    private function normalizeName($name)
    {
    }
  }
  /**
   * @author Nicolas Grekas <p@tchwork.com>
   */
  class EnvPlaceholderParameterBag extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBag
  {
    private $envPlaceholders = [];
    private $providedTypes = [];
    /**
     * {@inheritdoc}
     */
    public function get($name)
    {
    }
    /**
     * Returns the map of env vars used in the resolved parameter values to their placeholders.
     *
     * @return string[][] A map of env var names to their placeholders
     */
    public function getEnvPlaceholders()
    {
    }
    /**
     * Merges the env placeholders of another EnvPlaceholderParameterBag.
     */
    public function mergeEnvPlaceholders(self $bag)
    {
    }
    /**
     * Maps env prefixes to their corresponding PHP types.
     */
    public function setProvidedTypes(array $providedTypes)
    {
    }
    /**
     * Gets the PHP types corresponding to env() parameter prefixes.
     *
     * @return string[][]
     */
    public function getProvidedTypes()
    {
    }
    /**
     * {@inheritdoc}
     */
    public function resolve()
    {
    }
  }
  /**
   * Holds read-only parameters.
   *
   * @author Fabien Potencier <fabien@symfony.com>
   */
  class FrozenParameterBag extends \YoastSEO_Vendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBag
  {
    /**
     * For performance reasons, the constructor assumes that
     * all keys are already lowercased.
     *
     * This is always the case when used internally.
     *
     * @param array $parameters An array of parameters
     */
    public function __construct(array $parameters = [])
    {
    }
    /**
     * {@inheritdoc}
     */
    public function clear()
    {
    }
    /**
     * {@inheritdoc}
     */
    public function add(array $parameters)
    {
    }
    /**
     * {@inheritdoc}
     */
    public function set($name, $value)
    {
    }
    /**
     * {@inheritdoc}
     */
    public function remove($name)
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Config {
  abstract class Config
  {
    /**
     * Try to return config values using the dot syntax.
     *
     * @param string|null $key The key of the config using the dot syntax.
     * @return array|mixed Returns the entire config array if not found, otherwise the value itself.
     */
    public static function get($key = null)
    {
    }
    /**
     * Should return an array with the config.
     *
     * @return array An array containing the config values.
     */
    protected static function values()
    {
    }
  }
  class EnvironmentConfig extends \YoastSEO_Vendor\WordProof\SDK\Config\Config
  {
    /**
     * Returns an array with the environment config.
     *
     * @return array
     */
    protected static function values()
    {
    }
  }
  class OptionsConfig extends \YoastSEO_Vendor\WordProof\SDK\Config\Config
  {
    /**
     * Returns an array with the settings config.
     *
     * @return array
     */
    protected static function values()
    {
    }
  }
  class RoutesConfig extends \YoastSEO_Vendor\WordProof\SDK\Config\Config
  {
    /**
     * Returns an array with the environment config.
     *
     * @return array
     */
    protected static function values()
    {
    }
  }
  class ScriptsConfig extends \YoastSEO_Vendor\WordProof\SDK\Config\Config
  {
    /**
     * Returns an array with the environment config.
     *
     * @return array
     */
    protected static function values()
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Controllers {
  class AuthenticationController
  {
    /**
     * Triggers the authentication flow.
     *
     * @param null $redirectUrl
     */
    public function authenticate($redirectUrl = null)
    {
    }
    /**
     * Adds admin page that redirects to the authentication flow.
     */
    public function addRedirectPage()
    {
    }
    /**
     * The content for the redirect page.
     */
    public function redirectPageContent()
    {
    }
    /**
     * Gets triggered by the 'load-admin_page_' hook of the redirect page
     */
    public function redirectOnLoad()
    {
    }
    /**
     * Adds self destruct admin page.
     */
    public function addSelfDestructPage()
    {
    }
    /**
     * Adds a script to the loaded page to close on load.
     */
    public function closeOnLoadContent()
    {
    }
  }
  class CertificateController
  {
    /**
     * Add scripts and schema to the head of the current page.
     *
     * @action wp_head
     */
    public function head()
    {
    }
    /**
     * Adds the certificate tag to the content before rendering it.
     *
     * @param $content
     * @return mixed|string Content string from 'the_content' filter
     * @filter the_content
     */
    public function certificateTag($content)
    {
    }
  }
  class NoticeController
  {
    /**
     * @var string[] The screens on which notices should be rendered.
     */
    private $screens = ['post'];
    /**
     * @var TranslationsInterface The translations objects,
     */
    private $translations;
    public function __construct(\YoastSEO_Vendor\WordProof\SDK\Translations\TranslationsInterface $translations)
    {
    }
    /**
     * Showing notices for the classic editor and delete them so they are only shown once.
     *
     * @action admin_notices
     */
    public function show()
    {
    }
  }
  class PostEditorDataController
  {
    /**
     * @var TranslationsInterface The translations objects,
     */
    private $translations;
    /**
     * PostEditorDataController constructor.
     *
     * @param TranslationsInterface $translations The implemented translations interface.
     */
    public function __construct(\YoastSEO_Vendor\WordProof\SDK\Translations\TranslationsInterface $translations)
    {
    }
    /**
     * Add script for post edit pages.
     *
     * @param string $hook The current page.
     */
    public function addScript($hook)
    {
    }
    /**
     * Localizes the elementor script.
     */
    public function addScriptForElementor()
    {
    }
    /**
     * Enqueues and localizes data script.
     */
    private function enqueueAndLocalizeScript()
    {
    }
  }
  class PostEditorTimestampController
  {
    private $metaKey = '_wordproof_timestamp';
    private $classicEditorNonceKey = 'wordproof_timestamp_classic_nonce';
    /**
     * Registers post meta for all public post types.
     *
     * @action init
     */
    public function registerPostMeta()
    {
    }
    /**
     * Returns if the current user can edit posts.
     *
     * @return boolean
     */
    public function userCanEditPosts()
    {
    }
    /**
     * Enqueues the wordproof-block-editor script.
     *
     * @action enqueue_block_editor_assets
     * @script wordproof-block-editor
     */
    public function enqueueBlockEditorScript()
    {
    }
    /**
     * Enqueues the wordproof-elementor-editor script.
     *
     * @action elementor/editor/after_enqueue_scripts
     * @script wordproof-elementor-editor
     */
    public function enqueueElementorEditorScript()
    {
    }
    /**
     * Enqueues the wordproof-classic-editor script.
     *
     * @action admin_enqueue_scripts
     * @script wordproof-classic-editor
     */
    public function enqueueClassicEditorScript($hook)
    {
    }
    /**
     * Add Metabox to classic editor.
     *
     * @action add_meta_boxes
     */
    public function addMetaboxToClassicEditor()
    {
    }
    /**
     * Save the meta box meta value for the classic editor.
     *
     * @param integer $postId The post ID.
     * @action save_post
     */
    public function saveClassicMetaboxPostMeta($postId)
    {
    }
    /**
     * Display the meta box HTML to Classic Editor users.
     *
     * @param \WP_Post $post Post object.
     */
    public function classicMetaboxHtml($post)
    {
    }
    /**
     * Registers control for the Elementor editor.
     *
     * @param \Elementor\Core\DocumentTypes\PageBase $document The PageBase document instance.
     *
     * @action elementor/documents/register_controls
     */
    public function registerControl($document)
    {
    }
    /**
     * @param integer $postId
     * @action elementor/document/save/data
     */
    public function elementorSave($postId)
    {
    }
  }
  class RestApiController
  {
    /**
     * Registers the rest api endpoints.
     *
     * @action rest_api_init
     * @throws \Exception
     */
    public function init()
    {
    }
    /**
     * Returns an object containing the settings.
     *
     * @return \WP_REST_Response Returns the settings.
     */
    public function settings()
    {
    }
    /**
     * Save the settings.
     *
     * @return \WP_REST_Response Returns the settings.
     */
    public function saveSettings(\WP_REST_Request $request)
    {
    }
    /**
     * Returns if the user is authenticated.
     *
     * @return \WP_REST_Response Returns if the user is authenticated.
     */
    public function authentication()
    {
    }
    /**
     * Logout the user and return if the user is authenticated.
     *
     * @return \WP_REST_Response Returns if the user is authenticated.
     */
    public function destroyAuthentication()
    {
    }
    /**
     * Send a post request to WordProof to timestamp a post.
     *
     * @param \WP_REST_Request $request The Rest Request.
     * @return \WP_REST_Response
     */
    public function timestamp(\WP_REST_Request $request)
    {
    }
    /**
     * The latest timestamp transaction is returned.
     *
     * @param \WP_REST_Request $request
     * @return \WP_REST_Response
     */
    public function showLatestTimestampTransaction(\WP_REST_Request $request)
    {
    }
    /**
     * Returns the hash input of a post.
     *
     * @param \WP_REST_Request $request The Rest Request.
     * @return \WP_REST_Response The hash input of a post.
     */
    public function hashInput(\WP_REST_Request $request)
    {
    }
    /**
     * Retrieves the access token when the code and state are retrieved in the frontend.
     *
     * @throws \Exception
     */
    public function authenticate(\WP_REST_Request $request)
    {
    }
    /**
     * Handles webhooks sent by WordProof.
     *
     * @param \WP_REST_Request $request The Rest Request.
     * @return bool|null|\WP_REST_Response|void The value returned by the action undertaken.
     *
     * TODO: Improve
     */
    public function webhook(\WP_REST_Request $request)
    {
    }
    /**
     * @param $response
     *
     * TODO: Improve
     */
    private function setBlockchainTransaction($response)
    {
    }
    /**
     * Checks if the user has permission to publish a post.
     *
     * @return bool Returns if a user has permission to publish.
     */
    public function canPublishPermission()
    {
    }
    /**
     * Validates if the webhook is valid and signed with the correct secret.
     *
     * @param \WP_REST_Request $request The Rest Request.
     * @return bool If the webhook can be accepted.
     */
    public static function isValidWebhookRequest(\WP_REST_Request $request)
    {
    }
  }
  class SettingsController
  {
    /**
     * Redirects user to the settings page. Returns false if not authenticated.
     *
     * @param null|string $redirectUrl
     * @return false
     */
    public function redirect($redirectUrl = null)
    {
    }
    /**
     * Adds admin page that will redirect the user to a predefined url.
     *
     * @action admin_menu
     */
    public function addRedirectPage()
    {
    }
    /**
     * The content for the redirect page. Triggered by addRedirectPage().
     */
    public function redirectPageContent()
    {
    }
    /**
     * Redirects user on admin page load to the settings page on the WordProof My.
     *
     * @action load-admin_page_settings
     */
    public function redirectOnLoad()
    {
    }
  }
  class TimestampController
  {
    /**
     * Timestamp an post triggered by custom action.
     *
     * @param integer $postId The post id to be timestamped.
     * @action wordproof_timestamp
     */
    public static function timestamp($postId)
    {
    }
    /**
     * Timestamp new posts except those inserted by the API.
     *
     * @param integer $postId The post id to be timestamped.
     * @param \WP_Post $post The post to be timestamped.
     * @action wp_insert_post
     */
    public function timestampAfterPostRequest($postId, $post)
    {
    }
    /**
     * Timestamp new attachments.
     *
     * @param integer $postId The post id to be timestamped.
     *
     * @action add_attachment|edit_attachment
     */
    public function timestampAfterAttachmentRequest($postId)
    {
    }
    /**
     * Timestamp posts inserted by the API.
     *
     * @param \WP_Post $post The post to be timestamped.
     * @action rest_after_insert_post
     */
    public function timestampAfterRestApiRequest($post)
    {
    }
    /**
     * Removes action to timestamp post on insert if Elementor is used.
     */
    public function beforeElementorSave()
    {
    }
    /**
     * Syncs timestamp override post meta keys.
     *
     * @param $metaId
     * @param $postId
     * @param $metaKey
     * @param $metaValue
     */
    public function syncPostMetaTimestampOverrides($metaId, $postId, $metaKey, $metaValue)
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\DataTransferObjects {
  class TimestampData
  {
    /**
     * Get timestamp data from post object.
     *
     * @param \WP_Post $post
     * @return array
     */
    public static function fromPost($post)
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Exceptions {
  class ValidationException extends \Exception
  {
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Helpers {
  class AdminHelper
  {
    /**
     * Returns the current admin url of the user.
     *
     * @return null|string The current admin url of the logged in user.
     */
    public static function currentUrl()
    {
    }
  }
  class AppConfigHelper
  {
    /**
     * Returns the partner set during initialization.
     *
     * @return string|null
     */
    public static function getPartner()
    {
    }
    /**
     * Returns the environment set during initialization.
     * @return string|null
     */
    public static function getEnvironment()
    {
    }
    /**
     * Returns the environment set during initialization.
     * @return boolean
     */
    public static function getLoadUikitFromCdn()
    {
    }
    public static function getAppConfig()
    {
    }
  }
  class AssetHelper
  {
    private static $prefix = 'wordproof-';
    private static $filePath = 'app/';
    private static $buildPath = 'build/';
    /**
     * Localizes script by name.
     *
     * @param string $name Name of the script
     * @param string $objectName The name of the object in Javascript.
     * @param array $data The data to be included.
     * @return bool|void
     */
    public static function localize($name, $objectName, $data)
    {
    }
    /**
     * Enqueues a script defined in the scripts config.
     *
     * @param string $name The name of the script to enqueue.
     * @return false|mixed|void
     */
    public static function enqueue($name)
    {
    }
    /**
     * Returns the prefixed script handle.
     *
     * @param string $name The name of the script.
     * @return string Handle of the script.
     */
    private static function getHandle($name)
    {
    }
    /**
     * Get path url of the script.
     *
     * @param string $name The name of the script.
     * @return string The url of the script.
     */
    private static function getPathUrl($name, $extension)
    {
    }
    /**
     * Returns version for file.
     *
     * @return false|string
     */
    private static function getVersion()
    {
    }
  }
  class AuthenticationHelper
  {
    /**
     * Removes all the options set by WordProof.
     *
     * @return void
     */
    public static function logout()
    {
    }
    /**
     * Returns if the user is authenticated.
     *
     * @return bool If the user is authenticated.
     */
    public static function isAuthenticated()
    {
    }
  }
  class CertificateHelper
  {
    /**
     * Returns if the certificate should be displayed for this page.
     *
     * @return false If the certificate should be shown.
     */
    public static function show()
    {
    }
  }
  class ClassicNoticeHelper
  {
    /**
     * @var string The key used for the transient to save the single notice.
     */
    public static $transientKey = 'wordproof_notice';
    /**
     * Add a new transient with a notice key.
     *
     * @param string $noticeKey The noticeKey that should be displayed to the user.
     */
    public static function add($noticeKey)
    {
    }
    /**
     * Add new notice depending on the timestamp response.
     *
     * @param \WP_REST_Response $response The timestamp response.
     */
    public static function addTimestampNotice($response)
    {
    }
    /**
     * Retrieve notice key for the timestamp response data.
     *
     * @param object $data The timestamp response data.
     * @return string The notice key for this response data.
     */
    private static function getNoticeKeyForTimestampResponse($data)
    {
    }
  }
  class EnvironmentHelper
  {
    public static function url()
    {
    }
    public static function client()
    {
    }
    public static function sslVerify()
    {
    }
    public static function development()
    {
    }
    public static function get($key)
    {
    }
    private static function environmentConfig()
    {
    }
  }
  class EscapeHelper
  {
    /**
     * Returns the value escaped according to the escape function set in the class.
     *
     * @param mixed $value The value to be sanitized.
     * @param string $escapeKey The escape function to be used.
     *
     * @return array|bool|int|string
     */
    public static function escape($value, $escapeKey)
    {
    }
    /**
     * Loops through the array to escape the values inside.
     *
     * @param array $array The array with values to be escaped.
     * @param string $escapeKey The escape function to be used.
     * @return array Array with escapes values.
     */
    private static function escapeArray($array, $escapeKey)
    {
    }
    /**
     * Escapes a single value using an escape function set in the class.
     *
     * @param string $value The value to be escaped.
     * @param string $escapeKey The escape function to be used.
     * @return bool|int|string The escaped value.
     */
    private static function escapeSingleValue($value, $escapeKey)
    {
    }
  }
  class OptionsHelper
  {
    private static $prefix = 'wordproof_';
    /**
     * Sets site option while properly sanitizing the data.
     *
     * @param string $key The key to set.
     * @param mixed $value The value to save.
     * @return bool If update_option succeeded.
     */
    public static function set($key, $value)
    {
    }
    /**
     * Deletes the site options.
     *
     * @param string $key The key to be deleted.
     * @return mixed
     */
    public static function delete($key)
    {
    }
    /**
     * Retrieves the site option while properly escaping the data.
     *
     * @param string $key The site option.
     * @return array|bool|int|object|string
     */
    public static function get($key)
    {
    }
    /**
     * Returns all site options as object.
     *
     * @return object
     */
    public static function all()
    {
    }
    /**
     * Deletes all site options.
     */
    public static function reset()
    {
    }
    /**
     * Deletes authentication options.
     */
    public static function resetAuthentication()
    {
    }
    /**
     * Retrieves the access token.
     *
     * @return string|null
     */
    public static function accessToken()
    {
    }
    /**
     * Retrieves the source id.
     *
     * @return integer|null
     */
    public static function sourceId()
    {
    }
    /**
     * Sets the access token.
     *
     * @param string|null $value The access token to be set.
     * @return bool
     */
    public static function setAccessToken($value)
    {
    }
    /**
     * Sets the source id.
     *
     * @param integer|null $value The source id to be set.
     * @return bool
     */
    public static function setSourceId($value)
    {
    }
    /**
     * Retrieves the option settings from the config.
     *
     * @param string $key The option key.
     * @return array|false|mixed
     */
    private static function getOptionFromConfig($key)
    {
    }
    /**
     * Returns if the given option key contains options itself.
     *
     * @param string $key The option key to be checked.
     * @return bool
     */
    private static function optionContainsOptions($key)
    {
    }
    /**
     * Loops through an option that contains options to either sanitize or escape the result.
     *
     * @param $key
     * @param $value
     * @param string $method
     * @return array|object
     */
    private static function secureOptionWithOptions($key, $value, $method = 'sanitize')
    {
    }
  }
  class PostEditorHelper
  {
    /**
     * Returns the post editor that is in use.
     *
     * @return bool The post editor the user is using..
     */
    public static function getPostEditor()
    {
    }
    /**
     * Returns if the page is a post edit page.
     *
     * @param string $page The page to check.
     * @return bool If the current page is a post edit page.
     */
    public static function isPostEdit($page)
    {
    }
    /**
     * Returns an array of edit page hooks.
     *
     * @return array Post edit page hooks.
     */
    public static function getPostEditPages()
    {
    }
    /**
     * Returns the data that should be added to the post editor.
     *
     * @param TranslationsInterface $translations The implemented translations interface.
     *
     * @return array[] The post editor data.
     */
    public static function getPostEditorData(\YoastSEO_Vendor\WordProof\SDK\Translations\TranslationsInterface $translations)
    {
    }
    /**
     * Returns the current post type.
     *
     * @return null|string The current post type.
     */
    public static function getCurrentPostType()
    {
    }
  }
  class PostMetaHelper
  {
    /**
     * @param integer $postId The post id for which the meta should be set.
     * @param string $key The key for the post meta.
     * @param mixed $value The value for the post meta.
     * @return integer|boolean Returns the post meta id or false on failure.
     */
    public static function add($postId, $key, $value, $single = \false)
    {
    }
    /**
     * @param integer $postId The post id for which the meta should be set.
     * @param string $key The key for the post meta.
     * @param mixed $value The value for the post meta.
     * @return integer|boolean Returns the post meta id or false on failure.
     */
    public static function update($postId, $key, $value)
    {
    }
    /**
     * @param integer $postId The post id for which the meta should be set.
     * @param string $key The key for the post meta.
     * @param bool $single If a single result should be returned.
     * @return mixed Returns the post meta data or false on failure.
     */
    public static function get($postId, $key, $single = \true)
    {
    }
    /**
     * @param integer $postId The post id for which the meta should be set.
     * @param string $key The key for the post meta.
     * @return boolean Returns if the post meta key exists for the post id.
     */
    public static function has($postId, $key)
    {
    }
  }
  class PostTypeHelper
  {
    /**
     * Returns public post types.
     *
     * @return array The public post types.
     */
    public static function getPublicPostTypes()
    {
    }
    public static function getUnprotectedPosts($postType)
    {
    }
  }
  class RedirectHelper
  {
    /**
     * Does a safe redirect to an admin page.
     *
     * @param string $url The url to be redirected to.
     */
    public static function safe($url)
    {
    }
  }
  class ReflectionHelper
  {
    /**
     * @param class $instance The class from which to get the name.
     * @return false|string
     */
    public static function name($instance)
    {
    }
  }
  class RestApiHelper
  {
    private static function buildPath($endpoint)
    {
    }
    public static function getNamespace()
    {
    }
    public static function route($slug)
    {
    }
    public static function endpoint($slug)
    {
    }
    public static function getRestRoute($slug, $params = [])
    {
    }
  }
  class SanitizeHelper
  {
    /**
     * Returns the value sanitized according to the escape function set in the class.
     *
     * @param mixed $value The value to be sanitized.
     * @param string $sanitizeKey The sanitize function to be used.
     *
     * @return array|bool|int|string
     */
    public static function sanitize($value, $sanitizeKey)
    {
    }
    /**
     * Loops through the array to sanitize the values inside.
     *
     * @param array $array The array with values to be escaped.
     * @param string $sanitizeKey The sanitize function to be used.
     * @return array Array with escapes values.
     */
    private static function sanitizeArray($array, $sanitizeKey)
    {
    }
    /**
     * Sanitize a single value using an escape function set in the class.
     *
     * @param string $value The value to be sanitized.
     * @param string $sanitizeKey The sanitize function to be used.
     * @return bool|int|string The sanitized value.
     */
    private static function sanitizeSingleValue($value, $sanitizeKey)
    {
    }
  }
  class SchemaHelper
  {
    /**
     * Builds an blockchain transaction schema object as array.
     *
     * @param object $response The response by WordProof.
     * @return array The blockchain transaction in the correct schema format.
     */
    public static function getBlockchainTransaction($response)
    {
    }
    /**
     * Retrieves the schema as array for a post.
     *
     * @param integer $postId The post id for which the schema should be returned.
     * @return array The schema as array.
     */
    public static function getSchema($postId)
    {
    }
  }
  class SettingsHelper
  {
    private static $key = 'settings';
    /**
     * Retrieving settings from the option.
     *
     * @param null $setting The key for the setting
     * @return array|bool|int|mixed|object|string|null
     */
    public static function get($setting = null)
    {
    }
    public static function showRevisions()
    {
    }
    public static function certificateLinkText()
    {
    }
    public static function hideCertificateLink()
    {
    }
    public static function selectedPostTypes()
    {
    }
    public static function postTypeIsInSelectedPostTypes($postType)
    {
    }
  }
  class StringHelper
  {
    /**
     * Replace the last occurrence.
     *
     * @param string $search
     * @param string $replace
     * @param string $subject
     * @return string
     */
    public static function lastReplace($search, $replace, $subject)
    {
    }
    /**
     * PascalCase to snake_case
     *
     * @param $string
     * @return string
     */
    public static function toUnderscore($string)
    {
    }
  }
  class TimestampHelper
  {
    public static function debounce(\WP_Post $post)
    {
    }
    public static function shouldBeTimestamped(\WP_Post $post, $data)
    {
    }
    private static function hasPostMetaOverrideSetToTrue(\WP_Post $post)
    {
    }
  }
  class TransientHelper
  {
    /**
     * Set transient.
     *
     * @param $key
     * @param $value
     * @param int $expiration
     * @return bool
     */
    public static function set($key, $value, $expiration = 0)
    {
    }
    /**
     * Returns and deletes site transient by key.
     *
     * @param $key
     * @return mixed
     */
    public static function getOnce($key)
    {
    }
    /**
     * Returns the transient by key.
     *
     * @param $key
     * @return mixed
     */
    public static function get($key)
    {
    }
    /**
     * Debounce callback for post id.
     *
     * @param $postId
     * @param $action
     * @param $callback
     * @return mixed
     */
    public static function debounce($postId, $action, $callback)
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Support {
  class Api
  {
    /**
     * @param string $endpoint
     * @param array $body
     * @return mixed
     */
    public static function post($endpoint, $body = [])
    {
    }
  }
  class Authentication
  {
    private static $callbackEndpoint = 'wordproof/v1/oauth/callback';
    public static function authorize($redirectUrl = null)
    {
    }
    /**
     * Retrieve the access token with the state and code.
     *
     * @param string $state The state from remote
     * @param string $code The code from remote
     * @return \WP_REST_Response
     * @throws \Exception
     */
    public static function token($state, $code)
    {
    }
    private static function getCallbackUrl()
    {
    }
    public static function redirect($endpoint, $parameters)
    {
    }
  }
  class Loader
  {
    protected $actions;
    protected $filters;
    public function __construct()
    {
    }
    /**
     * @param string $hook The name of the WordPress action that is being registered.
     * @param object $component A reference to the instance of the object on which the action is defined.
     * @param string $callback The name of the function definition on the $component.
     * @param int $priority Optional. The priority at which the function should be fired. Default is 10.
     * @param int $accepted_args Optional. The number of arguments that should be passed to the $callback. Default is 1.
     */
    public function addAction($hook, $component, $callback, $priority = 10, $accepted_args = 1)
    {
    }
    /**
     * @param string $hook The name of the WordPress filter that is being registered.
     * @param object $component A reference to the instance of the object on which the filter is defined.
     * @param string $callback The name of the function definition on the $component.
     * @param int $priority Optional. The priority at which the function should be fired. Default is 10.
     * @param int $accepted_args Optional. The number of arguments that should be passed to the $callback. Default is 1
     */
    public function addFilter($hook, $component, $callback, $priority = 10, $accepted_args = 1)
    {
    }
    public function run()
    {
    }
    private function add($hooks, $hook, $component, $callback, $priority, $accepted_args)
    {
    }
  }
  class Settings
  {
    public static function redirect($redirectUrl = null)
    {
    }
  }
  class Template
  {
    private static $blocks = [];
    private static $cache_path = 'cache/';
    private static $template_path = 'templates/';
    private static $cache_enabled = \true;
    private static $store_cache = \false;
    public static function setOptions(array $options)
    {
    }
    public static function setCachePath($path)
    {
    }
    public static function setTemplatePath($path)
    {
    }
    public static function render($file, $data = [])
    {
    }
    public static function view($file, $data = [])
    {
    }
    private static function cache($file)
    {
    }
    public static function clearCache()
    {
    }
    private static function compileCode($code)
    {
    }
    private static function includeFiles($file)
    {
    }
    private static function compilePHP($code)
    {
    }
    private static function compileEchos($code)
    {
    }
    private static function compileEscapedEchos($code)
    {
    }
    private static function compileBlock($code)
    {
    }
    private static function compileYield($code)
    {
    }
  }
  class Timestamp
  {
    /**
     * @param array $data
     *
     * @return mixed
     */
    public static function sendPostRequest($data)
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK\Translations {
  class DefaultTranslations implements \YoastSEO_Vendor\WordProof\SDK\Translations\TranslationsInterface
  {
    public function getNoBalanceNotice()
    {
    }
    public function getTimestampFailedNotice()
    {
    }
    public function getTimestampSuccessNotice()
    {
    }
    public function getWebhookFailedNotice()
    {
    }
    public function getNotAuthenticatedNotice()
    {
    }
    public function getOpenAuthenticationButtonText()
    {
    }
    public function getOpenSettingsButtonText()
    {
    }
    public function getContactWordProofSupportButtonText()
    {
    }
  }
}

namespace YoastSEO_Vendor\WordProof\SDK {
  class WordPressSDK
  {
    /**
     * The version of this SDK
     * @var string
     */
    public $version = '1.3.2';
    /**
     * @var null|WordPressSDK
     */
    private static $instance = null;
    /**
     * Loader responsible for the WordPress hooks
     * @var Loader
     */
    private $loader;
    /**
     * Appconfig object
     * @var AppConfigInterface
     */
    public $appConfig;
    /**
     * Translations object
     * @var TranslationsInterface
     */
    private $translations;
    /**
     * WordPressSDK constructor.
     *
     * @return WordPressSDK|void
     *
     * @throws \Exception
     */
    public function __construct(\YoastSEO_Vendor\WordProof\SDK\Config\AppConfigInterface $appConfig = null, \YoastSEO_Vendor\WordProof\SDK\Translations\TranslationsInterface $translations = null)
    {
    }
    /**
     * Singleton implementation of WordPress SDK.
     *
     * @param AppConfigInterface|null $appConfig
     * @param TranslationsInterface|null $translations
     * @return WordPressSDK|null Returns the WordPress SDK instance.
     * @throws \Exception
     */
    public static function getInstance(\YoastSEO_Vendor\WordProof\SDK\Config\AppConfigInterface $appConfig = null, \YoastSEO_Vendor\WordProof\SDK\Translations\TranslationsInterface $translations = null)
    {
    }
    /**
     * Runs the loader and initializes the class.
     *
     * @return $this
     */
    public function initialize()
    {
    }
    /**
     * Initializes the authentication feature.
     */
    private function authentication()
    {
    }
    /**
     * Initializes the api feature.
     */
    private function api()
    {
    }
    /**
     * Adds hooks to timestamp posts on new inserts or on a custom action.
     */
    private function timestamp()
    {
    }
    /**
     * Adds admin pages that redirect to the WordProof My settings page.
     */
    private function settings()
    {
    }
    /**
     * Registers and localizes post editor scripts.
     */
    private function postEditorData()
    {
    }
    /**
     * Initializes the notices feature.
     */
    private function notices()
    {
    }
    /**
     * Optional feature to include the schema and certificate to the page.
     *
     * @return $this
     */
    public function certificate()
    {
    }
    /**
     * Optional feature to timestamp with JS in the post editor.
     *
     * @return $this
     */
    public function timestampInPostEditor()
    {
    }
  }
}

namespace {
  /**
   * Convenience function to JSON encode and echo results and then die.
   *
   * @param array $results Results array for encoding.
   */
  function wpseo_ajax_json_echo_die($results)
  {
  }
  /**
   * Function used from AJAX calls, takes it variables from $_POST, dies on exit.
   */
  function wpseo_set_option()
  {
  }
  /**
   * Function used to remove the admin notices for several purposes, dies on exit.
   */
  function wpseo_set_ignore()
  {
  }
  /**
   * Save an individual SEO title from the Bulk Editor.
   */
  function wpseo_save_title()
  {
  }
  /**
   * Save an individual meta description from the Bulk Editor.
   */
  function wpseo_save_description()
  {
  }
  /**
   * Save titles & descriptions.
   *
   * @param string $what Type of item to save (title, description).
   */
  function wpseo_save_what($what)
  {
  }
  /**
   * Helper function to update a post's meta data, returning relevant information
   * about the information updated and the results or the meta update.
   *
   * @param int    $post_id         Post ID.
   * @param string $new_meta_value  New meta value to record.
   * @param string $orig_meta_value Original meta value.
   * @param string $meta_key        Meta key string.
   * @param string $return_key      Return key string to use in results.
   *
   * @return array
   */
  function wpseo_upsert_meta($post_id, $new_meta_value, $orig_meta_value, $meta_key, $return_key)
  {
  }
  /**
   * Save all titles sent from the Bulk Editor.
   */
  function wpseo_save_all_titles()
  {
  }
  /**
   * Save all description sent from the Bulk Editor.
   */
  function wpseo_save_all_descriptions()
  {
  }
  /**
   * Utility function to save values.
   *
   * @param string $what Type of item so save.
   */
  function wpseo_save_all($what)
  {
  }
  /**
   * Insert a new value.
   *
   * @param string $what      Item type (such as title).
   * @param int    $post_id   Post ID.
   * @param string $new_value New value to record.
   * @param string $original  Original value.
   *
   * @return string
   */
  function wpseo_upsert_new($what, $post_id, $new_value, $original)
  {
  }
  /**
   * Retrieves the post ids where the keyword is used before as well as the types of those posts.
   */
  function ajax_get_keyword_usage_and_post_types()
  {
  }
  /**
   * Retrieves the keyword for the keyword doubles of the termpages.
   */
  function ajax_get_term_keyword_usage()
  {
  }
  /**
   * Registers hooks for all AJAX integrations.
   *
   * @return void
   */
  function wpseo_register_ajax_integrations()
  {
  }
  /* ********************* DEPRECATED FUNCTIONS ********************* */
  /**
   * Retrieves the keyword for the keyword doubles.
   */
  function ajax_get_keyword_usage()
  {
  }
  /**
   * Create the notifications HTML with restore/dismiss button.
   *
   * @param array  $notifications_list List of notifications.
   * @param string $status             Status of the notifications (active/dismissed).
   *
   * @return string The output to render.
   */
  function _yoast_display_notifications($notifications_list, $status)
  {
  }
  /**
   * Creates a select box given a name and plugins array.
   *
   * @param string $name    Name field for the select field.
   * @param array  $plugins An array of plugins and classes.
   *
   * @return void
   */
  function wpseo_import_external_select($name, $plugins)
  {
  }
  /**
   * Sanitizes the parameters that have been sent.
   *
   * @return array The sanitized fields.
   */
  function yoast_free_bulk_sanitize_input_fields()
  {
  }
  /**
   * Renders a bulk editor tab.
   *
   * @param WPSEO_Bulk_List_Table $table The table to render.
   * @param string                $id    The id for the tab.
   */
  function wpseo_get_rendered_tab($table, $id)
  {
  }
  /**
   * Template tag for breadcrumbs.
   *
   * @param string $before  What to show before the breadcrumb.
   * @param string $after   What to show after the breadcrumb.
   * @param bool   $display Whether to display the breadcrumb (true) or return it (false).
   *
   * @return string
   */
  function yoast_breadcrumb($before = '', $after = '', $display = \true)
  {
  }
  /**
   * Get the primary term ID.
   *
   * @param string           $taxonomy Optional. The taxonomy to get the primary term ID for. Defaults to category.
   * @param int|WP_Post|null $post     Optional. Post to get the primary term ID for.
   *
   * @return bool|int
   */
  function yoast_get_primary_term_id($taxonomy = 'category', $post = \null)
  {
  }
  /**
   * Get the primary term name.
   *
   * @param string           $taxonomy Optional. The taxonomy to get the primary term for. Defaults to category.
   * @param int|WP_Post|null $post     Optional. Post to get the primary term for.
   *
   * @return string Name of the primary term.
   */
  function yoast_get_primary_term($taxonomy = 'category', $post = \null)
  {
  }
  /**
   * Replace `%%variable_placeholders%%` with their real value based on the current requested page/post/cpt.
   *
   * @param string $text The string to replace the variables in.
   * @param object $args The object some of the replacement values might come from,
   *                     could be a post, taxonomy or term.
   * @param array  $omit Variables that should not be replaced by this function.
   *
   * @return string
   */
  function wpseo_replace_vars($text, $args, $omit = [])
  {
  }
  /**
   * Register a new variable replacement.
   *
   * This function is for use by other plugins/themes to easily add their own additional variables to replace.
   * This function should be called from a function on the 'wpseo_register_extra_replacements' action hook.
   * The use of this function is preferred over the older 'wpseo_replacements' filter as a way to add new replacements.
   * The 'wpseo_replacements' filter should still be used to adjust standard WPSEO replacement values.
   * The function can not be used to replace standard WPSEO replacement value functions and will thrown a warning
   * if you accidently try.
   * To avoid conflicts with variables registered by WPSEO and other themes/plugins, try and make the
   * name of your variable unique. Variable names also can not start with "%%cf_" or "%%ct_" as these are reserved
   * for the standard WPSEO variable variables 'cf_<custom-field-name>', 'ct_<custom-tax-name>' and
   * 'ct_desc_<custom-tax-name>'.
   * The replacement function will be passed the undelimited name (i.e. stripped of the %%) of the variable
   * to replace in case you need it.
   *
   * Example code:
   * <code>
   *
   * function retrieve_var1_replacement( $var1 ) {
   *        return 'your replacement value';
   * }
   *
   * function register_my_plugin_extra_replacements() {
   *        wpseo_register_var_replacement( '%%myvar1%%', 'retrieve_var1_replacement', 'advanced', 'this is a help text for myvar1' );
   *        wpseo_register_var_replacement( 'myvar2', array( 'class', 'method_name' ), 'basic', 'this is a help text for myvar2' );
   * }
   * add_action( 'wpseo_register_extra_replacements', 'register_my_plugin_extra_replacements' );
   *
   * </code>
   *
   * @since 1.5.4
   *
   * @param string $replacevar_name  The name of the variable to replace, i.e. '%%var%%'.
   *                                 Note: the surrounding %% are optional, name can only contain [A-Za-z0-9_-].
   * @param mixed  $replace_function Function or method to call to retrieve the replacement value for the variable.
   *                                 Uses the same format as add_filter/add_action function parameter and
   *                                 should *return* the replacement value. DON'T echo it.
   * @param string $type             Type of variable: 'basic' or 'advanced', defaults to 'advanced'.
   * @param string $help_text        Help text to be added to the help tab for this variable.
   *
   * @return bool Whether the replacement function was successfully registered.
   */
  function wpseo_register_var_replacement($replacevar_name, $replace_function, $type = 'advanced', $help_text = '')
  {
  }
  /**
   * WPML plugin support: Set titles for custom types / taxonomies as translatable.
   *
   * It adds new keys to a wpml-config.xml file for a custom post type title, metadesc,
   * title-ptarchive and metadesc-ptarchive fields translation.
   * Documentation: http://wpml.org/documentation/support/language-configuration-files/
   *
   * @global $sitepress
   *
   * @param array $config WPML configuration data to filter.
   *
   * @return array
   */
  function wpseo_wpml_config($config)
  {
  }
  /**
   * Makes sure the taxonomy meta is updated when a taxonomy term is split.
   *
   * @link https://make.wordpress.org/core/2015/02/16/taxonomy-term-splitting-in-4-2-a-developer-guide/ Article explaining the taxonomy term splitting in WP 4.2.
   *
   * @param string $old_term_id      Old term id of the taxonomy term that was splitted.
   * @param string $new_term_id      New term id of the taxonomy term that was splitted.
   * @param string $term_taxonomy_id Term taxonomy id for the taxonomy that was affected.
   * @param string $taxonomy         The taxonomy that the taxonomy term was splitted for.
   */
  function wpseo_split_shared_term($old_term_id, $new_term_id, $term_taxonomy_id, $taxonomy)
  {
  }
  /**
   * Get all WPSEO related capabilities.
   *
   * @since 8.3
   * @return array
   */
  function wpseo_get_capabilities()
  {
  }
  /**
   * Initializes the admin bar.
   *
   * @return void
   */
  function wpseo_initialize_admin_bar()
  {
  }
  /**
   * Allows editing of the meta fields through weblog editors like Marsedit.
   *
   * @param array $required_capabilities Capabilities that must all be true to allow action.
   * @param array $capabilities          Array of capabilities to be checked, unused here.
   * @param array $args                  List of arguments for the specific capabilities to be checked.
   *
   * @return array Filtered capabilities.
   */
  function allow_custom_field_edits($required_capabilities, $capabilities, $args)
  {
  }
  /**
   * Retrieves the main instance.
   *
   * @phpcs:disable WordPress.NamingConventions -- Should probably be renamed, but leave for now.
   *
   * @return Main The main instance.
   */
  function YoastSEO()
  {
  }
  /* ***************************** CLASS AUTOLOADING *************************** */
  /**
   * Autoload our class files.
   *
   * @param string $class_name Class name.
   *
   * @return void
   */
  function wpseo_auto_load($class_name)
  {
  }
  /* ***************************** PLUGIN (DE-)ACTIVATION *************************** */
  /**
   * Run single site / network-wide activation of the plugin.
   *
   * @param bool $networkwide Whether the plugin is being activated network-wide.
   */
  function wpseo_activate($networkwide = \false)
  {
  }
  /**
   * Run single site / network-wide de-activation of the plugin.
   *
   * @param bool $networkwide Whether the plugin is being de-activated network-wide.
   */
  function wpseo_deactivate($networkwide = \false)
  {
  }
  /**
   * Run network-wide (de-)activation of the plugin.
   *
   * @param bool $activate True for plugin activation, false for de-activation.
   */
  function wpseo_network_activate_deactivate($activate = \true)
  {
  }
  /**
   * Runs on activation of the plugin.
   */
  function _wpseo_activate()
  {
  }
  /**
   * On deactivation, flush the rewrite rules so XML sitemaps stop working.
   */
  function _wpseo_deactivate()
  {
  }
  /**
   * Run wpseo activation routine on creation / activation of a multisite blog if WPSEO is activated
   * network-wide.
   *
   * Will only be called by multisite actions.
   *
   * {@internal Unfortunately will fail if the plugin is in the must-use directory.
   *            {@link https://core.trac.wordpress.org/ticket/24205} }}
   *
   * @param int|WP_Site $blog_id Blog ID.
   */
  function wpseo_on_activate_blog($blog_id)
  {
  }
  /* ***************************** PLUGIN LOADING *************************** */
  /**
   * Load translations.
   */
  function wpseo_load_textdomain()
  {
  }
  /**
   * On plugins_loaded: load the minimum amount of essential files for this plugin.
   */
  function wpseo_init()
  {
  }
  /**
   * Loads the rest api endpoints.
   */
  function wpseo_init_rest_api()
  {
  }
  /**
   * Used to load the required files on the plugins_loaded hook, instead of immediately.
   */
  function wpseo_admin_init()
  {
  }
  /**
   * Wraps for notifications center class.
   */
  function load_yoast_notifications()
  {
  }
  /**
   * Throw an error if the PHP SPL extension is disabled (prevent white screens) and self-deactivate plugin.
   *
   * @since 1.5.4
   *
   * @return void
   */
  function yoast_wpseo_missing_spl()
  {
  }
  /**
   * Returns the notice in case of missing spl extension.
   */
  function yoast_wpseo_missing_spl_notice()
  {
  }
  /**
   * Throw an error if the Composer autoload is missing and self-deactivate plugin.
   *
   * @return void
   */
  function yoast_wpseo_missing_autoload()
  {
  }
  /**
   * Returns the notice in case of missing Composer autoload.
   */
  function yoast_wpseo_missing_autoload_notice()
  {
  }
  /**
   * Throw an error if the filter extension is disabled (prevent white screens) and self-deactivate plugin.
   *
   * @since 2.0
   *
   * @return void
   */
  function yoast_wpseo_missing_filter()
  {
  }
  /**
   * Returns the notice in case of missing filter extension.
   */
  function yoast_wpseo_missing_filter_notice()
  {
  }
  /**
   * Echo's the Activation failed notice with any given message.
   *
   * @param string $message Message string.
   */
  function yoast_wpseo_activation_failed_notice($message)
  {
  }
  /**
   * The method will deactivate the plugin, but only once, done by the static $is_deactivated.
   */
  function yoast_wpseo_self_deactivate()
  {
  }
}

namespace Yoast\WP\Free\Loggers {
  class Migration_Logger
  {
  }
}

namespace {
  define('WPSEO_VERSION', '0.0.0');
}
